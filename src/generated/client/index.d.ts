/**
 * Client
 **/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model Account
 *
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>;
/**
 * Model Session
 *
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>;
/**
 * Model VerificationToken
 *
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>;
/**
 * Model User
 *
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>;
/**
 * Model Category
 *
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>;
/**
 * Model Service
 *
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>;
/**
 * Model ServiceField
 *
 */
export type ServiceField = $Result.DefaultSelection<Prisma.$ServiceFieldPayload>;
/**
 * Model ServiceFieldOption
 *
 */
export type ServiceFieldOption = $Result.DefaultSelection<Prisma.$ServiceFieldOptionPayload>;
/**
 * Model ServiceVariant
 *
 */
export type ServiceVariant = $Result.DefaultSelection<Prisma.$ServiceVariantPayload>;
/**
 * Model Order
 *
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>;
/**
 * Model Payment
 *
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>;
/**
 * Model AuditLog
 *
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>;
/**
 * Model FAQ
 *
 */
export type FAQ = $Result.DefaultSelection<Prisma.$FAQPayload>;
/**
 * Model Document
 *
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>;
/**
 * Model OrderDocument
 *
 */
export type OrderDocument = $Result.DefaultSelection<Prisma.$OrderDocumentPayload>;
/**
 * Model ServiceDocument
 *
 */
export type ServiceDocument = $Result.DefaultSelection<Prisma.$ServiceDocumentPayload>;
/**
 * Model SystemSettings
 *
 */
export type SystemSettings = $Result.DefaultSelection<Prisma.$SystemSettingsPayload>;
/**
 * Model FormType
 * Forms inventory ("العهدة")
 */
export type FormType = $Result.DefaultSelection<Prisma.$FormTypePayload>;
/**
 * Model FormTypeVariant
 *
 */
export type FormTypeVariant = $Result.DefaultSelection<Prisma.$FormTypeVariantPayload>;
/**
 * Model FormSerial
 *
 */
export type FormSerial = $Result.DefaultSelection<Prisma.$FormSerialPayload>;
/**
 * Model Dependent
 *
 */
export type Dependent = $Result.DefaultSelection<Prisma.$DependentPayload>;
/**
 * Model PromoCode
 *
 */
export type PromoCode = $Result.DefaultSelection<Prisma.$PromoCodePayload>;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions
    ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions['log']>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] };

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(
    eventType: V,
    callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void
  ): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void;

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel }
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>,
    options?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    }
  ): $Utils.JsPromise<R>;

  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Sessions
   * const sessions = await prisma.session.findMany()
   * ```
   */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more VerificationTokens
   * const verificationTokens = await prisma.verificationToken.findMany()
   * ```
   */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Categories
   * const categories = await prisma.category.findMany()
   * ```
   */
  get category(): Prisma.CategoryDelegate<ExtArgs>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Services
   * const services = await prisma.service.findMany()
   * ```
   */
  get service(): Prisma.ServiceDelegate<ExtArgs>;

  /**
   * `prisma.serviceField`: Exposes CRUD operations for the **ServiceField** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ServiceFields
   * const serviceFields = await prisma.serviceField.findMany()
   * ```
   */
  get serviceField(): Prisma.ServiceFieldDelegate<ExtArgs>;

  /**
   * `prisma.serviceFieldOption`: Exposes CRUD operations for the **ServiceFieldOption** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ServiceFieldOptions
   * const serviceFieldOptions = await prisma.serviceFieldOption.findMany()
   * ```
   */
  get serviceFieldOption(): Prisma.ServiceFieldOptionDelegate<ExtArgs>;

  /**
   * `prisma.serviceVariant`: Exposes CRUD operations for the **ServiceVariant** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ServiceVariants
   * const serviceVariants = await prisma.serviceVariant.findMany()
   * ```
   */
  get serviceVariant(): Prisma.ServiceVariantDelegate<ExtArgs>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Orders
   * const orders = await prisma.order.findMany()
   * ```
   */
  get order(): Prisma.OrderDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Payments
   * const payments = await prisma.payment.findMany()
   * ```
   */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more AuditLogs
   * const auditLogs = await prisma.auditLog.findMany()
   * ```
   */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.fAQ`: Exposes CRUD operations for the **FAQ** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more FAQS
   * const fAQS = await prisma.fAQ.findMany()
   * ```
   */
  get fAQ(): Prisma.FAQDelegate<ExtArgs>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Documents
   * const documents = await prisma.document.findMany()
   * ```
   */
  get document(): Prisma.DocumentDelegate<ExtArgs>;

  /**
   * `prisma.orderDocument`: Exposes CRUD operations for the **OrderDocument** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more OrderDocuments
   * const orderDocuments = await prisma.orderDocument.findMany()
   * ```
   */
  get orderDocument(): Prisma.OrderDocumentDelegate<ExtArgs>;

  /**
   * `prisma.serviceDocument`: Exposes CRUD operations for the **ServiceDocument** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ServiceDocuments
   * const serviceDocuments = await prisma.serviceDocument.findMany()
   * ```
   */
  get serviceDocument(): Prisma.ServiceDocumentDelegate<ExtArgs>;

  /**
   * `prisma.systemSettings`: Exposes CRUD operations for the **SystemSettings** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more SystemSettings
   * const systemSettings = await prisma.systemSettings.findMany()
   * ```
   */
  get systemSettings(): Prisma.SystemSettingsDelegate<ExtArgs>;

  /**
   * `prisma.formType`: Exposes CRUD operations for the **FormType** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more FormTypes
   * const formTypes = await prisma.formType.findMany()
   * ```
   */
  get formType(): Prisma.FormTypeDelegate<ExtArgs>;

  /**
   * `prisma.formTypeVariant`: Exposes CRUD operations for the **FormTypeVariant** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more FormTypeVariants
   * const formTypeVariants = await prisma.formTypeVariant.findMany()
   * ```
   */
  get formTypeVariant(): Prisma.FormTypeVariantDelegate<ExtArgs>;

  /**
   * `prisma.formSerial`: Exposes CRUD operations for the **FormSerial** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more FormSerials
   * const formSerials = await prisma.formSerial.findMany()
   * ```
   */
  get formSerial(): Prisma.FormSerialDelegate<ExtArgs>;

  /**
   * `prisma.dependent`: Exposes CRUD operations for the **Dependent** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Dependents
   * const dependents = await prisma.dependent.findMany()
   * ```
   */
  get dependent(): Prisma.DependentDelegate<ExtArgs>;

  /**
   * `prisma.promoCode`: Exposes CRUD operations for the **PromoCode** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more PromoCodes
   * const promoCodes = await prisma.promoCode.findMany()
   * ```
   */
  get promoCode(): Prisma.PromoCodeDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;

  export type PrismaPromise<T> = $Public.PrismaPromise<T>;

  /**
   * Validator
   */
  export import validator = runtime.Public.validator;

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;
  export import NotFoundError = runtime.NotFoundError;

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  export type DecimalJsLike = runtime.DecimalJsLike;

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics;
  export type Metric<T> = runtime.Metric<T>;
  export type MetricHistogram = runtime.MetricHistogram;
  export type MetricHistogramBucket = runtime.MetricHistogramBucket;

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs;
  export import getExtensionContext = runtime.Extensions.getExtensionContext;
  export import Args = $Public.Args;
  export import Payload = $Public.Payload;
  export import Result = $Public.Result;
  export import Exact = $Public.Exact;

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  export import JsonObject = runtime.JsonObject;
  export import JsonArray = runtime.JsonArray;
  export import JsonValue = runtime.JsonValue;
  export import InputJsonObject = runtime.InputJsonObject;
  export import InputJsonArray = runtime.InputJsonArray;
  export import InputJsonValue = runtime.InputJsonValue;

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never;
      private constructor();
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull;

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull;

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull;

  type SelectAndInclude = {
    select: any;
    include: any;
  };

  type SelectAndOmit = {
    select: any;
    omit: any;
  };

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<
    ReturnType<T>
  >;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
  };

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends BigInt
            ? False
            : T extends object
              ? True
              : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<O extends object, K extends Key, strict extends Boolean = 1> = O extends unknown
    ? _Either<O, K, strict>
    : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (U extends unknown ? (k: U) => void : never) extends (
    k: infer I
  ) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? K : never]-?: O[P] } & O)
      : never
  >;

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0;

  export type Has<U extends Union, U1 extends Union> = Not<Extends<Exclude<U1, U>, U1>>;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<T, U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>> =
    IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<Or<Extends<'OR', K>, Extends<'AND', K>>, Extends<'NOT', K>> extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<
    T,
    MaybeTupleToUnion<K>
  >;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T;

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>;

  export const ModelName: {
    Account: 'Account';
    Session: 'Session';
    VerificationToken: 'VerificationToken';
    User: 'User';
    Category: 'Category';
    Service: 'Service';
    ServiceField: 'ServiceField';
    ServiceFieldOption: 'ServiceFieldOption';
    ServiceVariant: 'ServiceVariant';
    Order: 'Order';
    Payment: 'Payment';
    AuditLog: 'AuditLog';
    FAQ: 'FAQ';
    Document: 'Document';
    OrderDocument: 'OrderDocument';
    ServiceDocument: 'ServiceDocument';
    SystemSettings: 'SystemSettings';
    FormType: 'FormType';
    FormTypeVariant: 'FormTypeVariant';
    FormSerial: 'FormSerial';
    Dependent: 'Dependent';
    PromoCode: 'PromoCode';
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName];

  export type Datasources = {
    db?: Datasource;
  };

  interface TypeMapCb
    extends $Utils.Fn<
      { extArgs: $Extensions.InternalArgs; clientOptions: PrismaClientOptions },
      $Utils.Record<string, any>
    > {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>;
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    ClientOptions = {},
  > = {
    meta: {
      modelProps:
        | 'account'
        | 'session'
        | 'verificationToken'
        | 'user'
        | 'category'
        | 'service'
        | 'serviceField'
        | 'serviceFieldOption'
        | 'serviceVariant'
        | 'order'
        | 'payment'
        | 'auditLog'
        | 'fAQ'
        | 'document'
        | 'orderDocument'
        | 'serviceDocument'
        | 'systemSettings'
        | 'formType'
        | 'formTypeVariant'
        | 'formSerial'
        | 'dependent'
        | 'promoCode';
      txIsolationLevel: Prisma.TransactionIsolationLevel;
    };
    model: {
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>;
        fields: Prisma.AccountFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[];
          };
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[];
          };
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAccount>;
          };
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AccountGroupByOutputType>[];
          };
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>;
            result: $Utils.Optional<AccountCountAggregateOutputType> | number;
          };
        };
      };
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>;
        fields: Prisma.SessionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[];
          };
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[];
          };
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSession>;
          };
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SessionGroupByOutputType>[];
          };
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>;
            result: $Utils.Optional<SessionCountAggregateOutputType> | number;
          };
        };
      };
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>;
        fields: Prisma.VerificationTokenFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[];
          };
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[];
          };
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateVerificationToken>;
          };
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>;
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[];
          };
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>;
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number;
          };
        };
      };
      User: {
        payload: Prisma.$UserPayload<ExtArgs>;
        fields: Prisma.UserFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUser>;
          };
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserCountArgs<ExtArgs>;
            result: $Utils.Optional<UserCountAggregateOutputType> | number;
          };
        };
      };
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>;
        fields: Prisma.CategoryFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>;
          };
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>;
          };
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[];
          };
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>;
          };
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[];
          };
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>;
          };
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>;
          };
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>;
          };
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCategory>;
          };
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CategoryGroupByOutputType>[];
          };
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>;
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number;
          };
        };
      };
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>;
        fields: Prisma.ServiceFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>;
          };
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>;
          };
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[];
          };
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>;
          };
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[];
          };
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>;
          };
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>;
          };
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>;
          };
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateService>;
          };
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ServiceGroupByOutputType>[];
          };
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>;
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number;
          };
        };
      };
      ServiceField: {
        payload: Prisma.$ServiceFieldPayload<ExtArgs>;
        fields: Prisma.ServiceFieldFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ServiceFieldFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceFieldPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ServiceFieldFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceFieldPayload>;
          };
          findFirst: {
            args: Prisma.ServiceFieldFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceFieldPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ServiceFieldFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceFieldPayload>;
          };
          findMany: {
            args: Prisma.ServiceFieldFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceFieldPayload>[];
          };
          create: {
            args: Prisma.ServiceFieldCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceFieldPayload>;
          };
          createMany: {
            args: Prisma.ServiceFieldCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ServiceFieldCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceFieldPayload>[];
          };
          delete: {
            args: Prisma.ServiceFieldDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceFieldPayload>;
          };
          update: {
            args: Prisma.ServiceFieldUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceFieldPayload>;
          };
          deleteMany: {
            args: Prisma.ServiceFieldDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ServiceFieldUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ServiceFieldUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceFieldPayload>;
          };
          aggregate: {
            args: Prisma.ServiceFieldAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateServiceField>;
          };
          groupBy: {
            args: Prisma.ServiceFieldGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ServiceFieldGroupByOutputType>[];
          };
          count: {
            args: Prisma.ServiceFieldCountArgs<ExtArgs>;
            result: $Utils.Optional<ServiceFieldCountAggregateOutputType> | number;
          };
        };
      };
      ServiceFieldOption: {
        payload: Prisma.$ServiceFieldOptionPayload<ExtArgs>;
        fields: Prisma.ServiceFieldOptionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ServiceFieldOptionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceFieldOptionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ServiceFieldOptionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceFieldOptionPayload>;
          };
          findFirst: {
            args: Prisma.ServiceFieldOptionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceFieldOptionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ServiceFieldOptionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceFieldOptionPayload>;
          };
          findMany: {
            args: Prisma.ServiceFieldOptionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceFieldOptionPayload>[];
          };
          create: {
            args: Prisma.ServiceFieldOptionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceFieldOptionPayload>;
          };
          createMany: {
            args: Prisma.ServiceFieldOptionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ServiceFieldOptionCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceFieldOptionPayload>[];
          };
          delete: {
            args: Prisma.ServiceFieldOptionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceFieldOptionPayload>;
          };
          update: {
            args: Prisma.ServiceFieldOptionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceFieldOptionPayload>;
          };
          deleteMany: {
            args: Prisma.ServiceFieldOptionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ServiceFieldOptionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ServiceFieldOptionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceFieldOptionPayload>;
          };
          aggregate: {
            args: Prisma.ServiceFieldOptionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateServiceFieldOption>;
          };
          groupBy: {
            args: Prisma.ServiceFieldOptionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ServiceFieldOptionGroupByOutputType>[];
          };
          count: {
            args: Prisma.ServiceFieldOptionCountArgs<ExtArgs>;
            result: $Utils.Optional<ServiceFieldOptionCountAggregateOutputType> | number;
          };
        };
      };
      ServiceVariant: {
        payload: Prisma.$ServiceVariantPayload<ExtArgs>;
        fields: Prisma.ServiceVariantFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ServiceVariantFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceVariantPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ServiceVariantFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceVariantPayload>;
          };
          findFirst: {
            args: Prisma.ServiceVariantFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceVariantPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ServiceVariantFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceVariantPayload>;
          };
          findMany: {
            args: Prisma.ServiceVariantFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceVariantPayload>[];
          };
          create: {
            args: Prisma.ServiceVariantCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceVariantPayload>;
          };
          createMany: {
            args: Prisma.ServiceVariantCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ServiceVariantCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceVariantPayload>[];
          };
          delete: {
            args: Prisma.ServiceVariantDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceVariantPayload>;
          };
          update: {
            args: Prisma.ServiceVariantUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceVariantPayload>;
          };
          deleteMany: {
            args: Prisma.ServiceVariantDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ServiceVariantUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ServiceVariantUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceVariantPayload>;
          };
          aggregate: {
            args: Prisma.ServiceVariantAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateServiceVariant>;
          };
          groupBy: {
            args: Prisma.ServiceVariantGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ServiceVariantGroupByOutputType>[];
          };
          count: {
            args: Prisma.ServiceVariantCountArgs<ExtArgs>;
            result: $Utils.Optional<ServiceVariantCountAggregateOutputType> | number;
          };
        };
      };
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>;
        fields: Prisma.OrderFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>;
          };
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>;
          };
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[];
          };
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>;
          };
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[];
          };
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>;
          };
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>;
          };
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>;
          };
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateOrder>;
          };
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>;
            result: $Utils.Optional<OrderGroupByOutputType>[];
          };
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>;
            result: $Utils.Optional<OrderCountAggregateOutputType> | number;
          };
        };
      };
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>;
        fields: Prisma.PaymentFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>;
          };
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>;
          };
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[];
          };
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>;
          };
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[];
          };
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>;
          };
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>;
          };
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>;
          };
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePayment>;
          };
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PaymentGroupByOutputType>[];
          };
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>;
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number;
          };
        };
      };
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>;
        fields: Prisma.AuditLogFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[];
          };
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[];
          };
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAuditLog>;
          };
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AuditLogGroupByOutputType>[];
          };
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>;
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number;
          };
        };
      };
      FAQ: {
        payload: Prisma.$FAQPayload<ExtArgs>;
        fields: Prisma.FAQFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.FAQFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FAQPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.FAQFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>;
          };
          findFirst: {
            args: Prisma.FAQFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FAQPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.FAQFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>;
          };
          findMany: {
            args: Prisma.FAQFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>[];
          };
          create: {
            args: Prisma.FAQCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>;
          };
          createMany: {
            args: Prisma.FAQCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.FAQCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>[];
          };
          delete: {
            args: Prisma.FAQDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>;
          };
          update: {
            args: Prisma.FAQUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>;
          };
          deleteMany: {
            args: Prisma.FAQDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.FAQUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.FAQUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>;
          };
          aggregate: {
            args: Prisma.FAQAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateFAQ>;
          };
          groupBy: {
            args: Prisma.FAQGroupByArgs<ExtArgs>;
            result: $Utils.Optional<FAQGroupByOutputType>[];
          };
          count: {
            args: Prisma.FAQCountArgs<ExtArgs>;
            result: $Utils.Optional<FAQCountAggregateOutputType> | number;
          };
        };
      };
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>;
        fields: Prisma.DocumentFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>;
          };
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>;
          };
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[];
          };
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>;
          };
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[];
          };
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>;
          };
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>;
          };
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>;
          };
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateDocument>;
          };
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>;
            result: $Utils.Optional<DocumentGroupByOutputType>[];
          };
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>;
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number;
          };
        };
      };
      OrderDocument: {
        payload: Prisma.$OrderDocumentPayload<ExtArgs>;
        fields: Prisma.OrderDocumentFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.OrderDocumentFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderDocumentPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.OrderDocumentFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderDocumentPayload>;
          };
          findFirst: {
            args: Prisma.OrderDocumentFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderDocumentPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.OrderDocumentFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderDocumentPayload>;
          };
          findMany: {
            args: Prisma.OrderDocumentFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderDocumentPayload>[];
          };
          create: {
            args: Prisma.OrderDocumentCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderDocumentPayload>;
          };
          createMany: {
            args: Prisma.OrderDocumentCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.OrderDocumentCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderDocumentPayload>[];
          };
          delete: {
            args: Prisma.OrderDocumentDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderDocumentPayload>;
          };
          update: {
            args: Prisma.OrderDocumentUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderDocumentPayload>;
          };
          deleteMany: {
            args: Prisma.OrderDocumentDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.OrderDocumentUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.OrderDocumentUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$OrderDocumentPayload>;
          };
          aggregate: {
            args: Prisma.OrderDocumentAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateOrderDocument>;
          };
          groupBy: {
            args: Prisma.OrderDocumentGroupByArgs<ExtArgs>;
            result: $Utils.Optional<OrderDocumentGroupByOutputType>[];
          };
          count: {
            args: Prisma.OrderDocumentCountArgs<ExtArgs>;
            result: $Utils.Optional<OrderDocumentCountAggregateOutputType> | number;
          };
        };
      };
      ServiceDocument: {
        payload: Prisma.$ServiceDocumentPayload<ExtArgs>;
        fields: Prisma.ServiceDocumentFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ServiceDocumentFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceDocumentPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ServiceDocumentFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceDocumentPayload>;
          };
          findFirst: {
            args: Prisma.ServiceDocumentFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceDocumentPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ServiceDocumentFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceDocumentPayload>;
          };
          findMany: {
            args: Prisma.ServiceDocumentFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceDocumentPayload>[];
          };
          create: {
            args: Prisma.ServiceDocumentCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceDocumentPayload>;
          };
          createMany: {
            args: Prisma.ServiceDocumentCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ServiceDocumentCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceDocumentPayload>[];
          };
          delete: {
            args: Prisma.ServiceDocumentDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceDocumentPayload>;
          };
          update: {
            args: Prisma.ServiceDocumentUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceDocumentPayload>;
          };
          deleteMany: {
            args: Prisma.ServiceDocumentDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ServiceDocumentUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ServiceDocumentUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServiceDocumentPayload>;
          };
          aggregate: {
            args: Prisma.ServiceDocumentAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateServiceDocument>;
          };
          groupBy: {
            args: Prisma.ServiceDocumentGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ServiceDocumentGroupByOutputType>[];
          };
          count: {
            args: Prisma.ServiceDocumentCountArgs<ExtArgs>;
            result: $Utils.Optional<ServiceDocumentCountAggregateOutputType> | number;
          };
        };
      };
      SystemSettings: {
        payload: Prisma.$SystemSettingsPayload<ExtArgs>;
        fields: Prisma.SystemSettingsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SystemSettingsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SystemSettingsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>;
          };
          findFirst: {
            args: Prisma.SystemSettingsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SystemSettingsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>;
          };
          findMany: {
            args: Prisma.SystemSettingsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>[];
          };
          create: {
            args: Prisma.SystemSettingsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>;
          };
          createMany: {
            args: Prisma.SystemSettingsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.SystemSettingsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>[];
          };
          delete: {
            args: Prisma.SystemSettingsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>;
          };
          update: {
            args: Prisma.SystemSettingsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>;
          };
          deleteMany: {
            args: Prisma.SystemSettingsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SystemSettingsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.SystemSettingsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>;
          };
          aggregate: {
            args: Prisma.SystemSettingsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSystemSettings>;
          };
          groupBy: {
            args: Prisma.SystemSettingsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SystemSettingsGroupByOutputType>[];
          };
          count: {
            args: Prisma.SystemSettingsCountArgs<ExtArgs>;
            result: $Utils.Optional<SystemSettingsCountAggregateOutputType> | number;
          };
        };
      };
      FormType: {
        payload: Prisma.$FormTypePayload<ExtArgs>;
        fields: Prisma.FormTypeFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.FormTypeFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FormTypePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.FormTypeFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FormTypePayload>;
          };
          findFirst: {
            args: Prisma.FormTypeFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FormTypePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.FormTypeFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FormTypePayload>;
          };
          findMany: {
            args: Prisma.FormTypeFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FormTypePayload>[];
          };
          create: {
            args: Prisma.FormTypeCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FormTypePayload>;
          };
          createMany: {
            args: Prisma.FormTypeCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.FormTypeCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FormTypePayload>[];
          };
          delete: {
            args: Prisma.FormTypeDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FormTypePayload>;
          };
          update: {
            args: Prisma.FormTypeUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FormTypePayload>;
          };
          deleteMany: {
            args: Prisma.FormTypeDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.FormTypeUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.FormTypeUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FormTypePayload>;
          };
          aggregate: {
            args: Prisma.FormTypeAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateFormType>;
          };
          groupBy: {
            args: Prisma.FormTypeGroupByArgs<ExtArgs>;
            result: $Utils.Optional<FormTypeGroupByOutputType>[];
          };
          count: {
            args: Prisma.FormTypeCountArgs<ExtArgs>;
            result: $Utils.Optional<FormTypeCountAggregateOutputType> | number;
          };
        };
      };
      FormTypeVariant: {
        payload: Prisma.$FormTypeVariantPayload<ExtArgs>;
        fields: Prisma.FormTypeVariantFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.FormTypeVariantFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FormTypeVariantPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.FormTypeVariantFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FormTypeVariantPayload>;
          };
          findFirst: {
            args: Prisma.FormTypeVariantFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FormTypeVariantPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.FormTypeVariantFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FormTypeVariantPayload>;
          };
          findMany: {
            args: Prisma.FormTypeVariantFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FormTypeVariantPayload>[];
          };
          create: {
            args: Prisma.FormTypeVariantCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FormTypeVariantPayload>;
          };
          createMany: {
            args: Prisma.FormTypeVariantCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.FormTypeVariantCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FormTypeVariantPayload>[];
          };
          delete: {
            args: Prisma.FormTypeVariantDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FormTypeVariantPayload>;
          };
          update: {
            args: Prisma.FormTypeVariantUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FormTypeVariantPayload>;
          };
          deleteMany: {
            args: Prisma.FormTypeVariantDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.FormTypeVariantUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.FormTypeVariantUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FormTypeVariantPayload>;
          };
          aggregate: {
            args: Prisma.FormTypeVariantAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateFormTypeVariant>;
          };
          groupBy: {
            args: Prisma.FormTypeVariantGroupByArgs<ExtArgs>;
            result: $Utils.Optional<FormTypeVariantGroupByOutputType>[];
          };
          count: {
            args: Prisma.FormTypeVariantCountArgs<ExtArgs>;
            result: $Utils.Optional<FormTypeVariantCountAggregateOutputType> | number;
          };
        };
      };
      FormSerial: {
        payload: Prisma.$FormSerialPayload<ExtArgs>;
        fields: Prisma.FormSerialFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.FormSerialFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FormSerialPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.FormSerialFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FormSerialPayload>;
          };
          findFirst: {
            args: Prisma.FormSerialFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FormSerialPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.FormSerialFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FormSerialPayload>;
          };
          findMany: {
            args: Prisma.FormSerialFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FormSerialPayload>[];
          };
          create: {
            args: Prisma.FormSerialCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FormSerialPayload>;
          };
          createMany: {
            args: Prisma.FormSerialCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.FormSerialCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FormSerialPayload>[];
          };
          delete: {
            args: Prisma.FormSerialDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FormSerialPayload>;
          };
          update: {
            args: Prisma.FormSerialUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FormSerialPayload>;
          };
          deleteMany: {
            args: Prisma.FormSerialDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.FormSerialUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.FormSerialUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FormSerialPayload>;
          };
          aggregate: {
            args: Prisma.FormSerialAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateFormSerial>;
          };
          groupBy: {
            args: Prisma.FormSerialGroupByArgs<ExtArgs>;
            result: $Utils.Optional<FormSerialGroupByOutputType>[];
          };
          count: {
            args: Prisma.FormSerialCountArgs<ExtArgs>;
            result: $Utils.Optional<FormSerialCountAggregateOutputType> | number;
          };
        };
      };
      Dependent: {
        payload: Prisma.$DependentPayload<ExtArgs>;
        fields: Prisma.DependentFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.DependentFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DependentPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.DependentFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DependentPayload>;
          };
          findFirst: {
            args: Prisma.DependentFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DependentPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.DependentFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DependentPayload>;
          };
          findMany: {
            args: Prisma.DependentFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DependentPayload>[];
          };
          create: {
            args: Prisma.DependentCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DependentPayload>;
          };
          createMany: {
            args: Prisma.DependentCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.DependentCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DependentPayload>[];
          };
          delete: {
            args: Prisma.DependentDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DependentPayload>;
          };
          update: {
            args: Prisma.DependentUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DependentPayload>;
          };
          deleteMany: {
            args: Prisma.DependentDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.DependentUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.DependentUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DependentPayload>;
          };
          aggregate: {
            args: Prisma.DependentAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateDependent>;
          };
          groupBy: {
            args: Prisma.DependentGroupByArgs<ExtArgs>;
            result: $Utils.Optional<DependentGroupByOutputType>[];
          };
          count: {
            args: Prisma.DependentCountArgs<ExtArgs>;
            result: $Utils.Optional<DependentCountAggregateOutputType> | number;
          };
        };
      };
      PromoCode: {
        payload: Prisma.$PromoCodePayload<ExtArgs>;
        fields: Prisma.PromoCodeFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.PromoCodeFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.PromoCodeFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>;
          };
          findFirst: {
            args: Prisma.PromoCodeFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.PromoCodeFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>;
          };
          findMany: {
            args: Prisma.PromoCodeFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>[];
          };
          create: {
            args: Prisma.PromoCodeCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>;
          };
          createMany: {
            args: Prisma.PromoCodeCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.PromoCodeCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>[];
          };
          delete: {
            args: Prisma.PromoCodeDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>;
          };
          update: {
            args: Prisma.PromoCodeUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>;
          };
          deleteMany: {
            args: Prisma.PromoCodeDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.PromoCodeUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.PromoCodeUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>;
          };
          aggregate: {
            args: Prisma.PromoCodeAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePromoCode>;
          };
          groupBy: {
            args: Prisma.PromoCodeGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PromoCodeGroupByOutputType>[];
          };
          count: {
            args: Prisma.PromoCodeCountArgs<ExtArgs>;
            result: $Utils.Optional<PromoCodeCountAggregateOutputType> | number;
          };
        };
      };
    };
  } & {
    other: {
      payload: any;
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
      };
    };
  };
  export const defineExtension: $Extensions.ExtendsHook<
    'define',
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >;
  export type DefaultPrismaClient = PrismaClient;
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal';
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources;
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string;
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    };
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error';
  export type LogDefinition = {
    level: LogLevel;
    emit: 'stdout' | 'event';
  };

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition
    ? T['emit'] extends 'event'
      ? T['level']
      : never
    : never;
  export type GetEvents<T extends any> =
    T extends Array<LogLevel | LogDefinition>
      ? GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
      : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy';

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName;
    action: PrismaAction;
    args: any;
    dataPath: string[];
    runInTransaction: boolean;
  };

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>
  ) => $Utils.JsPromise<T>;

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>;

  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    createdUsers: number;
    createdOrders: number;
    orders: number;
    accounts: number;
    auditLogs: number;
    sessions: number;
    addedFormSerials: number;
    consumedFormSerials: number;
    createdDependents: number;
  };

  export type UserCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    createdUsers?: boolean | UserCountOutputTypeCountCreatedUsersArgs;
    createdOrders?: boolean | UserCountOutputTypeCountCreatedOrdersArgs;
    orders?: boolean | UserCountOutputTypeCountOrdersArgs;
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs;
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs;
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs;
    addedFormSerials?: boolean | UserCountOutputTypeCountAddedFormSerialsArgs;
    consumedFormSerials?: boolean | UserCountOutputTypeCountConsumedFormSerialsArgs;
    createdDependents?: boolean | UserCountOutputTypeCountCreatedDependentsArgs;
  };

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedUsersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedOrdersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrderWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrderWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AccountWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AuditLogWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SessionWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAddedFormSerialsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FormSerialWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConsumedFormSerialsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FormSerialWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedDependentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: DependentWhereInput;
  };

  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    services: number;
  };

  export type CategoryCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    services?: boolean | CategoryCountOutputTypeCountServicesArgs;
  };

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountServicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ServiceWhereInput;
  };

  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    orders: number;
    documents: number;
    variants: number;
    fields: number;
  };

  export type ServiceCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    orders?: boolean | ServiceCountOutputTypeCountOrdersArgs;
    documents?: boolean | ServiceCountOutputTypeCountDocumentsArgs;
    variants?: boolean | ServiceCountOutputTypeCountVariantsArgs;
    fields?: boolean | ServiceCountOutputTypeCountFieldsArgs;
  };

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountOrdersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrderWhereInput;
  };

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountDocumentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ServiceDocumentWhereInput;
  };

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountVariantsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ServiceVariantWhereInput;
  };

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountFieldsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ServiceFieldWhereInput;
  };

  /**
   * Count Type ServiceFieldCountOutputType
   */

  export type ServiceFieldCountOutputType = {
    options: number;
  };

  export type ServiceFieldCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    options?: boolean | ServiceFieldCountOutputTypeCountOptionsArgs;
  };

  // Custom InputTypes
  /**
   * ServiceFieldCountOutputType without action
   */
  export type ServiceFieldCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceFieldCountOutputType
     */
    select?: ServiceFieldCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ServiceFieldCountOutputType without action
   */
  export type ServiceFieldCountOutputTypeCountOptionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ServiceFieldOptionWhereInput;
  };

  /**
   * Count Type ServiceVariantCountOutputType
   */

  export type ServiceVariantCountOutputType = {
    orders: number;
    formTypeLinks: number;
  };

  export type ServiceVariantCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    orders?: boolean | ServiceVariantCountOutputTypeCountOrdersArgs;
    formTypeLinks?: boolean | ServiceVariantCountOutputTypeCountFormTypeLinksArgs;
  };

  // Custom InputTypes
  /**
   * ServiceVariantCountOutputType without action
   */
  export type ServiceVariantCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceVariantCountOutputType
     */
    select?: ServiceVariantCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ServiceVariantCountOutputType without action
   */
  export type ServiceVariantCountOutputTypeCountOrdersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrderWhereInput;
  };

  /**
   * ServiceVariantCountOutputType without action
   */
  export type ServiceVariantCountOutputTypeCountFormTypeLinksArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FormTypeVariantWhereInput;
  };

  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    documents: number;
    orderDocuments: number;
    formSerials: number;
  };

  export type OrderCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    documents?: boolean | OrderCountOutputTypeCountDocumentsArgs;
    orderDocuments?: boolean | OrderCountOutputTypeCountOrderDocumentsArgs;
    formSerials?: boolean | OrderCountOutputTypeCountFormSerialsArgs;
  };

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountDocumentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: DocumentWhereInput;
  };

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountOrderDocumentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrderDocumentWhereInput;
  };

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountFormSerialsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FormSerialWhereInput;
  };

  /**
   * Count Type FormTypeCountOutputType
   */

  export type FormTypeCountOutputType = {
    variantLinks: number;
    serials: number;
  };

  export type FormTypeCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    variantLinks?: boolean | FormTypeCountOutputTypeCountVariantLinksArgs;
    serials?: boolean | FormTypeCountOutputTypeCountSerialsArgs;
  };

  // Custom InputTypes
  /**
   * FormTypeCountOutputType without action
   */
  export type FormTypeCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormTypeCountOutputType
     */
    select?: FormTypeCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * FormTypeCountOutputType without action
   */
  export type FormTypeCountOutputTypeCountVariantLinksArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FormTypeVariantWhereInput;
  };

  /**
   * FormTypeCountOutputType without action
   */
  export type FormTypeCountOutputTypeCountSerialsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FormSerialWhereInput;
  };

  /**
   * Count Type PromoCodeCountOutputType
   */

  export type PromoCodeCountOutputType = {
    orders: number;
  };

  export type PromoCodeCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    orders?: boolean | PromoCodeCountOutputTypeCountOrdersArgs;
  };

  // Custom InputTypes
  /**
   * PromoCodeCountOutputType without action
   */
  export type PromoCodeCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PromoCodeCountOutputType
     */
    select?: PromoCodeCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * PromoCodeCountOutputType without action
   */
  export type PromoCodeCountOutputTypeCountOrdersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrderWhereInput;
  };

  /**
   * Models
   */

  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null;
    _avg: AccountAvgAggregateOutputType | null;
    _sum: AccountSumAggregateOutputType | null;
    _min: AccountMinAggregateOutputType | null;
    _max: AccountMaxAggregateOutputType | null;
  };

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null;
  };

  export type AccountSumAggregateOutputType = {
    expires_at: number | null;
  };

  export type AccountMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    type: string | null;
    provider: string | null;
    providerAccountId: string | null;
    refresh_token: string | null;
    access_token: string | null;
    expires_at: number | null;
    token_type: string | null;
    scope: string | null;
    id_token: string | null;
    session_state: string | null;
  };

  export type AccountMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    type: string | null;
    provider: string | null;
    providerAccountId: string | null;
    refresh_token: string | null;
    access_token: string | null;
    expires_at: number | null;
    token_type: string | null;
    scope: string | null;
    id_token: string | null;
    session_state: string | null;
  };

  export type AccountCountAggregateOutputType = {
    id: number;
    userId: number;
    type: number;
    provider: number;
    providerAccountId: number;
    refresh_token: number;
    access_token: number;
    expires_at: number;
    token_type: number;
    scope: number;
    id_token: number;
    session_state: number;
    _all: number;
  };

  export type AccountAvgAggregateInputType = {
    expires_at?: true;
  };

  export type AccountSumAggregateInputType = {
    expires_at?: true;
  };

  export type AccountMinAggregateInputType = {
    id?: true;
    userId?: true;
    type?: true;
    provider?: true;
    providerAccountId?: true;
    refresh_token?: true;
    access_token?: true;
    expires_at?: true;
    token_type?: true;
    scope?: true;
    id_token?: true;
    session_state?: true;
  };

  export type AccountMaxAggregateInputType = {
    id?: true;
    userId?: true;
    type?: true;
    provider?: true;
    providerAccountId?: true;
    refresh_token?: true;
    access_token?: true;
    expires_at?: true;
    token_type?: true;
    scope?: true;
    id_token?: true;
    session_state?: true;
  };

  export type AccountCountAggregateInputType = {
    id?: true;
    userId?: true;
    type?: true;
    provider?: true;
    providerAccountId?: true;
    refresh_token?: true;
    access_token?: true;
    expires_at?: true;
    token_type?: true;
    scope?: true;
    id_token?: true;
    session_state?: true;
    _all?: true;
  };

  export type AccountAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Accounts
     **/
    _count?: true | AccountCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: AccountAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: AccountSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AccountMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AccountMaxAggregateInputType;
  };

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
    [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>;
  };

  export type AccountGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AccountWhereInput;
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[];
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum;
    having?: AccountScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AccountCountAggregateInputType | true;
    _avg?: AccountAvgAggregateInputType;
    _sum?: AccountSumAggregateInputType;
    _min?: AccountMinAggregateInputType;
    _max?: AccountMaxAggregateInputType;
  };

  export type AccountGroupByOutputType = {
    id: string;
    userId: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token: string | null;
    access_token: string | null;
    expires_at: number | null;
    token_type: string | null;
    scope: string | null;
    id_token: string | null;
    session_state: string | null;
    _count: AccountCountAggregateOutputType | null;
    _avg: AccountAvgAggregateOutputType | null;
    _sum: AccountSumAggregateOutputType | null;
    _min: AccountMinAggregateOutputType | null;
    _max: AccountMaxAggregateOutputType | null;
  };

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> & {
        [P in keyof T & keyof AccountGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
          : GetScalarType<T[P], AccountGroupByOutputType[P]>;
      }
    >
  >;

  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        userId?: boolean;
        type?: boolean;
        provider?: boolean;
        providerAccountId?: boolean;
        refresh_token?: boolean;
        access_token?: boolean;
        expires_at?: boolean;
        token_type?: boolean;
        scope?: boolean;
        id_token?: boolean;
        session_state?: boolean;
        user?: boolean | UserDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['account']
    >;

  export type AccountSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      type?: boolean;
      provider?: boolean;
      providerAccountId?: boolean;
      refresh_token?: boolean;
      access_token?: boolean;
      expires_at?: boolean;
      token_type?: boolean;
      scope?: boolean;
      id_token?: boolean;
      session_state?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['account']
  >;

  export type AccountSelectScalar = {
    id?: boolean;
    userId?: boolean;
    type?: boolean;
    provider?: boolean;
    providerAccountId?: boolean;
    refresh_token?: boolean;
    access_token?: boolean;
    expires_at?: boolean;
    token_type?: boolean;
    scope?: boolean;
    id_token?: boolean;
    session_state?: boolean;
  };

  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type AccountIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Account';
      objects: {
        user: Prisma.$UserPayload<ExtArgs>;
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          userId: string;
          type: string;
          provider: string;
          providerAccountId: string;
          refresh_token: string | null;
          access_token: string | null;
          expires_at: number | null;
          token_type: string | null;
          scope: string | null;
          id_token: string | null;
          session_state: string | null;
        },
        ExtArgs['result']['account']
      >;
      composites: {};
    };

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> =
    $Result.GetResult<Prisma.$AccountPayload, S>;

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    AccountFindManyArgs,
    'select' | 'include' | 'distinct'
  > & {
    select?: AccountCountAggregateInputType | true;
  };

  export interface AccountDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account']; meta: { name: 'Account' } };
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(
      args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(
      args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     *
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AccountFindManyArgs>(
      args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     *
     */
    create<T extends AccountCreateArgs>(
      args: SelectSubset<T, AccountCreateArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AccountCreateManyArgs>(
      args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(
      args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     *
     */
    delete<T extends AccountDeleteArgs>(
      args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AccountUpdateArgs>(
      args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AccountDeleteManyArgs>(
      args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AccountUpdateManyArgs>(
      args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(
      args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
     **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AccountAggregateArgs>(
      args: Subset<T, AccountAggregateArgs>
    ): Prisma.PrismaPromise<GetAccountAggregateType<T>>;

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Account model
     */
    readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<'Account', 'String'>;
    readonly userId: FieldRef<'Account', 'String'>;
    readonly type: FieldRef<'Account', 'String'>;
    readonly provider: FieldRef<'Account', 'String'>;
    readonly providerAccountId: FieldRef<'Account', 'String'>;
    readonly refresh_token: FieldRef<'Account', 'String'>;
    readonly access_token: FieldRef<'Account', 'String'>;
    readonly expires_at: FieldRef<'Account', 'Int'>;
    readonly token_type: FieldRef<'Account', 'String'>;
    readonly scope: FieldRef<'Account', 'String'>;
    readonly id_token: FieldRef<'Account', 'String'>;
    readonly session_state: FieldRef<'Account', 'String'>;
  }

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * Account create
   */
  export type AccountCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>;
  };

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Account update
   */
  export type AccountUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>;
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>;
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput;
  };

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput;
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>;
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>;
  };

  /**
   * Account delete
   */
  export type AccountDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput;
  };

  /**
   * Account without action
   */
  export type AccountDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
  };

  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null;
    _min: SessionMinAggregateOutputType | null;
    _max: SessionMaxAggregateOutputType | null;
  };

  export type SessionMinAggregateOutputType = {
    id: string | null;
    sessionToken: string | null;
    userId: string | null;
    expires: Date | null;
  };

  export type SessionMaxAggregateOutputType = {
    id: string | null;
    sessionToken: string | null;
    userId: string | null;
    expires: Date | null;
  };

  export type SessionCountAggregateOutputType = {
    id: number;
    sessionToken: number;
    userId: number;
    expires: number;
    _all: number;
  };

  export type SessionMinAggregateInputType = {
    id?: true;
    sessionToken?: true;
    userId?: true;
    expires?: true;
  };

  export type SessionMaxAggregateInputType = {
    id?: true;
    sessionToken?: true;
    userId?: true;
    expires?: true;
  };

  export type SessionCountAggregateInputType = {
    id?: true;
    sessionToken?: true;
    userId?: true;
    expires?: true;
    _all?: true;
  };

  export type SessionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Sessions
     **/
    _count?: true | SessionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SessionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SessionMaxAggregateInputType;
  };

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
    [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>;
  };

  export type SessionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[];
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum;
    having?: SessionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SessionCountAggregateInputType | true;
    _min?: SessionMinAggregateInputType;
    _max?: SessionMaxAggregateInputType;
  };

  export type SessionGroupByOutputType = {
    id: string;
    sessionToken: string;
    userId: string;
    expires: Date;
    _count: SessionCountAggregateOutputType | null;
    _min: SessionMinAggregateOutputType | null;
    _max: SessionMaxAggregateOutputType | null;
  };

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> & {
        [P in keyof T & keyof SessionGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
          : GetScalarType<T[P], SessionGroupByOutputType[P]>;
      }
    >
  >;

  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        sessionToken?: boolean;
        userId?: boolean;
        expires?: boolean;
        user?: boolean | UserDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['session']
    >;

  export type SessionSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      sessionToken?: boolean;
      userId?: boolean;
      expires?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['session']
  >;

  export type SessionSelectScalar = {
    id?: boolean;
    sessionToken?: boolean;
    userId?: boolean;
    expires?: boolean;
  };

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type SessionIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Session';
      objects: {
        user: Prisma.$UserPayload<ExtArgs>;
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          sessionToken: string;
          userId: string;
          expires: Date;
        },
        ExtArgs['result']['session']
      >;
      composites: {};
    };

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> =
    $Result.GetResult<Prisma.$SessionPayload, S>;

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    SessionFindManyArgs,
    'select' | 'include' | 'distinct'
  > & {
    select?: SessionCountAggregateInputType | true;
  };

  export interface SessionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session']; meta: { name: 'Session' } };
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(
      args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(
      args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     *
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SessionFindManyArgs>(
      args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     *
     */
    create<T extends SessionCreateArgs>(
      args: SelectSubset<T, SessionCreateArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SessionCreateManyArgs>(
      args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(
      args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     *
     */
    delete<T extends SessionDeleteArgs>(
      args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SessionUpdateArgs>(
      args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SessionDeleteManyArgs>(
      args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SessionUpdateManyArgs>(
      args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(
      args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
     **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SessionAggregateArgs>(
      args: Subset<T, SessionAggregateArgs>
    ): Prisma.PrismaPromise<GetSessionAggregateType<T>>;

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Session model
     */
    readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<'Session', 'String'>;
    readonly sessionToken: FieldRef<'Session', 'String'>;
    readonly userId: FieldRef<'Session', 'String'>;
    readonly expires: FieldRef<'Session', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * Session create
   */
  export type SessionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>;
  };

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Session update
   */
  export type SessionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>;
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>;
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput;
  };

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput;
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>;
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>;
  };

  /**
   * Session delete
   */
  export type SessionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput;
  };

  /**
   * Session without action
   */
  export type SessionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
  };

  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null;
    _min: VerificationTokenMinAggregateOutputType | null;
    _max: VerificationTokenMaxAggregateOutputType | null;
  };

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null;
    token: string | null;
    expires: Date | null;
  };

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null;
    token: string | null;
    expires: Date | null;
  };

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number;
    token: number;
    expires: number;
    _all: number;
  };

  export type VerificationTokenMinAggregateInputType = {
    identifier?: true;
    token?: true;
    expires?: true;
  };

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true;
    token?: true;
    expires?: true;
  };

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true;
    token?: true;
    expires?: true;
    _all?: true;
  };

  export type VerificationTokenAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?:
      | VerificationTokenOrderByWithRelationInput
      | VerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VerificationTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned VerificationTokens
     **/
    _count?: true | VerificationTokenCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: VerificationTokenMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: VerificationTokenMaxAggregateInputType;
  };

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
    [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>;
  };

  export type VerificationTokenGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: VerificationTokenWhereInput;
    orderBy?:
      | VerificationTokenOrderByWithAggregationInput
      | VerificationTokenOrderByWithAggregationInput[];
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum;
    having?: VerificationTokenScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: VerificationTokenCountAggregateInputType | true;
    _min?: VerificationTokenMinAggregateInputType;
    _max?: VerificationTokenMaxAggregateInputType;
  };

  export type VerificationTokenGroupByOutputType = {
    identifier: string;
    token: string;
    expires: Date;
    _count: VerificationTokenCountAggregateOutputType | null;
    _min: VerificationTokenMinAggregateOutputType | null;
    _max: VerificationTokenMaxAggregateOutputType | null;
  };

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<VerificationTokenGroupByOutputType, T['by']> & {
          [P in keyof T & keyof VerificationTokenGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>;
        }
      >
    >;

  export type VerificationTokenSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      identifier?: boolean;
      token?: boolean;
      expires?: boolean;
    },
    ExtArgs['result']['verificationToken']
  >;

  export type VerificationTokenSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      identifier?: boolean;
      token?: boolean;
      expires?: boolean;
    },
    ExtArgs['result']['verificationToken']
  >;

  export type VerificationTokenSelectScalar = {
    identifier?: boolean;
    token?: boolean;
    expires?: boolean;
  };

  export type $VerificationTokenPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'VerificationToken';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        identifier: string;
        token: string;
        expires: Date;
      },
      ExtArgs['result']['verificationToken']
    >;
    composites: {};
  };

  type VerificationTokenGetPayload<
    S extends boolean | null | undefined | VerificationTokenDefaultArgs,
  > = $Result.GetResult<Prisma.$VerificationTokenPayload, S>;

  type VerificationTokenCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
    select?: VerificationTokenCountAggregateInputType | true;
  };

  export interface VerificationTokenDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'];
      meta: { name: 'VerificationToken' };
    };
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(
      args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(
      args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(
      args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(
      args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     *
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     *
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     *
     */
    findMany<T extends VerificationTokenFindManyArgs>(
      args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'findMany'>
    >;

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     *
     */
    create<T extends VerificationTokenCreateArgs>(
      args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends VerificationTokenCreateManyArgs>(
      args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(
      args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     *
     */
    delete<T extends VerificationTokenDeleteArgs>(
      args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends VerificationTokenUpdateArgs>(
      args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(
      args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(
      args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(
      args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
     **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends VerificationTokenAggregateArgs>(
      args: Subset<T, VerificationTokenAggregateArgs>
    ): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>;

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetVerificationTokenGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the VerificationToken model
     */
    readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<'VerificationToken', 'String'>;
    readonly token: FieldRef<'VerificationToken', 'String'>;
    readonly expires: FieldRef<'VerificationToken', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput;
  };

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput;
  };

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?:
      | VerificationTokenOrderByWithRelationInput
      | VerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VerificationTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[];
  };

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?:
      | VerificationTokenOrderByWithRelationInput
      | VerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VerificationTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[];
  };

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?:
      | VerificationTokenOrderByWithRelationInput
      | VerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VerificationTokens.
     */
    skip?: number;
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[];
  };

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>;
  };

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>;
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput;
  };

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>;
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput;
  };

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput;
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>;
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>;
  };

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput;
  };

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput;
  };

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
  };

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  export type UserMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    email: string | null;
    emailVerified: Date | null;
    image: string | null;
    passwordHash: string | null;
    phone: string | null;
    additionalPhone: string | null;
    role: string | null;
    createdByAdminId: string | null;
    resetToken: string | null;
    resetTokenExpiry: Date | null;
    verificationToken: string | null;
    verificationTokenExpiry: Date | null;
    verificationCode: string | null;
    verificationCodeExpiry: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    address: string | null;
    governorate: string | null;
    city: string | null;
    district: string | null;
    street: string | null;
    buildingNumber: string | null;
    apartmentNumber: string | null;
    landmark: string | null;
    birthDate: Date | null;
    fatherName: string | null;
    idNumber: string | null;
    motherName: string | null;
    nationality: string | null;
    wifeName: string | null;
    wifeMotherName: string | null;
  };

  export type UserMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    email: string | null;
    emailVerified: Date | null;
    image: string | null;
    passwordHash: string | null;
    phone: string | null;
    additionalPhone: string | null;
    role: string | null;
    createdByAdminId: string | null;
    resetToken: string | null;
    resetTokenExpiry: Date | null;
    verificationToken: string | null;
    verificationTokenExpiry: Date | null;
    verificationCode: string | null;
    verificationCodeExpiry: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    address: string | null;
    governorate: string | null;
    city: string | null;
    district: string | null;
    street: string | null;
    buildingNumber: string | null;
    apartmentNumber: string | null;
    landmark: string | null;
    birthDate: Date | null;
    fatherName: string | null;
    idNumber: string | null;
    motherName: string | null;
    nationality: string | null;
    wifeName: string | null;
    wifeMotherName: string | null;
  };

  export type UserCountAggregateOutputType = {
    id: number;
    name: number;
    email: number;
    emailVerified: number;
    image: number;
    passwordHash: number;
    phone: number;
    additionalPhone: number;
    role: number;
    createdByAdminId: number;
    resetToken: number;
    resetTokenExpiry: number;
    verificationToken: number;
    verificationTokenExpiry: number;
    verificationCode: number;
    verificationCodeExpiry: number;
    createdAt: number;
    updatedAt: number;
    address: number;
    governorate: number;
    city: number;
    district: number;
    street: number;
    buildingNumber: number;
    apartmentNumber: number;
    landmark: number;
    birthDate: number;
    fatherName: number;
    idNumber: number;
    motherName: number;
    nationality: number;
    wifeName: number;
    wifeMotherName: number;
    _all: number;
  };

  export type UserMinAggregateInputType = {
    id?: true;
    name?: true;
    email?: true;
    emailVerified?: true;
    image?: true;
    passwordHash?: true;
    phone?: true;
    additionalPhone?: true;
    role?: true;
    createdByAdminId?: true;
    resetToken?: true;
    resetTokenExpiry?: true;
    verificationToken?: true;
    verificationTokenExpiry?: true;
    verificationCode?: true;
    verificationCodeExpiry?: true;
    createdAt?: true;
    updatedAt?: true;
    address?: true;
    governorate?: true;
    city?: true;
    district?: true;
    street?: true;
    buildingNumber?: true;
    apartmentNumber?: true;
    landmark?: true;
    birthDate?: true;
    fatherName?: true;
    idNumber?: true;
    motherName?: true;
    nationality?: true;
    wifeName?: true;
    wifeMotherName?: true;
  };

  export type UserMaxAggregateInputType = {
    id?: true;
    name?: true;
    email?: true;
    emailVerified?: true;
    image?: true;
    passwordHash?: true;
    phone?: true;
    additionalPhone?: true;
    role?: true;
    createdByAdminId?: true;
    resetToken?: true;
    resetTokenExpiry?: true;
    verificationToken?: true;
    verificationTokenExpiry?: true;
    verificationCode?: true;
    verificationCodeExpiry?: true;
    createdAt?: true;
    updatedAt?: true;
    address?: true;
    governorate?: true;
    city?: true;
    district?: true;
    street?: true;
    buildingNumber?: true;
    apartmentNumber?: true;
    landmark?: true;
    birthDate?: true;
    fatherName?: true;
    idNumber?: true;
    motherName?: true;
    nationality?: true;
    wifeName?: true;
    wifeMotherName?: true;
  };

  export type UserCountAggregateInputType = {
    id?: true;
    name?: true;
    email?: true;
    emailVerified?: true;
    image?: true;
    passwordHash?: true;
    phone?: true;
    additionalPhone?: true;
    role?: true;
    createdByAdminId?: true;
    resetToken?: true;
    resetTokenExpiry?: true;
    verificationToken?: true;
    verificationTokenExpiry?: true;
    verificationCode?: true;
    verificationCodeExpiry?: true;
    createdAt?: true;
    updatedAt?: true;
    address?: true;
    governorate?: true;
    city?: true;
    district?: true;
    street?: true;
    buildingNumber?: true;
    apartmentNumber?: true;
    landmark?: true;
    birthDate?: true;
    fatherName?: true;
    idNumber?: true;
    motherName?: true;
    nationality?: true;
    wifeName?: true;
    wifeMotherName?: true;
    _all?: true;
  };

  export type UserAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Users
     **/
    _count?: true | UserCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserMaxAggregateInputType;
  };

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>;
  };

  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      where?: UserWhereInput;
      orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[];
      by: UserScalarFieldEnum[] | UserScalarFieldEnum;
      having?: UserScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: UserCountAggregateInputType | true;
      _min?: UserMinAggregateInputType;
      _max?: UserMaxAggregateInputType;
    };

  export type UserGroupByOutputType = {
    id: string;
    name: string | null;
    email: string | null;
    emailVerified: Date | null;
    image: string | null;
    passwordHash: string | null;
    phone: string | null;
    additionalPhone: string | null;
    role: string;
    createdByAdminId: string | null;
    resetToken: string | null;
    resetTokenExpiry: Date | null;
    verificationToken: string | null;
    verificationTokenExpiry: Date | null;
    verificationCode: string | null;
    verificationCodeExpiry: Date | null;
    createdAt: Date;
    updatedAt: Date;
    address: string | null;
    governorate: string | null;
    city: string | null;
    district: string | null;
    street: string | null;
    buildingNumber: string | null;
    apartmentNumber: string | null;
    landmark: string | null;
    birthDate: Date | null;
    fatherName: string | null;
    idNumber: string | null;
    motherName: string | null;
    nationality: string | null;
    wifeName: string | null;
    wifeMotherName: string | null;
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> & {
        [P in keyof T & keyof UserGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], UserGroupByOutputType[P]>
          : GetScalarType<T[P], UserGroupByOutputType[P]>;
      }
    >
  >;

  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        name?: boolean;
        email?: boolean;
        emailVerified?: boolean;
        image?: boolean;
        passwordHash?: boolean;
        phone?: boolean;
        additionalPhone?: boolean;
        role?: boolean;
        createdByAdminId?: boolean;
        resetToken?: boolean;
        resetTokenExpiry?: boolean;
        verificationToken?: boolean;
        verificationTokenExpiry?: boolean;
        verificationCode?: boolean;
        verificationCodeExpiry?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        address?: boolean;
        governorate?: boolean;
        city?: boolean;
        district?: boolean;
        street?: boolean;
        buildingNumber?: boolean;
        apartmentNumber?: boolean;
        landmark?: boolean;
        birthDate?: boolean;
        fatherName?: boolean;
        idNumber?: boolean;
        motherName?: boolean;
        nationality?: boolean;
        wifeName?: boolean;
        wifeMotherName?: boolean;
        createdByAdmin?: boolean | User$createdByAdminArgs<ExtArgs>;
        createdUsers?: boolean | User$createdUsersArgs<ExtArgs>;
        createdOrders?: boolean | User$createdOrdersArgs<ExtArgs>;
        orders?: boolean | User$ordersArgs<ExtArgs>;
        accounts?: boolean | User$accountsArgs<ExtArgs>;
        auditLogs?: boolean | User$auditLogsArgs<ExtArgs>;
        sessions?: boolean | User$sessionsArgs<ExtArgs>;
        addedFormSerials?: boolean | User$addedFormSerialsArgs<ExtArgs>;
        consumedFormSerials?: boolean | User$consumedFormSerialsArgs<ExtArgs>;
        createdDependents?: boolean | User$createdDependentsArgs<ExtArgs>;
        _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['user']
    >;

  export type UserSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      email?: boolean;
      emailVerified?: boolean;
      image?: boolean;
      passwordHash?: boolean;
      phone?: boolean;
      additionalPhone?: boolean;
      role?: boolean;
      createdByAdminId?: boolean;
      resetToken?: boolean;
      resetTokenExpiry?: boolean;
      verificationToken?: boolean;
      verificationTokenExpiry?: boolean;
      verificationCode?: boolean;
      verificationCodeExpiry?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      address?: boolean;
      governorate?: boolean;
      city?: boolean;
      district?: boolean;
      street?: boolean;
      buildingNumber?: boolean;
      apartmentNumber?: boolean;
      landmark?: boolean;
      birthDate?: boolean;
      fatherName?: boolean;
      idNumber?: boolean;
      motherName?: boolean;
      nationality?: boolean;
      wifeName?: boolean;
      wifeMotherName?: boolean;
      createdByAdmin?: boolean | User$createdByAdminArgs<ExtArgs>;
    },
    ExtArgs['result']['user']
  >;

  export type UserSelectScalar = {
    id?: boolean;
    name?: boolean;
    email?: boolean;
    emailVerified?: boolean;
    image?: boolean;
    passwordHash?: boolean;
    phone?: boolean;
    additionalPhone?: boolean;
    role?: boolean;
    createdByAdminId?: boolean;
    resetToken?: boolean;
    resetTokenExpiry?: boolean;
    verificationToken?: boolean;
    verificationTokenExpiry?: boolean;
    verificationCode?: boolean;
    verificationCodeExpiry?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    address?: boolean;
    governorate?: boolean;
    city?: boolean;
    district?: boolean;
    street?: boolean;
    buildingNumber?: boolean;
    apartmentNumber?: boolean;
    landmark?: boolean;
    birthDate?: boolean;
    fatherName?: boolean;
    idNumber?: boolean;
    motherName?: boolean;
    nationality?: boolean;
    wifeName?: boolean;
    wifeMotherName?: boolean;
  };

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByAdmin?: boolean | User$createdByAdminArgs<ExtArgs>;
    createdUsers?: boolean | User$createdUsersArgs<ExtArgs>;
    createdOrders?: boolean | User$createdOrdersArgs<ExtArgs>;
    orders?: boolean | User$ordersArgs<ExtArgs>;
    accounts?: boolean | User$accountsArgs<ExtArgs>;
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>;
    sessions?: boolean | User$sessionsArgs<ExtArgs>;
    addedFormSerials?: boolean | User$addedFormSerialsArgs<ExtArgs>;
    consumedFormSerials?: boolean | User$consumedFormSerialsArgs<ExtArgs>;
    createdDependents?: boolean | User$createdDependentsArgs<ExtArgs>;
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type UserIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    createdByAdmin?: boolean | User$createdByAdminArgs<ExtArgs>;
  };

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: 'User';
    objects: {
      createdByAdmin: Prisma.$UserPayload<ExtArgs> | null;
      createdUsers: Prisma.$UserPayload<ExtArgs>[];
      createdOrders: Prisma.$OrderPayload<ExtArgs>[];
      orders: Prisma.$OrderPayload<ExtArgs>[];
      accounts: Prisma.$AccountPayload<ExtArgs>[];
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[];
      sessions: Prisma.$SessionPayload<ExtArgs>[];
      addedFormSerials: Prisma.$FormSerialPayload<ExtArgs>[];
      consumedFormSerials: Prisma.$FormSerialPayload<ExtArgs>[];
      createdDependents: Prisma.$DependentPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string | null;
        email: string | null;
        emailVerified: Date | null;
        image: string | null;
        passwordHash: string | null;
        phone: string | null;
        additionalPhone: string | null;
        role: string;
        createdByAdminId: string | null;
        resetToken: string | null;
        resetTokenExpiry: Date | null;
        verificationToken: string | null;
        verificationTokenExpiry: Date | null;
        verificationCode: string | null;
        verificationCodeExpiry: Date | null;
        createdAt: Date;
        updatedAt: Date;
        address: string | null;
        governorate: string | null;
        city: string | null;
        district: string | null;
        street: string | null;
        buildingNumber: string | null;
        apartmentNumber: string | null;
        landmark: string | null;
        birthDate: Date | null;
        fatherName: string | null;
        idNumber: string | null;
        motherName: string | null;
        nationality: string | null;
        wifeName: string | null;
        wifeMotherName: string | null;
      },
      ExtArgs['result']['user']
    >;
    composites: {};
  };

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<
    Prisma.$UserPayload,
    S
  >;

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    UserFindManyArgs,
    'select' | 'include' | 'distinct'
  > & {
    select?: UserCountAggregateInputType | true;
  };

  export interface UserDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User']; meta: { name: 'User' } };
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     *
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     *
     */
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     *
     */
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
     **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserAggregateArgs>(
      args: Subset<T, UserAggregateArgs>
    ): Prisma.PrismaPromise<GetUserAggregateType<T>>;

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the User model
     */
    readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    createdByAdmin<T extends User$createdByAdminArgs<ExtArgs> = {}>(
      args?: Subset<T, User$createdByAdminArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null,
      null,
      ExtArgs
    >;
    createdUsers<T extends User$createdUsersArgs<ExtArgs> = {}>(
      args?: Subset<T, User$createdUsersArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'> | Null>;
    createdOrders<T extends User$createdOrdersArgs<ExtArgs> = {}>(
      args?: Subset<T, User$createdOrdersArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findMany'> | Null>;
    orders<T extends User$ordersArgs<ExtArgs> = {}>(
      args?: Subset<T, User$ordersArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findMany'> | Null>;
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$accountsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$auditLogsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$sessionsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    addedFormSerials<T extends User$addedFormSerialsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$addedFormSerialsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$FormSerialPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    consumedFormSerials<T extends User$consumedFormSerialsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$consumedFormSerialsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$FormSerialPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    createdDependents<T extends User$createdDependentsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$createdDependentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$DependentPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<'User', 'String'>;
    readonly name: FieldRef<'User', 'String'>;
    readonly email: FieldRef<'User', 'String'>;
    readonly emailVerified: FieldRef<'User', 'DateTime'>;
    readonly image: FieldRef<'User', 'String'>;
    readonly passwordHash: FieldRef<'User', 'String'>;
    readonly phone: FieldRef<'User', 'String'>;
    readonly additionalPhone: FieldRef<'User', 'String'>;
    readonly role: FieldRef<'User', 'String'>;
    readonly createdByAdminId: FieldRef<'User', 'String'>;
    readonly resetToken: FieldRef<'User', 'String'>;
    readonly resetTokenExpiry: FieldRef<'User', 'DateTime'>;
    readonly verificationToken: FieldRef<'User', 'String'>;
    readonly verificationTokenExpiry: FieldRef<'User', 'DateTime'>;
    readonly verificationCode: FieldRef<'User', 'String'>;
    readonly verificationCodeExpiry: FieldRef<'User', 'DateTime'>;
    readonly createdAt: FieldRef<'User', 'DateTime'>;
    readonly updatedAt: FieldRef<'User', 'DateTime'>;
    readonly address: FieldRef<'User', 'String'>;
    readonly governorate: FieldRef<'User', 'String'>;
    readonly city: FieldRef<'User', 'String'>;
    readonly district: FieldRef<'User', 'String'>;
    readonly street: FieldRef<'User', 'String'>;
    readonly buildingNumber: FieldRef<'User', 'String'>;
    readonly apartmentNumber: FieldRef<'User', 'String'>;
    readonly landmark: FieldRef<'User', 'String'>;
    readonly birthDate: FieldRef<'User', 'DateTime'>;
    readonly fatherName: FieldRef<'User', 'String'>;
    readonly idNumber: FieldRef<'User', 'String'>;
    readonly motherName: FieldRef<'User', 'String'>;
    readonly nationality: FieldRef<'User', 'String'>;
    readonly wifeName: FieldRef<'User', 'String'>;
    readonly wifeMotherName: FieldRef<'User', 'String'>;
  }

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the User
       */
      select?: UserSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: UserInclude<ExtArgs> | null;
      /**
       * Filter, which Users to fetch.
       */
      where?: UserWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Users to fetch.
       */
      orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing Users.
       */
      cursor?: UserWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Users from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Users.
       */
      skip?: number;
      distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
    };

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>;
  };

  /**
   * User createMany
   */
  export type UserCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
  };

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput;
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>;
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
  };

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput;
  };

  /**
   * User.createdByAdmin
   */
  export type User$createdByAdminArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * User.createdUsers
   */
  export type User$createdUsersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    cursor?: UserWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User.createdOrders
   */
  export type User$createdOrdersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    where?: OrderWhereInput;
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[];
    cursor?: OrderWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[];
  };

  /**
   * User.orders
   */
  export type User$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Order
       */
      select?: OrderSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: OrderInclude<ExtArgs> | null;
      where?: OrderWhereInput;
      orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[];
      cursor?: OrderWhereUniqueInput;
      take?: number;
      skip?: number;
      distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[];
    };

  /**
   * User.accounts
   */
  export type User$accountsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    where?: AccountWhereInput;
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[];
    cursor?: AccountWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    where?: AuditLogWhereInput;
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[];
    cursor?: AuditLogWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * User.sessions
   */
  export type User$sessionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    where?: SessionWhereInput;
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[];
    cursor?: SessionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * User.addedFormSerials
   */
  export type User$addedFormSerialsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormSerial
     */
    select?: FormSerialSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSerialInclude<ExtArgs> | null;
    where?: FormSerialWhereInput;
    orderBy?: FormSerialOrderByWithRelationInput | FormSerialOrderByWithRelationInput[];
    cursor?: FormSerialWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: FormSerialScalarFieldEnum | FormSerialScalarFieldEnum[];
  };

  /**
   * User.consumedFormSerials
   */
  export type User$consumedFormSerialsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormSerial
     */
    select?: FormSerialSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSerialInclude<ExtArgs> | null;
    where?: FormSerialWhereInput;
    orderBy?: FormSerialOrderByWithRelationInput | FormSerialOrderByWithRelationInput[];
    cursor?: FormSerialWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: FormSerialScalarFieldEnum | FormSerialScalarFieldEnum[];
  };

  /**
   * User.createdDependents
   */
  export type User$createdDependentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Dependent
     */
    select?: DependentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependentInclude<ExtArgs> | null;
    where?: DependentWhereInput;
    orderBy?: DependentOrderByWithRelationInput | DependentOrderByWithRelationInput[];
    cursor?: DependentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: DependentScalarFieldEnum | DependentScalarFieldEnum[];
  };

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the User
       */
      select?: UserSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: UserInclude<ExtArgs> | null;
    };

  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null;
    _avg: CategoryAvgAggregateOutputType | null;
    _sum: CategorySumAggregateOutputType | null;
    _min: CategoryMinAggregateOutputType | null;
    _max: CategoryMaxAggregateOutputType | null;
  };

  export type CategoryAvgAggregateOutputType = {
    orderIndex: number | null;
  };

  export type CategorySumAggregateOutputType = {
    orderIndex: number | null;
  };

  export type CategoryMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    slug: string | null;
    orderIndex: number | null;
    active: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    icon: string | null;
  };

  export type CategoryMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    slug: string | null;
    orderIndex: number | null;
    active: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    icon: string | null;
  };

  export type CategoryCountAggregateOutputType = {
    id: number;
    name: number;
    slug: number;
    orderIndex: number;
    active: number;
    createdAt: number;
    updatedAt: number;
    icon: number;
    _all: number;
  };

  export type CategoryAvgAggregateInputType = {
    orderIndex?: true;
  };

  export type CategorySumAggregateInputType = {
    orderIndex?: true;
  };

  export type CategoryMinAggregateInputType = {
    id?: true;
    name?: true;
    slug?: true;
    orderIndex?: true;
    active?: true;
    createdAt?: true;
    updatedAt?: true;
    icon?: true;
  };

  export type CategoryMaxAggregateInputType = {
    id?: true;
    name?: true;
    slug?: true;
    orderIndex?: true;
    active?: true;
    createdAt?: true;
    updatedAt?: true;
    icon?: true;
  };

  export type CategoryCountAggregateInputType = {
    id?: true;
    name?: true;
    slug?: true;
    orderIndex?: true;
    active?: true;
    createdAt?: true;
    updatedAt?: true;
    icon?: true;
    _all?: true;
  };

  export type CategoryAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Categories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Categories
     **/
    _count?: true | CategoryCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: CategoryAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: CategorySumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CategoryMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CategoryMaxAggregateInputType;
  };

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
    [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>;
  };

  export type CategoryGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[];
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum;
    having?: CategoryScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CategoryCountAggregateInputType | true;
    _avg?: CategoryAvgAggregateInputType;
    _sum?: CategorySumAggregateInputType;
    _min?: CategoryMinAggregateInputType;
    _max?: CategoryMaxAggregateInputType;
  };

  export type CategoryGroupByOutputType = {
    id: string;
    name: string;
    slug: string;
    orderIndex: number;
    active: boolean;
    createdAt: Date;
    updatedAt: Date;
    icon: string | null;
    _count: CategoryCountAggregateOutputType | null;
    _avg: CategoryAvgAggregateOutputType | null;
    _sum: CategorySumAggregateOutputType | null;
    _min: CategoryMinAggregateOutputType | null;
    _max: CategoryMaxAggregateOutputType | null;
  };

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> & {
        [P in keyof T & keyof CategoryGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
          : GetScalarType<T[P], CategoryGroupByOutputType[P]>;
      }
    >
  >;

  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        name?: boolean;
        slug?: boolean;
        orderIndex?: boolean;
        active?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        icon?: boolean;
        services?: boolean | Category$servicesArgs<ExtArgs>;
        _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['category']
    >;

  export type CategorySelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      slug?: boolean;
      orderIndex?: boolean;
      active?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      icon?: boolean;
    },
    ExtArgs['result']['category']
  >;

  export type CategorySelectScalar = {
    id?: boolean;
    name?: boolean;
    slug?: boolean;
    orderIndex?: boolean;
    active?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    icon?: boolean;
  };

  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      services?: boolean | Category$servicesArgs<ExtArgs>;
      _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>;
    };
  export type CategoryIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Category';
      objects: {
        services: Prisma.$ServicePayload<ExtArgs>[];
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          name: string;
          slug: string;
          orderIndex: number;
          active: boolean;
          createdAt: Date;
          updatedAt: Date;
          icon: string | null;
        },
        ExtArgs['result']['category']
      >;
      composites: {};
    };

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> =
    $Result.GetResult<Prisma.$CategoryPayload, S>;

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    CategoryFindManyArgs,
    'select' | 'include' | 'distinct'
  > & {
    select?: CategoryCountAggregateInputType | true;
  };

  export interface CategoryDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Category'];
      meta: { name: 'Category' };
    };
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(
      args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>
    ): Prisma__CategoryClient<
      $Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CategoryClient<
      $Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(
      args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>
    ): Prisma__CategoryClient<
      $Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CategoryClient<
      $Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     *
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CategoryFindManyArgs>(
      args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     *
     */
    create<T extends CategoryCreateArgs>(
      args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>
    ): Prisma__CategoryClient<
      $Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CategoryCreateManyArgs>(
      args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(
      args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     *
     */
    delete<T extends CategoryDeleteArgs>(
      args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>
    ): Prisma__CategoryClient<
      $Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CategoryUpdateArgs>(
      args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>
    ): Prisma__CategoryClient<
      $Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CategoryDeleteManyArgs>(
      args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CategoryUpdateManyArgs>(
      args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(
      args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>
    ): Prisma__CategoryClient<
      $Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
     **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CategoryAggregateArgs>(
      args: Subset<T, CategoryAggregateArgs>
    ): Prisma.PrismaPromise<GetCategoryAggregateType<T>>;

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Category model
     */
    readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    services<T extends Category$servicesArgs<ExtArgs> = {}>(
      args?: Subset<T, Category$servicesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findMany'> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<'Category', 'String'>;
    readonly name: FieldRef<'Category', 'String'>;
    readonly slug: FieldRef<'Category', 'String'>;
    readonly orderIndex: FieldRef<'Category', 'Int'>;
    readonly active: FieldRef<'Category', 'Boolean'>;
    readonly createdAt: FieldRef<'Category', 'DateTime'>;
    readonly updatedAt: FieldRef<'Category', 'DateTime'>;
    readonly icon: FieldRef<'Category', 'String'>;
  }

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null;
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput;
  };

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null;
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput;
  };

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null;
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Categories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[];
  };

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null;
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Categories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[];
  };

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null;
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Categories.
     */
    skip?: number;
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[];
  };

  /**
   * Category create
   */
  export type CategoryCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null;
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>;
  };

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Category update
   */
  export type CategoryUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null;
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>;
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput;
  };

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>;
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput;
  };

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null;
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput;
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>;
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>;
  };

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null;
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput;
  };

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput;
  };

  /**
   * Category.services
   */
  export type Category$servicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[];
    cursor?: ServiceWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[];
  };

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null;
  };

  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null;
    _min: ServiceMinAggregateOutputType | null;
    _max: ServiceMaxAggregateOutputType | null;
  };

  export type ServiceMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    slug: string | null;
    description: string | null;
    icon: string | null;
    active: boolean | null;
    categoryId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ServiceMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    slug: string | null;
    description: string | null;
    icon: string | null;
    active: boolean | null;
    categoryId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ServiceCountAggregateOutputType = {
    id: number;
    name: number;
    slug: number;
    description: number;
    icon: number;
    active: number;
    categoryId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type ServiceMinAggregateInputType = {
    id?: true;
    name?: true;
    slug?: true;
    description?: true;
    icon?: true;
    active?: true;
    categoryId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ServiceMaxAggregateInputType = {
    id?: true;
    name?: true;
    slug?: true;
    description?: true;
    icon?: true;
    active?: true;
    categoryId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ServiceCountAggregateInputType = {
    id?: true;
    name?: true;
    slug?: true;
    description?: true;
    icon?: true;
    active?: true;
    categoryId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type ServiceAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Services from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Services.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Services
     **/
    _count?: true | ServiceCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ServiceMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ServiceMaxAggregateInputType;
  };

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
    [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>;
  };

  export type ServiceGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[];
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum;
    having?: ServiceScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ServiceCountAggregateInputType | true;
    _min?: ServiceMinAggregateInputType;
    _max?: ServiceMaxAggregateInputType;
  };

  export type ServiceGroupByOutputType = {
    id: string;
    name: string;
    slug: string;
    description: string | null;
    icon: string | null;
    active: boolean;
    categoryId: string;
    createdAt: Date;
    updatedAt: Date;
    _count: ServiceCountAggregateOutputType | null;
    _min: ServiceMinAggregateOutputType | null;
    _max: ServiceMaxAggregateOutputType | null;
  };

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> & {
        [P in keyof T & keyof ServiceGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
          : GetScalarType<T[P], ServiceGroupByOutputType[P]>;
      }
    >
  >;

  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        name?: boolean;
        slug?: boolean;
        description?: boolean;
        icon?: boolean;
        active?: boolean;
        categoryId?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        orders?: boolean | Service$ordersArgs<ExtArgs>;
        category?: boolean | CategoryDefaultArgs<ExtArgs>;
        documents?: boolean | Service$documentsArgs<ExtArgs>;
        variants?: boolean | Service$variantsArgs<ExtArgs>;
        fields?: boolean | Service$fieldsArgs<ExtArgs>;
        _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['service']
    >;

  export type ServiceSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      slug?: boolean;
      description?: boolean;
      icon?: boolean;
      active?: boolean;
      categoryId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      category?: boolean | CategoryDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['service']
  >;

  export type ServiceSelectScalar = {
    id?: boolean;
    name?: boolean;
    slug?: boolean;
    description?: boolean;
    icon?: boolean;
    active?: boolean;
    categoryId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | Service$ordersArgs<ExtArgs>;
    category?: boolean | CategoryDefaultArgs<ExtArgs>;
    documents?: boolean | Service$documentsArgs<ExtArgs>;
    variants?: boolean | Service$variantsArgs<ExtArgs>;
    fields?: boolean | Service$fieldsArgs<ExtArgs>;
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type ServiceIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>;
  };

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Service';
      objects: {
        orders: Prisma.$OrderPayload<ExtArgs>[];
        category: Prisma.$CategoryPayload<ExtArgs>;
        documents: Prisma.$ServiceDocumentPayload<ExtArgs>[];
        variants: Prisma.$ServiceVariantPayload<ExtArgs>[];
        fields: Prisma.$ServiceFieldPayload<ExtArgs>[];
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          name: string;
          slug: string;
          description: string | null;
          icon: string | null;
          active: boolean;
          categoryId: string;
          createdAt: Date;
          updatedAt: Date;
        },
        ExtArgs['result']['service']
      >;
      composites: {};
    };

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> =
    $Result.GetResult<Prisma.$ServicePayload, S>;

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    ServiceFindManyArgs,
    'select' | 'include' | 'distinct'
  > & {
    select?: ServiceCountAggregateInputType | true;
  };

  export interface ServiceDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service']; meta: { name: 'Service' } };
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(
      args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(
      args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     *
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ServiceFindManyArgs>(
      args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     *
     */
    create<T extends ServiceCreateArgs>(
      args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ServiceCreateManyArgs>(
      args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     *
     */
    delete<T extends ServiceDeleteArgs>(
      args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ServiceUpdateArgs>(
      args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ServiceDeleteManyArgs>(
      args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ServiceUpdateManyArgs>(
      args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(
      args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
     **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ServiceAggregateArgs>(
      args: Subset<T, ServiceAggregateArgs>
    ): Prisma.PrismaPromise<GetServiceAggregateType<T>>;

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Service model
     */
    readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    orders<T extends Service$ordersArgs<ExtArgs> = {}>(
      args?: Subset<T, Service$ordersArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findMany'> | Null>;
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, CategoryDefaultArgs<ExtArgs>>
    ): Prisma__CategoryClient<
      $Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    documents<T extends Service$documentsArgs<ExtArgs> = {}>(
      args?: Subset<T, Service$documentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ServiceDocumentPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    variants<T extends Service$variantsArgs<ExtArgs> = {}>(
      args?: Subset<T, Service$variantsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ServiceVariantPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    fields<T extends Service$fieldsArgs<ExtArgs> = {}>(
      args?: Subset<T, Service$fieldsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ServiceFieldPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<'Service', 'String'>;
    readonly name: FieldRef<'Service', 'String'>;
    readonly slug: FieldRef<'Service', 'String'>;
    readonly description: FieldRef<'Service', 'String'>;
    readonly icon: FieldRef<'Service', 'String'>;
    readonly active: FieldRef<'Service', 'Boolean'>;
    readonly categoryId: FieldRef<'Service', 'String'>;
    readonly createdAt: FieldRef<'Service', 'DateTime'>;
    readonly updatedAt: FieldRef<'Service', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput;
  };

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput;
  };

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Services from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Services.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[];
  };

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Services from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Services.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[];
  };

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Services from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Services.
     */
    skip?: number;
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[];
  };

  /**
   * Service create
   */
  export type ServiceCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>;
  };

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Service update
   */
  export type ServiceUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>;
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput;
  };

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>;
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput;
  };

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput;
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>;
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>;
  };

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput;
  };

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput;
  };

  /**
   * Service.orders
   */
  export type Service$ordersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    where?: OrderWhereInput;
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[];
    cursor?: OrderWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[];
  };

  /**
   * Service.documents
   */
  export type Service$documentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceDocument
     */
    select?: ServiceDocumentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDocumentInclude<ExtArgs> | null;
    where?: ServiceDocumentWhereInput;
    orderBy?: ServiceDocumentOrderByWithRelationInput | ServiceDocumentOrderByWithRelationInput[];
    cursor?: ServiceDocumentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ServiceDocumentScalarFieldEnum | ServiceDocumentScalarFieldEnum[];
  };

  /**
   * Service.variants
   */
  export type Service$variantsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantInclude<ExtArgs> | null;
    where?: ServiceVariantWhereInput;
    orderBy?: ServiceVariantOrderByWithRelationInput | ServiceVariantOrderByWithRelationInput[];
    cursor?: ServiceVariantWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ServiceVariantScalarFieldEnum | ServiceVariantScalarFieldEnum[];
  };

  /**
   * Service.fields
   */
  export type Service$fieldsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceField
     */
    select?: ServiceFieldSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFieldInclude<ExtArgs> | null;
    where?: ServiceFieldWhereInput;
    orderBy?: ServiceFieldOrderByWithRelationInput | ServiceFieldOrderByWithRelationInput[];
    cursor?: ServiceFieldWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ServiceFieldScalarFieldEnum | ServiceFieldScalarFieldEnum[];
  };

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
  };

  /**
   * Model ServiceField
   */

  export type AggregateServiceField = {
    _count: ServiceFieldCountAggregateOutputType | null;
    _avg: ServiceFieldAvgAggregateOutputType | null;
    _sum: ServiceFieldSumAggregateOutputType | null;
    _min: ServiceFieldMinAggregateOutputType | null;
    _max: ServiceFieldMaxAggregateOutputType | null;
  };

  export type ServiceFieldAvgAggregateOutputType = {
    orderIndex: number | null;
  };

  export type ServiceFieldSumAggregateOutputType = {
    orderIndex: number | null;
  };

  export type ServiceFieldMinAggregateOutputType = {
    id: string | null;
    serviceId: string | null;
    name: string | null;
    label: string | null;
    type: string | null;
    placeholder: string | null;
    required: boolean | null;
    orderIndex: number | null;
    active: boolean | null;
    showIf: string | null;
    validation: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ServiceFieldMaxAggregateOutputType = {
    id: string | null;
    serviceId: string | null;
    name: string | null;
    label: string | null;
    type: string | null;
    placeholder: string | null;
    required: boolean | null;
    orderIndex: number | null;
    active: boolean | null;
    showIf: string | null;
    validation: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ServiceFieldCountAggregateOutputType = {
    id: number;
    serviceId: number;
    name: number;
    label: number;
    type: number;
    placeholder: number;
    required: number;
    orderIndex: number;
    active: number;
    showIf: number;
    validation: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type ServiceFieldAvgAggregateInputType = {
    orderIndex?: true;
  };

  export type ServiceFieldSumAggregateInputType = {
    orderIndex?: true;
  };

  export type ServiceFieldMinAggregateInputType = {
    id?: true;
    serviceId?: true;
    name?: true;
    label?: true;
    type?: true;
    placeholder?: true;
    required?: true;
    orderIndex?: true;
    active?: true;
    showIf?: true;
    validation?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ServiceFieldMaxAggregateInputType = {
    id?: true;
    serviceId?: true;
    name?: true;
    label?: true;
    type?: true;
    placeholder?: true;
    required?: true;
    orderIndex?: true;
    active?: true;
    showIf?: true;
    validation?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ServiceFieldCountAggregateInputType = {
    id?: true;
    serviceId?: true;
    name?: true;
    label?: true;
    type?: true;
    placeholder?: true;
    required?: true;
    orderIndex?: true;
    active?: true;
    showIf?: true;
    validation?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type ServiceFieldAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ServiceField to aggregate.
     */
    where?: ServiceFieldWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ServiceFields to fetch.
     */
    orderBy?: ServiceFieldOrderByWithRelationInput | ServiceFieldOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ServiceFieldWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ServiceFields from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ServiceFields.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ServiceFields
     **/
    _count?: true | ServiceFieldCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ServiceFieldAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ServiceFieldSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ServiceFieldMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ServiceFieldMaxAggregateInputType;
  };

  export type GetServiceFieldAggregateType<T extends ServiceFieldAggregateArgs> = {
    [P in keyof T & keyof AggregateServiceField]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceField[P]>
      : GetScalarType<T[P], AggregateServiceField[P]>;
  };

  export type ServiceFieldGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ServiceFieldWhereInput;
    orderBy?: ServiceFieldOrderByWithAggregationInput | ServiceFieldOrderByWithAggregationInput[];
    by: ServiceFieldScalarFieldEnum[] | ServiceFieldScalarFieldEnum;
    having?: ServiceFieldScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ServiceFieldCountAggregateInputType | true;
    _avg?: ServiceFieldAvgAggregateInputType;
    _sum?: ServiceFieldSumAggregateInputType;
    _min?: ServiceFieldMinAggregateInputType;
    _max?: ServiceFieldMaxAggregateInputType;
  };

  export type ServiceFieldGroupByOutputType = {
    id: string;
    serviceId: string;
    name: string;
    label: string;
    type: string;
    placeholder: string | null;
    required: boolean;
    orderIndex: number;
    active: boolean;
    showIf: string | null;
    validation: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: ServiceFieldCountAggregateOutputType | null;
    _avg: ServiceFieldAvgAggregateOutputType | null;
    _sum: ServiceFieldSumAggregateOutputType | null;
    _min: ServiceFieldMinAggregateOutputType | null;
    _max: ServiceFieldMaxAggregateOutputType | null;
  };

  type GetServiceFieldGroupByPayload<T extends ServiceFieldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceFieldGroupByOutputType, T['by']> & {
        [P in keyof T & keyof ServiceFieldGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ServiceFieldGroupByOutputType[P]>
          : GetScalarType<T[P], ServiceFieldGroupByOutputType[P]>;
      }
    >
  >;

  export type ServiceFieldSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      serviceId?: boolean;
      name?: boolean;
      label?: boolean;
      type?: boolean;
      placeholder?: boolean;
      required?: boolean;
      orderIndex?: boolean;
      active?: boolean;
      showIf?: boolean;
      validation?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      service?: boolean | ServiceDefaultArgs<ExtArgs>;
      options?: boolean | ServiceField$optionsArgs<ExtArgs>;
      _count?: boolean | ServiceFieldCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['serviceField']
  >;

  export type ServiceFieldSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      serviceId?: boolean;
      name?: boolean;
      label?: boolean;
      type?: boolean;
      placeholder?: boolean;
      required?: boolean;
      orderIndex?: boolean;
      active?: boolean;
      showIf?: boolean;
      validation?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      service?: boolean | ServiceDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['serviceField']
  >;

  export type ServiceFieldSelectScalar = {
    id?: boolean;
    serviceId?: boolean;
    name?: boolean;
    label?: boolean;
    type?: boolean;
    placeholder?: boolean;
    required?: boolean;
    orderIndex?: boolean;
    active?: boolean;
    showIf?: boolean;
    validation?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type ServiceFieldInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>;
    options?: boolean | ServiceField$optionsArgs<ExtArgs>;
    _count?: boolean | ServiceFieldCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type ServiceFieldIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>;
  };

  export type $ServiceFieldPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'ServiceField';
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>;
      options: Prisma.$ServiceFieldOptionPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        serviceId: string;
        name: string;
        label: string;
        type: string;
        placeholder: string | null;
        required: boolean;
        orderIndex: number;
        active: boolean;
        showIf: string | null;
        validation: string | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['serviceField']
    >;
    composites: {};
  };

  type ServiceFieldGetPayload<S extends boolean | null | undefined | ServiceFieldDefaultArgs> =
    $Result.GetResult<Prisma.$ServiceFieldPayload, S>;

  type ServiceFieldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFieldFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceFieldCountAggregateInputType | true;
    };

  export interface ServiceFieldDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ServiceField'];
      meta: { name: 'ServiceField' };
    };
    /**
     * Find zero or one ServiceField that matches the filter.
     * @param {ServiceFieldFindUniqueArgs} args - Arguments to find a ServiceField
     * @example
     * // Get one ServiceField
     * const serviceField = await prisma.serviceField.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFieldFindUniqueArgs>(
      args: SelectSubset<T, ServiceFieldFindUniqueArgs<ExtArgs>>
    ): Prisma__ServiceFieldClient<
      $Result.GetResult<Prisma.$ServiceFieldPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one ServiceField that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFieldFindUniqueOrThrowArgs} args - Arguments to find a ServiceField
     * @example
     * // Get one ServiceField
     * const serviceField = await prisma.serviceField.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFieldFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ServiceFieldFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceFieldClient<
      $Result.GetResult<Prisma.$ServiceFieldPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first ServiceField that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFieldFindFirstArgs} args - Arguments to find a ServiceField
     * @example
     * // Get one ServiceField
     * const serviceField = await prisma.serviceField.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFieldFindFirstArgs>(
      args?: SelectSubset<T, ServiceFieldFindFirstArgs<ExtArgs>>
    ): Prisma__ServiceFieldClient<
      $Result.GetResult<Prisma.$ServiceFieldPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first ServiceField that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFieldFindFirstOrThrowArgs} args - Arguments to find a ServiceField
     * @example
     * // Get one ServiceField
     * const serviceField = await prisma.serviceField.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFieldFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ServiceFieldFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceFieldClient<
      $Result.GetResult<Prisma.$ServiceFieldPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more ServiceFields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFieldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceFields
     * const serviceFields = await prisma.serviceField.findMany()
     *
     * // Get first 10 ServiceFields
     * const serviceFields = await prisma.serviceField.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const serviceFieldWithIdOnly = await prisma.serviceField.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ServiceFieldFindManyArgs>(
      args?: SelectSubset<T, ServiceFieldFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceFieldPayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a ServiceField.
     * @param {ServiceFieldCreateArgs} args - Arguments to create a ServiceField.
     * @example
     * // Create one ServiceField
     * const ServiceField = await prisma.serviceField.create({
     *   data: {
     *     // ... data to create a ServiceField
     *   }
     * })
     *
     */
    create<T extends ServiceFieldCreateArgs>(
      args: SelectSubset<T, ServiceFieldCreateArgs<ExtArgs>>
    ): Prisma__ServiceFieldClient<
      $Result.GetResult<Prisma.$ServiceFieldPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many ServiceFields.
     * @param {ServiceFieldCreateManyArgs} args - Arguments to create many ServiceFields.
     * @example
     * // Create many ServiceFields
     * const serviceField = await prisma.serviceField.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ServiceFieldCreateManyArgs>(
      args?: SelectSubset<T, ServiceFieldCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ServiceFields and returns the data saved in the database.
     * @param {ServiceFieldCreateManyAndReturnArgs} args - Arguments to create many ServiceFields.
     * @example
     * // Create many ServiceFields
     * const serviceField = await prisma.serviceField.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ServiceFields and only return the `id`
     * const serviceFieldWithIdOnly = await prisma.serviceField.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ServiceFieldCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ServiceFieldCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ServiceFieldPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a ServiceField.
     * @param {ServiceFieldDeleteArgs} args - Arguments to delete one ServiceField.
     * @example
     * // Delete one ServiceField
     * const ServiceField = await prisma.serviceField.delete({
     *   where: {
     *     // ... filter to delete one ServiceField
     *   }
     * })
     *
     */
    delete<T extends ServiceFieldDeleteArgs>(
      args: SelectSubset<T, ServiceFieldDeleteArgs<ExtArgs>>
    ): Prisma__ServiceFieldClient<
      $Result.GetResult<Prisma.$ServiceFieldPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one ServiceField.
     * @param {ServiceFieldUpdateArgs} args - Arguments to update one ServiceField.
     * @example
     * // Update one ServiceField
     * const serviceField = await prisma.serviceField.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ServiceFieldUpdateArgs>(
      args: SelectSubset<T, ServiceFieldUpdateArgs<ExtArgs>>
    ): Prisma__ServiceFieldClient<
      $Result.GetResult<Prisma.$ServiceFieldPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more ServiceFields.
     * @param {ServiceFieldDeleteManyArgs} args - Arguments to filter ServiceFields to delete.
     * @example
     * // Delete a few ServiceFields
     * const { count } = await prisma.serviceField.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ServiceFieldDeleteManyArgs>(
      args?: SelectSubset<T, ServiceFieldDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ServiceFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFieldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceFields
     * const serviceField = await prisma.serviceField.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ServiceFieldUpdateManyArgs>(
      args: SelectSubset<T, ServiceFieldUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one ServiceField.
     * @param {ServiceFieldUpsertArgs} args - Arguments to update or create a ServiceField.
     * @example
     * // Update or create a ServiceField
     * const serviceField = await prisma.serviceField.upsert({
     *   create: {
     *     // ... data to create a ServiceField
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceField we want to update
     *   }
     * })
     */
    upsert<T extends ServiceFieldUpsertArgs>(
      args: SelectSubset<T, ServiceFieldUpsertArgs<ExtArgs>>
    ): Prisma__ServiceFieldClient<
      $Result.GetResult<Prisma.$ServiceFieldPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of ServiceFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFieldCountArgs} args - Arguments to filter ServiceFields to count.
     * @example
     * // Count the number of ServiceFields
     * const count = await prisma.serviceField.count({
     *   where: {
     *     // ... the filter for the ServiceFields we want to count
     *   }
     * })
     **/
    count<T extends ServiceFieldCountArgs>(
      args?: Subset<T, ServiceFieldCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceFieldCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ServiceField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFieldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ServiceFieldAggregateArgs>(
      args: Subset<T, ServiceFieldAggregateArgs>
    ): Prisma.PrismaPromise<GetServiceFieldAggregateType<T>>;

    /**
     * Group by ServiceField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFieldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ServiceFieldGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceFieldGroupByArgs['orderBy'] }
        : { orderBy?: ServiceFieldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ServiceFieldGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetServiceFieldGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ServiceField model
     */
    readonly fields: ServiceFieldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceField.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceFieldClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ServiceDefaultArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    options<T extends ServiceField$optionsArgs<ExtArgs> = {}>(
      args?: Subset<T, ServiceField$optionsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ServiceFieldOptionPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ServiceField model
   */
  interface ServiceFieldFieldRefs {
    readonly id: FieldRef<'ServiceField', 'String'>;
    readonly serviceId: FieldRef<'ServiceField', 'String'>;
    readonly name: FieldRef<'ServiceField', 'String'>;
    readonly label: FieldRef<'ServiceField', 'String'>;
    readonly type: FieldRef<'ServiceField', 'String'>;
    readonly placeholder: FieldRef<'ServiceField', 'String'>;
    readonly required: FieldRef<'ServiceField', 'Boolean'>;
    readonly orderIndex: FieldRef<'ServiceField', 'Int'>;
    readonly active: FieldRef<'ServiceField', 'Boolean'>;
    readonly showIf: FieldRef<'ServiceField', 'String'>;
    readonly validation: FieldRef<'ServiceField', 'String'>;
    readonly createdAt: FieldRef<'ServiceField', 'DateTime'>;
    readonly updatedAt: FieldRef<'ServiceField', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * ServiceField findUnique
   */
  export type ServiceFieldFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceField
     */
    select?: ServiceFieldSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFieldInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceField to fetch.
     */
    where: ServiceFieldWhereUniqueInput;
  };

  /**
   * ServiceField findUniqueOrThrow
   */
  export type ServiceFieldFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceField
     */
    select?: ServiceFieldSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFieldInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceField to fetch.
     */
    where: ServiceFieldWhereUniqueInput;
  };

  /**
   * ServiceField findFirst
   */
  export type ServiceFieldFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceField
     */
    select?: ServiceFieldSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFieldInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceField to fetch.
     */
    where?: ServiceFieldWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ServiceFields to fetch.
     */
    orderBy?: ServiceFieldOrderByWithRelationInput | ServiceFieldOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ServiceFields.
     */
    cursor?: ServiceFieldWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ServiceFields from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ServiceFields.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ServiceFields.
     */
    distinct?: ServiceFieldScalarFieldEnum | ServiceFieldScalarFieldEnum[];
  };

  /**
   * ServiceField findFirstOrThrow
   */
  export type ServiceFieldFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceField
     */
    select?: ServiceFieldSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFieldInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceField to fetch.
     */
    where?: ServiceFieldWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ServiceFields to fetch.
     */
    orderBy?: ServiceFieldOrderByWithRelationInput | ServiceFieldOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ServiceFields.
     */
    cursor?: ServiceFieldWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ServiceFields from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ServiceFields.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ServiceFields.
     */
    distinct?: ServiceFieldScalarFieldEnum | ServiceFieldScalarFieldEnum[];
  };

  /**
   * ServiceField findMany
   */
  export type ServiceFieldFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceField
     */
    select?: ServiceFieldSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFieldInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceFields to fetch.
     */
    where?: ServiceFieldWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ServiceFields to fetch.
     */
    orderBy?: ServiceFieldOrderByWithRelationInput | ServiceFieldOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ServiceFields.
     */
    cursor?: ServiceFieldWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ServiceFields from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ServiceFields.
     */
    skip?: number;
    distinct?: ServiceFieldScalarFieldEnum | ServiceFieldScalarFieldEnum[];
  };

  /**
   * ServiceField create
   */
  export type ServiceFieldCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceField
     */
    select?: ServiceFieldSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFieldInclude<ExtArgs> | null;
    /**
     * The data needed to create a ServiceField.
     */
    data: XOR<ServiceFieldCreateInput, ServiceFieldUncheckedCreateInput>;
  };

  /**
   * ServiceField createMany
   */
  export type ServiceFieldCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ServiceFields.
     */
    data: ServiceFieldCreateManyInput | ServiceFieldCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ServiceField createManyAndReturn
   */
  export type ServiceFieldCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceField
     */
    select?: ServiceFieldSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many ServiceFields.
     */
    data: ServiceFieldCreateManyInput | ServiceFieldCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFieldIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ServiceField update
   */
  export type ServiceFieldUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceField
     */
    select?: ServiceFieldSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFieldInclude<ExtArgs> | null;
    /**
     * The data needed to update a ServiceField.
     */
    data: XOR<ServiceFieldUpdateInput, ServiceFieldUncheckedUpdateInput>;
    /**
     * Choose, which ServiceField to update.
     */
    where: ServiceFieldWhereUniqueInput;
  };

  /**
   * ServiceField updateMany
   */
  export type ServiceFieldUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ServiceFields.
     */
    data: XOR<ServiceFieldUpdateManyMutationInput, ServiceFieldUncheckedUpdateManyInput>;
    /**
     * Filter which ServiceFields to update
     */
    where?: ServiceFieldWhereInput;
  };

  /**
   * ServiceField upsert
   */
  export type ServiceFieldUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceField
     */
    select?: ServiceFieldSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFieldInclude<ExtArgs> | null;
    /**
     * The filter to search for the ServiceField to update in case it exists.
     */
    where: ServiceFieldWhereUniqueInput;
    /**
     * In case the ServiceField found by the `where` argument doesn't exist, create a new ServiceField with this data.
     */
    create: XOR<ServiceFieldCreateInput, ServiceFieldUncheckedCreateInput>;
    /**
     * In case the ServiceField was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceFieldUpdateInput, ServiceFieldUncheckedUpdateInput>;
  };

  /**
   * ServiceField delete
   */
  export type ServiceFieldDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceField
     */
    select?: ServiceFieldSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFieldInclude<ExtArgs> | null;
    /**
     * Filter which ServiceField to delete.
     */
    where: ServiceFieldWhereUniqueInput;
  };

  /**
   * ServiceField deleteMany
   */
  export type ServiceFieldDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ServiceFields to delete
     */
    where?: ServiceFieldWhereInput;
  };

  /**
   * ServiceField.options
   */
  export type ServiceField$optionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceFieldOption
     */
    select?: ServiceFieldOptionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFieldOptionInclude<ExtArgs> | null;
    where?: ServiceFieldOptionWhereInput;
    orderBy?:
      | ServiceFieldOptionOrderByWithRelationInput
      | ServiceFieldOptionOrderByWithRelationInput[];
    cursor?: ServiceFieldOptionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ServiceFieldOptionScalarFieldEnum | ServiceFieldOptionScalarFieldEnum[];
  };

  /**
   * ServiceField without action
   */
  export type ServiceFieldDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceField
     */
    select?: ServiceFieldSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFieldInclude<ExtArgs> | null;
  };

  /**
   * Model ServiceFieldOption
   */

  export type AggregateServiceFieldOption = {
    _count: ServiceFieldOptionCountAggregateOutputType | null;
    _avg: ServiceFieldOptionAvgAggregateOutputType | null;
    _sum: ServiceFieldOptionSumAggregateOutputType | null;
    _min: ServiceFieldOptionMinAggregateOutputType | null;
    _max: ServiceFieldOptionMaxAggregateOutputType | null;
  };

  export type ServiceFieldOptionAvgAggregateOutputType = {
    orderIndex: number | null;
  };

  export type ServiceFieldOptionSumAggregateOutputType = {
    orderIndex: number | null;
  };

  export type ServiceFieldOptionMinAggregateOutputType = {
    id: string | null;
    fieldId: string | null;
    value: string | null;
    label: string | null;
    orderIndex: number | null;
    requiredDocs: string | null;
    showFields: string | null;
    createdAt: Date | null;
  };

  export type ServiceFieldOptionMaxAggregateOutputType = {
    id: string | null;
    fieldId: string | null;
    value: string | null;
    label: string | null;
    orderIndex: number | null;
    requiredDocs: string | null;
    showFields: string | null;
    createdAt: Date | null;
  };

  export type ServiceFieldOptionCountAggregateOutputType = {
    id: number;
    fieldId: number;
    value: number;
    label: number;
    orderIndex: number;
    requiredDocs: number;
    showFields: number;
    createdAt: number;
    _all: number;
  };

  export type ServiceFieldOptionAvgAggregateInputType = {
    orderIndex?: true;
  };

  export type ServiceFieldOptionSumAggregateInputType = {
    orderIndex?: true;
  };

  export type ServiceFieldOptionMinAggregateInputType = {
    id?: true;
    fieldId?: true;
    value?: true;
    label?: true;
    orderIndex?: true;
    requiredDocs?: true;
    showFields?: true;
    createdAt?: true;
  };

  export type ServiceFieldOptionMaxAggregateInputType = {
    id?: true;
    fieldId?: true;
    value?: true;
    label?: true;
    orderIndex?: true;
    requiredDocs?: true;
    showFields?: true;
    createdAt?: true;
  };

  export type ServiceFieldOptionCountAggregateInputType = {
    id?: true;
    fieldId?: true;
    value?: true;
    label?: true;
    orderIndex?: true;
    requiredDocs?: true;
    showFields?: true;
    createdAt?: true;
    _all?: true;
  };

  export type ServiceFieldOptionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ServiceFieldOption to aggregate.
     */
    where?: ServiceFieldOptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ServiceFieldOptions to fetch.
     */
    orderBy?:
      | ServiceFieldOptionOrderByWithRelationInput
      | ServiceFieldOptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ServiceFieldOptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ServiceFieldOptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ServiceFieldOptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ServiceFieldOptions
     **/
    _count?: true | ServiceFieldOptionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ServiceFieldOptionAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ServiceFieldOptionSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ServiceFieldOptionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ServiceFieldOptionMaxAggregateInputType;
  };

  export type GetServiceFieldOptionAggregateType<T extends ServiceFieldOptionAggregateArgs> = {
    [P in keyof T & keyof AggregateServiceFieldOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceFieldOption[P]>
      : GetScalarType<T[P], AggregateServiceFieldOption[P]>;
  };

  export type ServiceFieldOptionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ServiceFieldOptionWhereInput;
    orderBy?:
      | ServiceFieldOptionOrderByWithAggregationInput
      | ServiceFieldOptionOrderByWithAggregationInput[];
    by: ServiceFieldOptionScalarFieldEnum[] | ServiceFieldOptionScalarFieldEnum;
    having?: ServiceFieldOptionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ServiceFieldOptionCountAggregateInputType | true;
    _avg?: ServiceFieldOptionAvgAggregateInputType;
    _sum?: ServiceFieldOptionSumAggregateInputType;
    _min?: ServiceFieldOptionMinAggregateInputType;
    _max?: ServiceFieldOptionMaxAggregateInputType;
  };

  export type ServiceFieldOptionGroupByOutputType = {
    id: string;
    fieldId: string;
    value: string;
    label: string;
    orderIndex: number;
    requiredDocs: string | null;
    showFields: string | null;
    createdAt: Date;
    _count: ServiceFieldOptionCountAggregateOutputType | null;
    _avg: ServiceFieldOptionAvgAggregateOutputType | null;
    _sum: ServiceFieldOptionSumAggregateOutputType | null;
    _min: ServiceFieldOptionMinAggregateOutputType | null;
    _max: ServiceFieldOptionMaxAggregateOutputType | null;
  };

  type GetServiceFieldOptionGroupByPayload<T extends ServiceFieldOptionGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ServiceFieldOptionGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ServiceFieldOptionGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceFieldOptionGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceFieldOptionGroupByOutputType[P]>;
        }
      >
    >;

  export type ServiceFieldOptionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      fieldId?: boolean;
      value?: boolean;
      label?: boolean;
      orderIndex?: boolean;
      requiredDocs?: boolean;
      showFields?: boolean;
      createdAt?: boolean;
      field?: boolean | ServiceFieldDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['serviceFieldOption']
  >;

  export type ServiceFieldOptionSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      fieldId?: boolean;
      value?: boolean;
      label?: boolean;
      orderIndex?: boolean;
      requiredDocs?: boolean;
      showFields?: boolean;
      createdAt?: boolean;
      field?: boolean | ServiceFieldDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['serviceFieldOption']
  >;

  export type ServiceFieldOptionSelectScalar = {
    id?: boolean;
    fieldId?: boolean;
    value?: boolean;
    label?: boolean;
    orderIndex?: boolean;
    requiredDocs?: boolean;
    showFields?: boolean;
    createdAt?: boolean;
  };

  export type ServiceFieldOptionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    field?: boolean | ServiceFieldDefaultArgs<ExtArgs>;
  };
  export type ServiceFieldOptionIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    field?: boolean | ServiceFieldDefaultArgs<ExtArgs>;
  };

  export type $ServiceFieldOptionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'ServiceFieldOption';
    objects: {
      field: Prisma.$ServiceFieldPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        fieldId: string;
        value: string;
        label: string;
        orderIndex: number;
        requiredDocs: string | null;
        showFields: string | null;
        createdAt: Date;
      },
      ExtArgs['result']['serviceFieldOption']
    >;
    composites: {};
  };

  type ServiceFieldOptionGetPayload<
    S extends boolean | null | undefined | ServiceFieldOptionDefaultArgs,
  > = $Result.GetResult<Prisma.$ServiceFieldOptionPayload, S>;

  type ServiceFieldOptionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<ServiceFieldOptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
    select?: ServiceFieldOptionCountAggregateInputType | true;
  };

  export interface ServiceFieldOptionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ServiceFieldOption'];
      meta: { name: 'ServiceFieldOption' };
    };
    /**
     * Find zero or one ServiceFieldOption that matches the filter.
     * @param {ServiceFieldOptionFindUniqueArgs} args - Arguments to find a ServiceFieldOption
     * @example
     * // Get one ServiceFieldOption
     * const serviceFieldOption = await prisma.serviceFieldOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFieldOptionFindUniqueArgs>(
      args: SelectSubset<T, ServiceFieldOptionFindUniqueArgs<ExtArgs>>
    ): Prisma__ServiceFieldOptionClient<
      $Result.GetResult<Prisma.$ServiceFieldOptionPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one ServiceFieldOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFieldOptionFindUniqueOrThrowArgs} args - Arguments to find a ServiceFieldOption
     * @example
     * // Get one ServiceFieldOption
     * const serviceFieldOption = await prisma.serviceFieldOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFieldOptionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ServiceFieldOptionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceFieldOptionClient<
      $Result.GetResult<Prisma.$ServiceFieldOptionPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first ServiceFieldOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFieldOptionFindFirstArgs} args - Arguments to find a ServiceFieldOption
     * @example
     * // Get one ServiceFieldOption
     * const serviceFieldOption = await prisma.serviceFieldOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFieldOptionFindFirstArgs>(
      args?: SelectSubset<T, ServiceFieldOptionFindFirstArgs<ExtArgs>>
    ): Prisma__ServiceFieldOptionClient<
      $Result.GetResult<Prisma.$ServiceFieldOptionPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first ServiceFieldOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFieldOptionFindFirstOrThrowArgs} args - Arguments to find a ServiceFieldOption
     * @example
     * // Get one ServiceFieldOption
     * const serviceFieldOption = await prisma.serviceFieldOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFieldOptionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ServiceFieldOptionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceFieldOptionClient<
      $Result.GetResult<Prisma.$ServiceFieldOptionPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more ServiceFieldOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFieldOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceFieldOptions
     * const serviceFieldOptions = await prisma.serviceFieldOption.findMany()
     *
     * // Get first 10 ServiceFieldOptions
     * const serviceFieldOptions = await prisma.serviceFieldOption.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const serviceFieldOptionWithIdOnly = await prisma.serviceFieldOption.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ServiceFieldOptionFindManyArgs>(
      args?: SelectSubset<T, ServiceFieldOptionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ServiceFieldOptionPayload<ExtArgs>, T, 'findMany'>
    >;

    /**
     * Create a ServiceFieldOption.
     * @param {ServiceFieldOptionCreateArgs} args - Arguments to create a ServiceFieldOption.
     * @example
     * // Create one ServiceFieldOption
     * const ServiceFieldOption = await prisma.serviceFieldOption.create({
     *   data: {
     *     // ... data to create a ServiceFieldOption
     *   }
     * })
     *
     */
    create<T extends ServiceFieldOptionCreateArgs>(
      args: SelectSubset<T, ServiceFieldOptionCreateArgs<ExtArgs>>
    ): Prisma__ServiceFieldOptionClient<
      $Result.GetResult<Prisma.$ServiceFieldOptionPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many ServiceFieldOptions.
     * @param {ServiceFieldOptionCreateManyArgs} args - Arguments to create many ServiceFieldOptions.
     * @example
     * // Create many ServiceFieldOptions
     * const serviceFieldOption = await prisma.serviceFieldOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ServiceFieldOptionCreateManyArgs>(
      args?: SelectSubset<T, ServiceFieldOptionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ServiceFieldOptions and returns the data saved in the database.
     * @param {ServiceFieldOptionCreateManyAndReturnArgs} args - Arguments to create many ServiceFieldOptions.
     * @example
     * // Create many ServiceFieldOptions
     * const serviceFieldOption = await prisma.serviceFieldOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ServiceFieldOptions and only return the `id`
     * const serviceFieldOptionWithIdOnly = await prisma.serviceFieldOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ServiceFieldOptionCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ServiceFieldOptionCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ServiceFieldOptionPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a ServiceFieldOption.
     * @param {ServiceFieldOptionDeleteArgs} args - Arguments to delete one ServiceFieldOption.
     * @example
     * // Delete one ServiceFieldOption
     * const ServiceFieldOption = await prisma.serviceFieldOption.delete({
     *   where: {
     *     // ... filter to delete one ServiceFieldOption
     *   }
     * })
     *
     */
    delete<T extends ServiceFieldOptionDeleteArgs>(
      args: SelectSubset<T, ServiceFieldOptionDeleteArgs<ExtArgs>>
    ): Prisma__ServiceFieldOptionClient<
      $Result.GetResult<Prisma.$ServiceFieldOptionPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one ServiceFieldOption.
     * @param {ServiceFieldOptionUpdateArgs} args - Arguments to update one ServiceFieldOption.
     * @example
     * // Update one ServiceFieldOption
     * const serviceFieldOption = await prisma.serviceFieldOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ServiceFieldOptionUpdateArgs>(
      args: SelectSubset<T, ServiceFieldOptionUpdateArgs<ExtArgs>>
    ): Prisma__ServiceFieldOptionClient<
      $Result.GetResult<Prisma.$ServiceFieldOptionPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more ServiceFieldOptions.
     * @param {ServiceFieldOptionDeleteManyArgs} args - Arguments to filter ServiceFieldOptions to delete.
     * @example
     * // Delete a few ServiceFieldOptions
     * const { count } = await prisma.serviceFieldOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ServiceFieldOptionDeleteManyArgs>(
      args?: SelectSubset<T, ServiceFieldOptionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ServiceFieldOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFieldOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceFieldOptions
     * const serviceFieldOption = await prisma.serviceFieldOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ServiceFieldOptionUpdateManyArgs>(
      args: SelectSubset<T, ServiceFieldOptionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one ServiceFieldOption.
     * @param {ServiceFieldOptionUpsertArgs} args - Arguments to update or create a ServiceFieldOption.
     * @example
     * // Update or create a ServiceFieldOption
     * const serviceFieldOption = await prisma.serviceFieldOption.upsert({
     *   create: {
     *     // ... data to create a ServiceFieldOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceFieldOption we want to update
     *   }
     * })
     */
    upsert<T extends ServiceFieldOptionUpsertArgs>(
      args: SelectSubset<T, ServiceFieldOptionUpsertArgs<ExtArgs>>
    ): Prisma__ServiceFieldOptionClient<
      $Result.GetResult<Prisma.$ServiceFieldOptionPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of ServiceFieldOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFieldOptionCountArgs} args - Arguments to filter ServiceFieldOptions to count.
     * @example
     * // Count the number of ServiceFieldOptions
     * const count = await prisma.serviceFieldOption.count({
     *   where: {
     *     // ... the filter for the ServiceFieldOptions we want to count
     *   }
     * })
     **/
    count<T extends ServiceFieldOptionCountArgs>(
      args?: Subset<T, ServiceFieldOptionCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceFieldOptionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ServiceFieldOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFieldOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ServiceFieldOptionAggregateArgs>(
      args: Subset<T, ServiceFieldOptionAggregateArgs>
    ): Prisma.PrismaPromise<GetServiceFieldOptionAggregateType<T>>;

    /**
     * Group by ServiceFieldOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFieldOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ServiceFieldOptionGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceFieldOptionGroupByArgs['orderBy'] }
        : { orderBy?: ServiceFieldOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ServiceFieldOptionGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetServiceFieldOptionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ServiceFieldOption model
     */
    readonly fields: ServiceFieldOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceFieldOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceFieldOptionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    field<T extends ServiceFieldDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ServiceFieldDefaultArgs<ExtArgs>>
    ): Prisma__ServiceFieldClient<
      $Result.GetResult<Prisma.$ServiceFieldPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ServiceFieldOption model
   */
  interface ServiceFieldOptionFieldRefs {
    readonly id: FieldRef<'ServiceFieldOption', 'String'>;
    readonly fieldId: FieldRef<'ServiceFieldOption', 'String'>;
    readonly value: FieldRef<'ServiceFieldOption', 'String'>;
    readonly label: FieldRef<'ServiceFieldOption', 'String'>;
    readonly orderIndex: FieldRef<'ServiceFieldOption', 'Int'>;
    readonly requiredDocs: FieldRef<'ServiceFieldOption', 'String'>;
    readonly showFields: FieldRef<'ServiceFieldOption', 'String'>;
    readonly createdAt: FieldRef<'ServiceFieldOption', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * ServiceFieldOption findUnique
   */
  export type ServiceFieldOptionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceFieldOption
     */
    select?: ServiceFieldOptionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFieldOptionInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceFieldOption to fetch.
     */
    where: ServiceFieldOptionWhereUniqueInput;
  };

  /**
   * ServiceFieldOption findUniqueOrThrow
   */
  export type ServiceFieldOptionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceFieldOption
     */
    select?: ServiceFieldOptionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFieldOptionInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceFieldOption to fetch.
     */
    where: ServiceFieldOptionWhereUniqueInput;
  };

  /**
   * ServiceFieldOption findFirst
   */
  export type ServiceFieldOptionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceFieldOption
     */
    select?: ServiceFieldOptionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFieldOptionInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceFieldOption to fetch.
     */
    where?: ServiceFieldOptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ServiceFieldOptions to fetch.
     */
    orderBy?:
      | ServiceFieldOptionOrderByWithRelationInput
      | ServiceFieldOptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ServiceFieldOptions.
     */
    cursor?: ServiceFieldOptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ServiceFieldOptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ServiceFieldOptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ServiceFieldOptions.
     */
    distinct?: ServiceFieldOptionScalarFieldEnum | ServiceFieldOptionScalarFieldEnum[];
  };

  /**
   * ServiceFieldOption findFirstOrThrow
   */
  export type ServiceFieldOptionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceFieldOption
     */
    select?: ServiceFieldOptionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFieldOptionInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceFieldOption to fetch.
     */
    where?: ServiceFieldOptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ServiceFieldOptions to fetch.
     */
    orderBy?:
      | ServiceFieldOptionOrderByWithRelationInput
      | ServiceFieldOptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ServiceFieldOptions.
     */
    cursor?: ServiceFieldOptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ServiceFieldOptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ServiceFieldOptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ServiceFieldOptions.
     */
    distinct?: ServiceFieldOptionScalarFieldEnum | ServiceFieldOptionScalarFieldEnum[];
  };

  /**
   * ServiceFieldOption findMany
   */
  export type ServiceFieldOptionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceFieldOption
     */
    select?: ServiceFieldOptionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFieldOptionInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceFieldOptions to fetch.
     */
    where?: ServiceFieldOptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ServiceFieldOptions to fetch.
     */
    orderBy?:
      | ServiceFieldOptionOrderByWithRelationInput
      | ServiceFieldOptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ServiceFieldOptions.
     */
    cursor?: ServiceFieldOptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ServiceFieldOptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ServiceFieldOptions.
     */
    skip?: number;
    distinct?: ServiceFieldOptionScalarFieldEnum | ServiceFieldOptionScalarFieldEnum[];
  };

  /**
   * ServiceFieldOption create
   */
  export type ServiceFieldOptionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceFieldOption
     */
    select?: ServiceFieldOptionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFieldOptionInclude<ExtArgs> | null;
    /**
     * The data needed to create a ServiceFieldOption.
     */
    data: XOR<ServiceFieldOptionCreateInput, ServiceFieldOptionUncheckedCreateInput>;
  };

  /**
   * ServiceFieldOption createMany
   */
  export type ServiceFieldOptionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ServiceFieldOptions.
     */
    data: ServiceFieldOptionCreateManyInput | ServiceFieldOptionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ServiceFieldOption createManyAndReturn
   */
  export type ServiceFieldOptionCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceFieldOption
     */
    select?: ServiceFieldOptionSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many ServiceFieldOptions.
     */
    data: ServiceFieldOptionCreateManyInput | ServiceFieldOptionCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFieldOptionIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ServiceFieldOption update
   */
  export type ServiceFieldOptionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceFieldOption
     */
    select?: ServiceFieldOptionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFieldOptionInclude<ExtArgs> | null;
    /**
     * The data needed to update a ServiceFieldOption.
     */
    data: XOR<ServiceFieldOptionUpdateInput, ServiceFieldOptionUncheckedUpdateInput>;
    /**
     * Choose, which ServiceFieldOption to update.
     */
    where: ServiceFieldOptionWhereUniqueInput;
  };

  /**
   * ServiceFieldOption updateMany
   */
  export type ServiceFieldOptionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ServiceFieldOptions.
     */
    data: XOR<
      ServiceFieldOptionUpdateManyMutationInput,
      ServiceFieldOptionUncheckedUpdateManyInput
    >;
    /**
     * Filter which ServiceFieldOptions to update
     */
    where?: ServiceFieldOptionWhereInput;
  };

  /**
   * ServiceFieldOption upsert
   */
  export type ServiceFieldOptionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceFieldOption
     */
    select?: ServiceFieldOptionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFieldOptionInclude<ExtArgs> | null;
    /**
     * The filter to search for the ServiceFieldOption to update in case it exists.
     */
    where: ServiceFieldOptionWhereUniqueInput;
    /**
     * In case the ServiceFieldOption found by the `where` argument doesn't exist, create a new ServiceFieldOption with this data.
     */
    create: XOR<ServiceFieldOptionCreateInput, ServiceFieldOptionUncheckedCreateInput>;
    /**
     * In case the ServiceFieldOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceFieldOptionUpdateInput, ServiceFieldOptionUncheckedUpdateInput>;
  };

  /**
   * ServiceFieldOption delete
   */
  export type ServiceFieldOptionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceFieldOption
     */
    select?: ServiceFieldOptionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFieldOptionInclude<ExtArgs> | null;
    /**
     * Filter which ServiceFieldOption to delete.
     */
    where: ServiceFieldOptionWhereUniqueInput;
  };

  /**
   * ServiceFieldOption deleteMany
   */
  export type ServiceFieldOptionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ServiceFieldOptions to delete
     */
    where?: ServiceFieldOptionWhereInput;
  };

  /**
   * ServiceFieldOption without action
   */
  export type ServiceFieldOptionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceFieldOption
     */
    select?: ServiceFieldOptionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceFieldOptionInclude<ExtArgs> | null;
  };

  /**
   * Model ServiceVariant
   */

  export type AggregateServiceVariant = {
    _count: ServiceVariantCountAggregateOutputType | null;
    _avg: ServiceVariantAvgAggregateOutputType | null;
    _sum: ServiceVariantSumAggregateOutputType | null;
    _min: ServiceVariantMinAggregateOutputType | null;
    _max: ServiceVariantMaxAggregateOutputType | null;
  };

  export type ServiceVariantAvgAggregateOutputType = {
    priceCents: number | null;
    etaDays: number | null;
  };

  export type ServiceVariantSumAggregateOutputType = {
    priceCents: number | null;
    etaDays: number | null;
  };

  export type ServiceVariantMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    priceCents: number | null;
    etaDays: number | null;
    serviceId: string | null;
    active: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ServiceVariantMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    priceCents: number | null;
    etaDays: number | null;
    serviceId: string | null;
    active: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ServiceVariantCountAggregateOutputType = {
    id: number;
    name: number;
    priceCents: number;
    etaDays: number;
    serviceId: number;
    active: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type ServiceVariantAvgAggregateInputType = {
    priceCents?: true;
    etaDays?: true;
  };

  export type ServiceVariantSumAggregateInputType = {
    priceCents?: true;
    etaDays?: true;
  };

  export type ServiceVariantMinAggregateInputType = {
    id?: true;
    name?: true;
    priceCents?: true;
    etaDays?: true;
    serviceId?: true;
    active?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ServiceVariantMaxAggregateInputType = {
    id?: true;
    name?: true;
    priceCents?: true;
    etaDays?: true;
    serviceId?: true;
    active?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ServiceVariantCountAggregateInputType = {
    id?: true;
    name?: true;
    priceCents?: true;
    etaDays?: true;
    serviceId?: true;
    active?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type ServiceVariantAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ServiceVariant to aggregate.
     */
    where?: ServiceVariantWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ServiceVariants to fetch.
     */
    orderBy?: ServiceVariantOrderByWithRelationInput | ServiceVariantOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ServiceVariantWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ServiceVariants from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ServiceVariants.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ServiceVariants
     **/
    _count?: true | ServiceVariantCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ServiceVariantAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ServiceVariantSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ServiceVariantMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ServiceVariantMaxAggregateInputType;
  };

  export type GetServiceVariantAggregateType<T extends ServiceVariantAggregateArgs> = {
    [P in keyof T & keyof AggregateServiceVariant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceVariant[P]>
      : GetScalarType<T[P], AggregateServiceVariant[P]>;
  };

  export type ServiceVariantGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ServiceVariantWhereInput;
    orderBy?:
      | ServiceVariantOrderByWithAggregationInput
      | ServiceVariantOrderByWithAggregationInput[];
    by: ServiceVariantScalarFieldEnum[] | ServiceVariantScalarFieldEnum;
    having?: ServiceVariantScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ServiceVariantCountAggregateInputType | true;
    _avg?: ServiceVariantAvgAggregateInputType;
    _sum?: ServiceVariantSumAggregateInputType;
    _min?: ServiceVariantMinAggregateInputType;
    _max?: ServiceVariantMaxAggregateInputType;
  };

  export type ServiceVariantGroupByOutputType = {
    id: string;
    name: string;
    priceCents: number;
    etaDays: number;
    serviceId: string;
    active: boolean;
    createdAt: Date;
    updatedAt: Date;
    _count: ServiceVariantCountAggregateOutputType | null;
    _avg: ServiceVariantAvgAggregateOutputType | null;
    _sum: ServiceVariantSumAggregateOutputType | null;
    _min: ServiceVariantMinAggregateOutputType | null;
    _max: ServiceVariantMaxAggregateOutputType | null;
  };

  type GetServiceVariantGroupByPayload<T extends ServiceVariantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceVariantGroupByOutputType, T['by']> & {
        [P in keyof T & keyof ServiceVariantGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ServiceVariantGroupByOutputType[P]>
          : GetScalarType<T[P], ServiceVariantGroupByOutputType[P]>;
      }
    >
  >;

  export type ServiceVariantSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      priceCents?: boolean;
      etaDays?: boolean;
      serviceId?: boolean;
      active?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      orders?: boolean | ServiceVariant$ordersArgs<ExtArgs>;
      service?: boolean | ServiceDefaultArgs<ExtArgs>;
      formTypeLinks?: boolean | ServiceVariant$formTypeLinksArgs<ExtArgs>;
      _count?: boolean | ServiceVariantCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['serviceVariant']
  >;

  export type ServiceVariantSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      priceCents?: boolean;
      etaDays?: boolean;
      serviceId?: boolean;
      active?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      service?: boolean | ServiceDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['serviceVariant']
  >;

  export type ServiceVariantSelectScalar = {
    id?: boolean;
    name?: boolean;
    priceCents?: boolean;
    etaDays?: boolean;
    serviceId?: boolean;
    active?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type ServiceVariantInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    orders?: boolean | ServiceVariant$ordersArgs<ExtArgs>;
    service?: boolean | ServiceDefaultArgs<ExtArgs>;
    formTypeLinks?: boolean | ServiceVariant$formTypeLinksArgs<ExtArgs>;
    _count?: boolean | ServiceVariantCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type ServiceVariantIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>;
  };

  export type $ServiceVariantPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'ServiceVariant';
    objects: {
      orders: Prisma.$OrderPayload<ExtArgs>[];
      service: Prisma.$ServicePayload<ExtArgs>;
      formTypeLinks: Prisma.$FormTypeVariantPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        priceCents: number;
        etaDays: number;
        serviceId: string;
        active: boolean;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['serviceVariant']
    >;
    composites: {};
  };

  type ServiceVariantGetPayload<S extends boolean | null | undefined | ServiceVariantDefaultArgs> =
    $Result.GetResult<Prisma.$ServiceVariantPayload, S>;

  type ServiceVariantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceVariantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceVariantCountAggregateInputType | true;
    };

  export interface ServiceVariantDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ServiceVariant'];
      meta: { name: 'ServiceVariant' };
    };
    /**
     * Find zero or one ServiceVariant that matches the filter.
     * @param {ServiceVariantFindUniqueArgs} args - Arguments to find a ServiceVariant
     * @example
     * // Get one ServiceVariant
     * const serviceVariant = await prisma.serviceVariant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceVariantFindUniqueArgs>(
      args: SelectSubset<T, ServiceVariantFindUniqueArgs<ExtArgs>>
    ): Prisma__ServiceVariantClient<
      $Result.GetResult<Prisma.$ServiceVariantPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one ServiceVariant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceVariantFindUniqueOrThrowArgs} args - Arguments to find a ServiceVariant
     * @example
     * // Get one ServiceVariant
     * const serviceVariant = await prisma.serviceVariant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceVariantFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ServiceVariantFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceVariantClient<
      $Result.GetResult<Prisma.$ServiceVariantPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first ServiceVariant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceVariantFindFirstArgs} args - Arguments to find a ServiceVariant
     * @example
     * // Get one ServiceVariant
     * const serviceVariant = await prisma.serviceVariant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceVariantFindFirstArgs>(
      args?: SelectSubset<T, ServiceVariantFindFirstArgs<ExtArgs>>
    ): Prisma__ServiceVariantClient<
      $Result.GetResult<Prisma.$ServiceVariantPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first ServiceVariant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceVariantFindFirstOrThrowArgs} args - Arguments to find a ServiceVariant
     * @example
     * // Get one ServiceVariant
     * const serviceVariant = await prisma.serviceVariant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceVariantFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ServiceVariantFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceVariantClient<
      $Result.GetResult<Prisma.$ServiceVariantPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more ServiceVariants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceVariantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceVariants
     * const serviceVariants = await prisma.serviceVariant.findMany()
     *
     * // Get first 10 ServiceVariants
     * const serviceVariants = await prisma.serviceVariant.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const serviceVariantWithIdOnly = await prisma.serviceVariant.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ServiceVariantFindManyArgs>(
      args?: SelectSubset<T, ServiceVariantFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ServiceVariantPayload<ExtArgs>, T, 'findMany'>
    >;

    /**
     * Create a ServiceVariant.
     * @param {ServiceVariantCreateArgs} args - Arguments to create a ServiceVariant.
     * @example
     * // Create one ServiceVariant
     * const ServiceVariant = await prisma.serviceVariant.create({
     *   data: {
     *     // ... data to create a ServiceVariant
     *   }
     * })
     *
     */
    create<T extends ServiceVariantCreateArgs>(
      args: SelectSubset<T, ServiceVariantCreateArgs<ExtArgs>>
    ): Prisma__ServiceVariantClient<
      $Result.GetResult<Prisma.$ServiceVariantPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many ServiceVariants.
     * @param {ServiceVariantCreateManyArgs} args - Arguments to create many ServiceVariants.
     * @example
     * // Create many ServiceVariants
     * const serviceVariant = await prisma.serviceVariant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ServiceVariantCreateManyArgs>(
      args?: SelectSubset<T, ServiceVariantCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ServiceVariants and returns the data saved in the database.
     * @param {ServiceVariantCreateManyAndReturnArgs} args - Arguments to create many ServiceVariants.
     * @example
     * // Create many ServiceVariants
     * const serviceVariant = await prisma.serviceVariant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ServiceVariants and only return the `id`
     * const serviceVariantWithIdOnly = await prisma.serviceVariant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ServiceVariantCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ServiceVariantCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ServiceVariantPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a ServiceVariant.
     * @param {ServiceVariantDeleteArgs} args - Arguments to delete one ServiceVariant.
     * @example
     * // Delete one ServiceVariant
     * const ServiceVariant = await prisma.serviceVariant.delete({
     *   where: {
     *     // ... filter to delete one ServiceVariant
     *   }
     * })
     *
     */
    delete<T extends ServiceVariantDeleteArgs>(
      args: SelectSubset<T, ServiceVariantDeleteArgs<ExtArgs>>
    ): Prisma__ServiceVariantClient<
      $Result.GetResult<Prisma.$ServiceVariantPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one ServiceVariant.
     * @param {ServiceVariantUpdateArgs} args - Arguments to update one ServiceVariant.
     * @example
     * // Update one ServiceVariant
     * const serviceVariant = await prisma.serviceVariant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ServiceVariantUpdateArgs>(
      args: SelectSubset<T, ServiceVariantUpdateArgs<ExtArgs>>
    ): Prisma__ServiceVariantClient<
      $Result.GetResult<Prisma.$ServiceVariantPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more ServiceVariants.
     * @param {ServiceVariantDeleteManyArgs} args - Arguments to filter ServiceVariants to delete.
     * @example
     * // Delete a few ServiceVariants
     * const { count } = await prisma.serviceVariant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ServiceVariantDeleteManyArgs>(
      args?: SelectSubset<T, ServiceVariantDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ServiceVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceVariantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceVariants
     * const serviceVariant = await prisma.serviceVariant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ServiceVariantUpdateManyArgs>(
      args: SelectSubset<T, ServiceVariantUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one ServiceVariant.
     * @param {ServiceVariantUpsertArgs} args - Arguments to update or create a ServiceVariant.
     * @example
     * // Update or create a ServiceVariant
     * const serviceVariant = await prisma.serviceVariant.upsert({
     *   create: {
     *     // ... data to create a ServiceVariant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceVariant we want to update
     *   }
     * })
     */
    upsert<T extends ServiceVariantUpsertArgs>(
      args: SelectSubset<T, ServiceVariantUpsertArgs<ExtArgs>>
    ): Prisma__ServiceVariantClient<
      $Result.GetResult<Prisma.$ServiceVariantPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of ServiceVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceVariantCountArgs} args - Arguments to filter ServiceVariants to count.
     * @example
     * // Count the number of ServiceVariants
     * const count = await prisma.serviceVariant.count({
     *   where: {
     *     // ... the filter for the ServiceVariants we want to count
     *   }
     * })
     **/
    count<T extends ServiceVariantCountArgs>(
      args?: Subset<T, ServiceVariantCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceVariantCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ServiceVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceVariantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ServiceVariantAggregateArgs>(
      args: Subset<T, ServiceVariantAggregateArgs>
    ): Prisma.PrismaPromise<GetServiceVariantAggregateType<T>>;

    /**
     * Group by ServiceVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceVariantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ServiceVariantGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceVariantGroupByArgs['orderBy'] }
        : { orderBy?: ServiceVariantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ServiceVariantGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetServiceVariantGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ServiceVariant model
     */
    readonly fields: ServiceVariantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceVariant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceVariantClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    orders<T extends ServiceVariant$ordersArgs<ExtArgs> = {}>(
      args?: Subset<T, ServiceVariant$ordersArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findMany'> | Null>;
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ServiceDefaultArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    formTypeLinks<T extends ServiceVariant$formTypeLinksArgs<ExtArgs> = {}>(
      args?: Subset<T, ServiceVariant$formTypeLinksArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$FormTypeVariantPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ServiceVariant model
   */
  interface ServiceVariantFieldRefs {
    readonly id: FieldRef<'ServiceVariant', 'String'>;
    readonly name: FieldRef<'ServiceVariant', 'String'>;
    readonly priceCents: FieldRef<'ServiceVariant', 'Int'>;
    readonly etaDays: FieldRef<'ServiceVariant', 'Int'>;
    readonly serviceId: FieldRef<'ServiceVariant', 'String'>;
    readonly active: FieldRef<'ServiceVariant', 'Boolean'>;
    readonly createdAt: FieldRef<'ServiceVariant', 'DateTime'>;
    readonly updatedAt: FieldRef<'ServiceVariant', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * ServiceVariant findUnique
   */
  export type ServiceVariantFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceVariant to fetch.
     */
    where: ServiceVariantWhereUniqueInput;
  };

  /**
   * ServiceVariant findUniqueOrThrow
   */
  export type ServiceVariantFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceVariant to fetch.
     */
    where: ServiceVariantWhereUniqueInput;
  };

  /**
   * ServiceVariant findFirst
   */
  export type ServiceVariantFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceVariant to fetch.
     */
    where?: ServiceVariantWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ServiceVariants to fetch.
     */
    orderBy?: ServiceVariantOrderByWithRelationInput | ServiceVariantOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ServiceVariants.
     */
    cursor?: ServiceVariantWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ServiceVariants from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ServiceVariants.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ServiceVariants.
     */
    distinct?: ServiceVariantScalarFieldEnum | ServiceVariantScalarFieldEnum[];
  };

  /**
   * ServiceVariant findFirstOrThrow
   */
  export type ServiceVariantFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceVariant to fetch.
     */
    where?: ServiceVariantWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ServiceVariants to fetch.
     */
    orderBy?: ServiceVariantOrderByWithRelationInput | ServiceVariantOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ServiceVariants.
     */
    cursor?: ServiceVariantWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ServiceVariants from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ServiceVariants.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ServiceVariants.
     */
    distinct?: ServiceVariantScalarFieldEnum | ServiceVariantScalarFieldEnum[];
  };

  /**
   * ServiceVariant findMany
   */
  export type ServiceVariantFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceVariants to fetch.
     */
    where?: ServiceVariantWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ServiceVariants to fetch.
     */
    orderBy?: ServiceVariantOrderByWithRelationInput | ServiceVariantOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ServiceVariants.
     */
    cursor?: ServiceVariantWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ServiceVariants from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ServiceVariants.
     */
    skip?: number;
    distinct?: ServiceVariantScalarFieldEnum | ServiceVariantScalarFieldEnum[];
  };

  /**
   * ServiceVariant create
   */
  export type ServiceVariantCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantInclude<ExtArgs> | null;
    /**
     * The data needed to create a ServiceVariant.
     */
    data: XOR<ServiceVariantCreateInput, ServiceVariantUncheckedCreateInput>;
  };

  /**
   * ServiceVariant createMany
   */
  export type ServiceVariantCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ServiceVariants.
     */
    data: ServiceVariantCreateManyInput | ServiceVariantCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ServiceVariant createManyAndReturn
   */
  export type ServiceVariantCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many ServiceVariants.
     */
    data: ServiceVariantCreateManyInput | ServiceVariantCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ServiceVariant update
   */
  export type ServiceVariantUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantInclude<ExtArgs> | null;
    /**
     * The data needed to update a ServiceVariant.
     */
    data: XOR<ServiceVariantUpdateInput, ServiceVariantUncheckedUpdateInput>;
    /**
     * Choose, which ServiceVariant to update.
     */
    where: ServiceVariantWhereUniqueInput;
  };

  /**
   * ServiceVariant updateMany
   */
  export type ServiceVariantUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ServiceVariants.
     */
    data: XOR<ServiceVariantUpdateManyMutationInput, ServiceVariantUncheckedUpdateManyInput>;
    /**
     * Filter which ServiceVariants to update
     */
    where?: ServiceVariantWhereInput;
  };

  /**
   * ServiceVariant upsert
   */
  export type ServiceVariantUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantInclude<ExtArgs> | null;
    /**
     * The filter to search for the ServiceVariant to update in case it exists.
     */
    where: ServiceVariantWhereUniqueInput;
    /**
     * In case the ServiceVariant found by the `where` argument doesn't exist, create a new ServiceVariant with this data.
     */
    create: XOR<ServiceVariantCreateInput, ServiceVariantUncheckedCreateInput>;
    /**
     * In case the ServiceVariant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceVariantUpdateInput, ServiceVariantUncheckedUpdateInput>;
  };

  /**
   * ServiceVariant delete
   */
  export type ServiceVariantDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantInclude<ExtArgs> | null;
    /**
     * Filter which ServiceVariant to delete.
     */
    where: ServiceVariantWhereUniqueInput;
  };

  /**
   * ServiceVariant deleteMany
   */
  export type ServiceVariantDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ServiceVariants to delete
     */
    where?: ServiceVariantWhereInput;
  };

  /**
   * ServiceVariant.orders
   */
  export type ServiceVariant$ordersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    where?: OrderWhereInput;
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[];
    cursor?: OrderWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[];
  };

  /**
   * ServiceVariant.formTypeLinks
   */
  export type ServiceVariant$formTypeLinksArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormTypeVariant
     */
    select?: FormTypeVariantSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTypeVariantInclude<ExtArgs> | null;
    where?: FormTypeVariantWhereInput;
    orderBy?: FormTypeVariantOrderByWithRelationInput | FormTypeVariantOrderByWithRelationInput[];
    cursor?: FormTypeVariantWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: FormTypeVariantScalarFieldEnum | FormTypeVariantScalarFieldEnum[];
  };

  /**
   * ServiceVariant without action
   */
  export type ServiceVariantDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceVariant
     */
    select?: ServiceVariantSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceVariantInclude<ExtArgs> | null;
  };

  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null;
    _avg: OrderAvgAggregateOutputType | null;
    _sum: OrderSumAggregateOutputType | null;
    _min: OrderMinAggregateOutputType | null;
    _max: OrderMaxAggregateOutputType | null;
  };

  export type OrderAvgAggregateOutputType = {
    totalPrice: number | null;
    totalCents: number | null;
    deliveryFee: number | null;
    quantity: number | null;
    otherFees: number | null;
    discount: number | null;
    discountAmount: number | null;
  };

  export type OrderSumAggregateOutputType = {
    totalPrice: number | null;
    totalCents: number | null;
    deliveryFee: number | null;
    quantity: number | null;
    otherFees: number | null;
    discount: number | null;
    discountAmount: number | null;
  };

  export type OrderMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    serviceId: string | null;
    variantId: string | null;
    status: string | null;
    totalPrice: number | null;
    totalCents: number | null;
    customerName: string | null;
    customerPhone: string | null;
    additionalPhone: string | null;
    customerEmail: string | null;
    address: string | null;
    governorate: string | null;
    city: string | null;
    district: string | null;
    street: string | null;
    buildingNumber: string | null;
    apartmentNumber: string | null;
    landmark: string | null;
    notes: string | null;
    adminNotes: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    completedAt: Date | null;
    estimatedCompletionDate: Date | null;
    deliveryFee: number | null;
    deliveryType: string | null;
    createdByAdminId: string | null;
    birthDate: Date | null;
    fatherName: string | null;
    idNumber: string | null;
    motherName: string | null;
    nationality: string | null;
    wifeName: string | null;
    photographyLocation: string | null;
    photographyDate: Date | null;
    marriageDate: Date | null;
    divorceDate: Date | null;
    wifeMotherName: string | null;
    quantity: number | null;
    serviceDetails: string | null;
    otherFees: number | null;
    discount: number | null;
    gender: string | null;
    policeStation: string | null;
    pickupLocation: string | null;
    originalDocuments: string | null;
    attachedDocuments: string | null;
    hasAttachments: boolean | null;
    selectedFines: string | null;
    finesDetails: string | null;
    servicesDetails: string | null;
    customerFollowUp: string | null;
    promoCodeId: string | null;
    discountAmount: number | null;
  };

  export type OrderMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    serviceId: string | null;
    variantId: string | null;
    status: string | null;
    totalPrice: number | null;
    totalCents: number | null;
    customerName: string | null;
    customerPhone: string | null;
    additionalPhone: string | null;
    customerEmail: string | null;
    address: string | null;
    governorate: string | null;
    city: string | null;
    district: string | null;
    street: string | null;
    buildingNumber: string | null;
    apartmentNumber: string | null;
    landmark: string | null;
    notes: string | null;
    adminNotes: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    completedAt: Date | null;
    estimatedCompletionDate: Date | null;
    deliveryFee: number | null;
    deliveryType: string | null;
    createdByAdminId: string | null;
    birthDate: Date | null;
    fatherName: string | null;
    idNumber: string | null;
    motherName: string | null;
    nationality: string | null;
    wifeName: string | null;
    photographyLocation: string | null;
    photographyDate: Date | null;
    marriageDate: Date | null;
    divorceDate: Date | null;
    wifeMotherName: string | null;
    quantity: number | null;
    serviceDetails: string | null;
    otherFees: number | null;
    discount: number | null;
    gender: string | null;
    policeStation: string | null;
    pickupLocation: string | null;
    originalDocuments: string | null;
    attachedDocuments: string | null;
    hasAttachments: boolean | null;
    selectedFines: string | null;
    finesDetails: string | null;
    servicesDetails: string | null;
    customerFollowUp: string | null;
    promoCodeId: string | null;
    discountAmount: number | null;
  };

  export type OrderCountAggregateOutputType = {
    id: number;
    userId: number;
    serviceId: number;
    variantId: number;
    status: number;
    totalPrice: number;
    totalCents: number;
    customerName: number;
    customerPhone: number;
    additionalPhone: number;
    customerEmail: number;
    address: number;
    governorate: number;
    city: number;
    district: number;
    street: number;
    buildingNumber: number;
    apartmentNumber: number;
    landmark: number;
    notes: number;
    adminNotes: number;
    createdAt: number;
    updatedAt: number;
    completedAt: number;
    estimatedCompletionDate: number;
    deliveryFee: number;
    deliveryType: number;
    createdByAdminId: number;
    birthDate: number;
    fatherName: number;
    idNumber: number;
    motherName: number;
    nationality: number;
    wifeName: number;
    photographyLocation: number;
    photographyDate: number;
    marriageDate: number;
    divorceDate: number;
    wifeMotherName: number;
    quantity: number;
    serviceDetails: number;
    otherFees: number;
    discount: number;
    gender: number;
    policeStation: number;
    pickupLocation: number;
    originalDocuments: number;
    attachedDocuments: number;
    hasAttachments: number;
    selectedFines: number;
    finesDetails: number;
    servicesDetails: number;
    customerFollowUp: number;
    promoCodeId: number;
    discountAmount: number;
    _all: number;
  };

  export type OrderAvgAggregateInputType = {
    totalPrice?: true;
    totalCents?: true;
    deliveryFee?: true;
    quantity?: true;
    otherFees?: true;
    discount?: true;
    discountAmount?: true;
  };

  export type OrderSumAggregateInputType = {
    totalPrice?: true;
    totalCents?: true;
    deliveryFee?: true;
    quantity?: true;
    otherFees?: true;
    discount?: true;
    discountAmount?: true;
  };

  export type OrderMinAggregateInputType = {
    id?: true;
    userId?: true;
    serviceId?: true;
    variantId?: true;
    status?: true;
    totalPrice?: true;
    totalCents?: true;
    customerName?: true;
    customerPhone?: true;
    additionalPhone?: true;
    customerEmail?: true;
    address?: true;
    governorate?: true;
    city?: true;
    district?: true;
    street?: true;
    buildingNumber?: true;
    apartmentNumber?: true;
    landmark?: true;
    notes?: true;
    adminNotes?: true;
    createdAt?: true;
    updatedAt?: true;
    completedAt?: true;
    estimatedCompletionDate?: true;
    deliveryFee?: true;
    deliveryType?: true;
    createdByAdminId?: true;
    birthDate?: true;
    fatherName?: true;
    idNumber?: true;
    motherName?: true;
    nationality?: true;
    wifeName?: true;
    photographyLocation?: true;
    photographyDate?: true;
    marriageDate?: true;
    divorceDate?: true;
    wifeMotherName?: true;
    quantity?: true;
    serviceDetails?: true;
    otherFees?: true;
    discount?: true;
    gender?: true;
    policeStation?: true;
    pickupLocation?: true;
    originalDocuments?: true;
    attachedDocuments?: true;
    hasAttachments?: true;
    selectedFines?: true;
    finesDetails?: true;
    servicesDetails?: true;
    customerFollowUp?: true;
    promoCodeId?: true;
    discountAmount?: true;
  };

  export type OrderMaxAggregateInputType = {
    id?: true;
    userId?: true;
    serviceId?: true;
    variantId?: true;
    status?: true;
    totalPrice?: true;
    totalCents?: true;
    customerName?: true;
    customerPhone?: true;
    additionalPhone?: true;
    customerEmail?: true;
    address?: true;
    governorate?: true;
    city?: true;
    district?: true;
    street?: true;
    buildingNumber?: true;
    apartmentNumber?: true;
    landmark?: true;
    notes?: true;
    adminNotes?: true;
    createdAt?: true;
    updatedAt?: true;
    completedAt?: true;
    estimatedCompletionDate?: true;
    deliveryFee?: true;
    deliveryType?: true;
    createdByAdminId?: true;
    birthDate?: true;
    fatherName?: true;
    idNumber?: true;
    motherName?: true;
    nationality?: true;
    wifeName?: true;
    photographyLocation?: true;
    photographyDate?: true;
    marriageDate?: true;
    divorceDate?: true;
    wifeMotherName?: true;
    quantity?: true;
    serviceDetails?: true;
    otherFees?: true;
    discount?: true;
    gender?: true;
    policeStation?: true;
    pickupLocation?: true;
    originalDocuments?: true;
    attachedDocuments?: true;
    hasAttachments?: true;
    selectedFines?: true;
    finesDetails?: true;
    servicesDetails?: true;
    customerFollowUp?: true;
    promoCodeId?: true;
    discountAmount?: true;
  };

  export type OrderCountAggregateInputType = {
    id?: true;
    userId?: true;
    serviceId?: true;
    variantId?: true;
    status?: true;
    totalPrice?: true;
    totalCents?: true;
    customerName?: true;
    customerPhone?: true;
    additionalPhone?: true;
    customerEmail?: true;
    address?: true;
    governorate?: true;
    city?: true;
    district?: true;
    street?: true;
    buildingNumber?: true;
    apartmentNumber?: true;
    landmark?: true;
    notes?: true;
    adminNotes?: true;
    createdAt?: true;
    updatedAt?: true;
    completedAt?: true;
    estimatedCompletionDate?: true;
    deliveryFee?: true;
    deliveryType?: true;
    createdByAdminId?: true;
    birthDate?: true;
    fatherName?: true;
    idNumber?: true;
    motherName?: true;
    nationality?: true;
    wifeName?: true;
    photographyLocation?: true;
    photographyDate?: true;
    marriageDate?: true;
    divorceDate?: true;
    wifeMotherName?: true;
    quantity?: true;
    serviceDetails?: true;
    otherFees?: true;
    discount?: true;
    gender?: true;
    policeStation?: true;
    pickupLocation?: true;
    originalDocuments?: true;
    attachedDocuments?: true;
    hasAttachments?: true;
    selectedFines?: true;
    finesDetails?: true;
    servicesDetails?: true;
    customerFollowUp?: true;
    promoCodeId?: true;
    discountAmount?: true;
    _all?: true;
  };

  export type OrderAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Orders.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Orders
     **/
    _count?: true | OrderCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: OrderAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: OrderSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: OrderMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: OrderMaxAggregateInputType;
  };

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
    [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>;
  };

  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      where?: OrderWhereInput;
      orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[];
      by: OrderScalarFieldEnum[] | OrderScalarFieldEnum;
      having?: OrderScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: OrderCountAggregateInputType | true;
      _avg?: OrderAvgAggregateInputType;
      _sum?: OrderSumAggregateInputType;
      _min?: OrderMinAggregateInputType;
      _max?: OrderMaxAggregateInputType;
    };

  export type OrderGroupByOutputType = {
    id: string;
    userId: string;
    serviceId: string;
    variantId: string;
    status: string;
    totalPrice: number;
    totalCents: number;
    customerName: string;
    customerPhone: string;
    additionalPhone: string | null;
    customerEmail: string;
    address: string | null;
    governorate: string | null;
    city: string | null;
    district: string | null;
    street: string | null;
    buildingNumber: string | null;
    apartmentNumber: string | null;
    landmark: string | null;
    notes: string | null;
    adminNotes: string | null;
    createdAt: Date;
    updatedAt: Date;
    completedAt: Date | null;
    estimatedCompletionDate: Date | null;
    deliveryFee: number;
    deliveryType: string;
    createdByAdminId: string | null;
    birthDate: Date | null;
    fatherName: string | null;
    idNumber: string | null;
    motherName: string | null;
    nationality: string | null;
    wifeName: string | null;
    photographyLocation: string | null;
    photographyDate: Date | null;
    marriageDate: Date | null;
    divorceDate: Date | null;
    wifeMotherName: string | null;
    quantity: number;
    serviceDetails: string | null;
    otherFees: number;
    discount: number;
    gender: string | null;
    policeStation: string | null;
    pickupLocation: string | null;
    originalDocuments: string | null;
    attachedDocuments: string | null;
    hasAttachments: boolean;
    selectedFines: string | null;
    finesDetails: string | null;
    servicesDetails: string | null;
    customerFollowUp: string | null;
    promoCodeId: string | null;
    discountAmount: number;
    _count: OrderCountAggregateOutputType | null;
    _avg: OrderAvgAggregateOutputType | null;
    _sum: OrderSumAggregateOutputType | null;
    _min: OrderMinAggregateOutputType | null;
    _max: OrderMaxAggregateOutputType | null;
  };

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> & {
        [P in keyof T & keyof OrderGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
          : GetScalarType<T[P], OrderGroupByOutputType[P]>;
      }
    >
  >;

  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        userId?: boolean;
        serviceId?: boolean;
        variantId?: boolean;
        status?: boolean;
        totalPrice?: boolean;
        totalCents?: boolean;
        customerName?: boolean;
        customerPhone?: boolean;
        additionalPhone?: boolean;
        customerEmail?: boolean;
        address?: boolean;
        governorate?: boolean;
        city?: boolean;
        district?: boolean;
        street?: boolean;
        buildingNumber?: boolean;
        apartmentNumber?: boolean;
        landmark?: boolean;
        notes?: boolean;
        adminNotes?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        completedAt?: boolean;
        estimatedCompletionDate?: boolean;
        deliveryFee?: boolean;
        deliveryType?: boolean;
        createdByAdminId?: boolean;
        birthDate?: boolean;
        fatherName?: boolean;
        idNumber?: boolean;
        motherName?: boolean;
        nationality?: boolean;
        wifeName?: boolean;
        photographyLocation?: boolean;
        photographyDate?: boolean;
        marriageDate?: boolean;
        divorceDate?: boolean;
        wifeMotherName?: boolean;
        quantity?: boolean;
        serviceDetails?: boolean;
        otherFees?: boolean;
        discount?: boolean;
        gender?: boolean;
        policeStation?: boolean;
        pickupLocation?: boolean;
        originalDocuments?: boolean;
        attachedDocuments?: boolean;
        hasAttachments?: boolean;
        selectedFines?: boolean;
        finesDetails?: boolean;
        servicesDetails?: boolean;
        customerFollowUp?: boolean;
        promoCodeId?: boolean;
        discountAmount?: boolean;
        createdByAdmin?: boolean | Order$createdByAdminArgs<ExtArgs>;
        documents?: boolean | Order$documentsArgs<ExtArgs>;
        service?: boolean | ServiceDefaultArgs<ExtArgs>;
        user?: boolean | UserDefaultArgs<ExtArgs>;
        variant?: boolean | ServiceVariantDefaultArgs<ExtArgs>;
        orderDocuments?: boolean | Order$orderDocumentsArgs<ExtArgs>;
        payment?: boolean | Order$paymentArgs<ExtArgs>;
        formSerials?: boolean | Order$formSerialsArgs<ExtArgs>;
        promoCode?: boolean | Order$promoCodeArgs<ExtArgs>;
        _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['order']
    >;

  export type OrderSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      serviceId?: boolean;
      variantId?: boolean;
      status?: boolean;
      totalPrice?: boolean;
      totalCents?: boolean;
      customerName?: boolean;
      customerPhone?: boolean;
      additionalPhone?: boolean;
      customerEmail?: boolean;
      address?: boolean;
      governorate?: boolean;
      city?: boolean;
      district?: boolean;
      street?: boolean;
      buildingNumber?: boolean;
      apartmentNumber?: boolean;
      landmark?: boolean;
      notes?: boolean;
      adminNotes?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      completedAt?: boolean;
      estimatedCompletionDate?: boolean;
      deliveryFee?: boolean;
      deliveryType?: boolean;
      createdByAdminId?: boolean;
      birthDate?: boolean;
      fatherName?: boolean;
      idNumber?: boolean;
      motherName?: boolean;
      nationality?: boolean;
      wifeName?: boolean;
      photographyLocation?: boolean;
      photographyDate?: boolean;
      marriageDate?: boolean;
      divorceDate?: boolean;
      wifeMotherName?: boolean;
      quantity?: boolean;
      serviceDetails?: boolean;
      otherFees?: boolean;
      discount?: boolean;
      gender?: boolean;
      policeStation?: boolean;
      pickupLocation?: boolean;
      originalDocuments?: boolean;
      attachedDocuments?: boolean;
      hasAttachments?: boolean;
      selectedFines?: boolean;
      finesDetails?: boolean;
      servicesDetails?: boolean;
      customerFollowUp?: boolean;
      promoCodeId?: boolean;
      discountAmount?: boolean;
      createdByAdmin?: boolean | Order$createdByAdminArgs<ExtArgs>;
      service?: boolean | ServiceDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      variant?: boolean | ServiceVariantDefaultArgs<ExtArgs>;
      promoCode?: boolean | Order$promoCodeArgs<ExtArgs>;
    },
    ExtArgs['result']['order']
  >;

  export type OrderSelectScalar = {
    id?: boolean;
    userId?: boolean;
    serviceId?: boolean;
    variantId?: boolean;
    status?: boolean;
    totalPrice?: boolean;
    totalCents?: boolean;
    customerName?: boolean;
    customerPhone?: boolean;
    additionalPhone?: boolean;
    customerEmail?: boolean;
    address?: boolean;
    governorate?: boolean;
    city?: boolean;
    district?: boolean;
    street?: boolean;
    buildingNumber?: boolean;
    apartmentNumber?: boolean;
    landmark?: boolean;
    notes?: boolean;
    adminNotes?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    completedAt?: boolean;
    estimatedCompletionDate?: boolean;
    deliveryFee?: boolean;
    deliveryType?: boolean;
    createdByAdminId?: boolean;
    birthDate?: boolean;
    fatherName?: boolean;
    idNumber?: boolean;
    motherName?: boolean;
    nationality?: boolean;
    wifeName?: boolean;
    photographyLocation?: boolean;
    photographyDate?: boolean;
    marriageDate?: boolean;
    divorceDate?: boolean;
    wifeMotherName?: boolean;
    quantity?: boolean;
    serviceDetails?: boolean;
    otherFees?: boolean;
    discount?: boolean;
    gender?: boolean;
    policeStation?: boolean;
    pickupLocation?: boolean;
    originalDocuments?: boolean;
    attachedDocuments?: boolean;
    hasAttachments?: boolean;
    selectedFines?: boolean;
    finesDetails?: boolean;
    servicesDetails?: boolean;
    customerFollowUp?: boolean;
    promoCodeId?: boolean;
    discountAmount?: boolean;
  };

  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByAdmin?: boolean | Order$createdByAdminArgs<ExtArgs>;
    documents?: boolean | Order$documentsArgs<ExtArgs>;
    service?: boolean | ServiceDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
    variant?: boolean | ServiceVariantDefaultArgs<ExtArgs>;
    orderDocuments?: boolean | Order$orderDocumentsArgs<ExtArgs>;
    payment?: boolean | Order$paymentArgs<ExtArgs>;
    formSerials?: boolean | Order$formSerialsArgs<ExtArgs>;
    promoCode?: boolean | Order$promoCodeArgs<ExtArgs>;
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type OrderIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    createdByAdmin?: boolean | Order$createdByAdminArgs<ExtArgs>;
    service?: boolean | ServiceDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
    variant?: boolean | ServiceVariantDefaultArgs<ExtArgs>;
    promoCode?: boolean | Order$promoCodeArgs<ExtArgs>;
  };

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: 'Order';
    objects: {
      createdByAdmin: Prisma.$UserPayload<ExtArgs> | null;
      documents: Prisma.$DocumentPayload<ExtArgs>[];
      service: Prisma.$ServicePayload<ExtArgs>;
      user: Prisma.$UserPayload<ExtArgs>;
      variant: Prisma.$ServiceVariantPayload<ExtArgs>;
      orderDocuments: Prisma.$OrderDocumentPayload<ExtArgs>[];
      payment: Prisma.$PaymentPayload<ExtArgs> | null;
      formSerials: Prisma.$FormSerialPayload<ExtArgs>[];
      promoCode: Prisma.$PromoCodePayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        serviceId: string;
        variantId: string;
        status: string;
        totalPrice: number;
        totalCents: number;
        customerName: string;
        customerPhone: string;
        additionalPhone: string | null;
        customerEmail: string;
        address: string | null;
        governorate: string | null;
        city: string | null;
        district: string | null;
        street: string | null;
        buildingNumber: string | null;
        apartmentNumber: string | null;
        landmark: string | null;
        notes: string | null;
        adminNotes: string | null;
        createdAt: Date;
        updatedAt: Date;
        completedAt: Date | null;
        estimatedCompletionDate: Date | null;
        deliveryFee: number;
        deliveryType: string;
        createdByAdminId: string | null;
        birthDate: Date | null;
        fatherName: string | null;
        idNumber: string | null;
        motherName: string | null;
        nationality: string | null;
        wifeName: string | null;
        photographyLocation: string | null;
        photographyDate: Date | null;
        marriageDate: Date | null;
        divorceDate: Date | null;
        wifeMotherName: string | null;
        quantity: number;
        serviceDetails: string | null;
        otherFees: number;
        discount: number;
        gender: string | null;
        policeStation: string | null;
        pickupLocation: string | null;
        originalDocuments: string | null;
        attachedDocuments: string | null;
        hasAttachments: boolean;
        selectedFines: string | null;
        finesDetails: string | null;
        servicesDetails: string | null;
        customerFollowUp: string | null;
        promoCodeId: string | null;
        discountAmount: number;
      },
      ExtArgs['result']['order']
    >;
    composites: {};
  };

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<
    Prisma.$OrderPayload,
    S
  >;

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    OrderFindManyArgs,
    'select' | 'include' | 'distinct'
  > & {
    select?: OrderCountAggregateInputType | true;
  };

  export interface OrderDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order']; meta: { name: 'Order' } };
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(
      args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>
    ): Prisma__OrderClient<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(
      args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrderClient<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(
      args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>
    ): Prisma__OrderClient<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrderClient<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     *
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     *
     */
    findMany<T extends OrderFindManyArgs>(
      args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     *
     */
    create<T extends OrderCreateArgs>(
      args: SelectSubset<T, OrderCreateArgs<ExtArgs>>
    ): Prisma__OrderClient<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends OrderCreateManyArgs>(
      args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(
      args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     *
     */
    delete<T extends OrderDeleteArgs>(
      args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>
    ): Prisma__OrderClient<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends OrderUpdateArgs>(
      args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>
    ): Prisma__OrderClient<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends OrderDeleteManyArgs>(
      args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends OrderUpdateManyArgs>(
      args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(
      args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>
    ): Prisma__OrderClient<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
     **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends OrderAggregateArgs>(
      args: Subset<T, OrderAggregateArgs>
    ): Prisma.PrismaPromise<GetOrderAggregateType<T>>;

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Order model
     */
    readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    createdByAdmin<T extends Order$createdByAdminArgs<ExtArgs> = {}>(
      args?: Subset<T, Order$createdByAdminArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null,
      null,
      ExtArgs
    >;
    documents<T extends Order$documentsArgs<ExtArgs> = {}>(
      args?: Subset<T, Order$documentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ServiceDefaultArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    variant<T extends ServiceVariantDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ServiceVariantDefaultArgs<ExtArgs>>
    ): Prisma__ServiceVariantClient<
      $Result.GetResult<Prisma.$ServiceVariantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    orderDocuments<T extends Order$orderDocumentsArgs<ExtArgs> = {}>(
      args?: Subset<T, Order$orderDocumentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$OrderDocumentPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    payment<T extends Order$paymentArgs<ExtArgs> = {}>(
      args?: Subset<T, Order$paymentArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null,
      null,
      ExtArgs
    >;
    formSerials<T extends Order$formSerialsArgs<ExtArgs> = {}>(
      args?: Subset<T, Order$formSerialsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$FormSerialPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    promoCode<T extends Order$promoCodeArgs<ExtArgs> = {}>(
      args?: Subset<T, Order$promoCodeArgs<ExtArgs>>
    ): Prisma__PromoCodeClient<
      $Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null,
      null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<'Order', 'String'>;
    readonly userId: FieldRef<'Order', 'String'>;
    readonly serviceId: FieldRef<'Order', 'String'>;
    readonly variantId: FieldRef<'Order', 'String'>;
    readonly status: FieldRef<'Order', 'String'>;
    readonly totalPrice: FieldRef<'Order', 'Int'>;
    readonly totalCents: FieldRef<'Order', 'Int'>;
    readonly customerName: FieldRef<'Order', 'String'>;
    readonly customerPhone: FieldRef<'Order', 'String'>;
    readonly additionalPhone: FieldRef<'Order', 'String'>;
    readonly customerEmail: FieldRef<'Order', 'String'>;
    readonly address: FieldRef<'Order', 'String'>;
    readonly governorate: FieldRef<'Order', 'String'>;
    readonly city: FieldRef<'Order', 'String'>;
    readonly district: FieldRef<'Order', 'String'>;
    readonly street: FieldRef<'Order', 'String'>;
    readonly buildingNumber: FieldRef<'Order', 'String'>;
    readonly apartmentNumber: FieldRef<'Order', 'String'>;
    readonly landmark: FieldRef<'Order', 'String'>;
    readonly notes: FieldRef<'Order', 'String'>;
    readonly adminNotes: FieldRef<'Order', 'String'>;
    readonly createdAt: FieldRef<'Order', 'DateTime'>;
    readonly updatedAt: FieldRef<'Order', 'DateTime'>;
    readonly completedAt: FieldRef<'Order', 'DateTime'>;
    readonly estimatedCompletionDate: FieldRef<'Order', 'DateTime'>;
    readonly deliveryFee: FieldRef<'Order', 'Int'>;
    readonly deliveryType: FieldRef<'Order', 'String'>;
    readonly createdByAdminId: FieldRef<'Order', 'String'>;
    readonly birthDate: FieldRef<'Order', 'DateTime'>;
    readonly fatherName: FieldRef<'Order', 'String'>;
    readonly idNumber: FieldRef<'Order', 'String'>;
    readonly motherName: FieldRef<'Order', 'String'>;
    readonly nationality: FieldRef<'Order', 'String'>;
    readonly wifeName: FieldRef<'Order', 'String'>;
    readonly photographyLocation: FieldRef<'Order', 'String'>;
    readonly photographyDate: FieldRef<'Order', 'DateTime'>;
    readonly marriageDate: FieldRef<'Order', 'DateTime'>;
    readonly divorceDate: FieldRef<'Order', 'DateTime'>;
    readonly wifeMotherName: FieldRef<'Order', 'String'>;
    readonly quantity: FieldRef<'Order', 'Int'>;
    readonly serviceDetails: FieldRef<'Order', 'String'>;
    readonly otherFees: FieldRef<'Order', 'Int'>;
    readonly discount: FieldRef<'Order', 'Int'>;
    readonly gender: FieldRef<'Order', 'String'>;
    readonly policeStation: FieldRef<'Order', 'String'>;
    readonly pickupLocation: FieldRef<'Order', 'String'>;
    readonly originalDocuments: FieldRef<'Order', 'String'>;
    readonly attachedDocuments: FieldRef<'Order', 'String'>;
    readonly hasAttachments: FieldRef<'Order', 'Boolean'>;
    readonly selectedFines: FieldRef<'Order', 'String'>;
    readonly finesDetails: FieldRef<'Order', 'String'>;
    readonly servicesDetails: FieldRef<'Order', 'String'>;
    readonly customerFollowUp: FieldRef<'Order', 'String'>;
    readonly promoCodeId: FieldRef<'Order', 'String'>;
    readonly discountAmount: FieldRef<'Order', 'Int'>;
  }

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput;
  };

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput;
  };

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Orders.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[];
  };

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Orders.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[];
  };

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Orders.
     */
    skip?: number;
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[];
  };

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Order
       */
      select?: OrderSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: OrderInclude<ExtArgs> | null;
      /**
       * The data needed to create a Order.
       */
      data: XOR<OrderCreateInput, OrderUncheckedCreateInput>;
    };

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Order
       */
      select?: OrderSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: OrderInclude<ExtArgs> | null;
      /**
       * The data needed to update a Order.
       */
      data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>;
      /**
       * Choose, which Order to update.
       */
      where: OrderWhereUniqueInput;
    };

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>;
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput;
  };

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Order
       */
      select?: OrderSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: OrderInclude<ExtArgs> | null;
      /**
       * The filter to search for the Order to update in case it exists.
       */
      where: OrderWhereUniqueInput;
      /**
       * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
       */
      create: XOR<OrderCreateInput, OrderUncheckedCreateInput>;
      /**
       * In case the Order was found with the provided `where` argument, update it with this data.
       */
      update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>;
    };

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Order
       */
      select?: OrderSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: OrderInclude<ExtArgs> | null;
      /**
       * Filter which Order to delete.
       */
      where: OrderWhereUniqueInput;
    };

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput;
  };

  /**
   * Order.createdByAdmin
   */
  export type Order$createdByAdminArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * Order.documents
   */
  export type Order$documentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    where?: DocumentWhereInput;
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[];
    cursor?: DocumentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[];
  };

  /**
   * Order.orderDocuments
   */
  export type Order$orderDocumentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderDocument
     */
    select?: OrderDocumentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDocumentInclude<ExtArgs> | null;
    where?: OrderDocumentWhereInput;
    orderBy?: OrderDocumentOrderByWithRelationInput | OrderDocumentOrderByWithRelationInput[];
    cursor?: OrderDocumentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: OrderDocumentScalarFieldEnum | OrderDocumentScalarFieldEnum[];
  };

  /**
   * Order.payment
   */
  export type Order$paymentArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    where?: PaymentWhereInput;
  };

  /**
   * Order.formSerials
   */
  export type Order$formSerialsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormSerial
     */
    select?: FormSerialSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSerialInclude<ExtArgs> | null;
    where?: FormSerialWhereInput;
    orderBy?: FormSerialOrderByWithRelationInput | FormSerialOrderByWithRelationInput[];
    cursor?: FormSerialWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: FormSerialScalarFieldEnum | FormSerialScalarFieldEnum[];
  };

  /**
   * Order.promoCode
   */
  export type Order$promoCodeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null;
    where?: PromoCodeWhereInput;
  };

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Order
       */
      select?: OrderSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: OrderInclude<ExtArgs> | null;
    };

  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null;
    _avg: PaymentAvgAggregateOutputType | null;
    _sum: PaymentSumAggregateOutputType | null;
    _min: PaymentMinAggregateOutputType | null;
    _max: PaymentMaxAggregateOutputType | null;
  };

  export type PaymentAvgAggregateOutputType = {
    amount: number | null;
  };

  export type PaymentSumAggregateOutputType = {
    amount: number | null;
  };

  export type PaymentMinAggregateOutputType = {
    id: string | null;
    orderId: string | null;
    amount: number | null;
    currency: string | null;
    method: string | null;
    status: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    paymentScreenshot: string | null;
    senderPhone: string | null;
    notes: string | null;
  };

  export type PaymentMaxAggregateOutputType = {
    id: string | null;
    orderId: string | null;
    amount: number | null;
    currency: string | null;
    method: string | null;
    status: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    paymentScreenshot: string | null;
    senderPhone: string | null;
    notes: string | null;
  };

  export type PaymentCountAggregateOutputType = {
    id: number;
    orderId: number;
    amount: number;
    currency: number;
    method: number;
    status: number;
    createdAt: number;
    updatedAt: number;
    paymentScreenshot: number;
    senderPhone: number;
    notes: number;
    _all: number;
  };

  export type PaymentAvgAggregateInputType = {
    amount?: true;
  };

  export type PaymentSumAggregateInputType = {
    amount?: true;
  };

  export type PaymentMinAggregateInputType = {
    id?: true;
    orderId?: true;
    amount?: true;
    currency?: true;
    method?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
    paymentScreenshot?: true;
    senderPhone?: true;
    notes?: true;
  };

  export type PaymentMaxAggregateInputType = {
    id?: true;
    orderId?: true;
    amount?: true;
    currency?: true;
    method?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
    paymentScreenshot?: true;
    senderPhone?: true;
    notes?: true;
  };

  export type PaymentCountAggregateInputType = {
    id?: true;
    orderId?: true;
    amount?: true;
    currency?: true;
    method?: true;
    status?: true;
    createdAt?: true;
    updatedAt?: true;
    paymentScreenshot?: true;
    senderPhone?: true;
    notes?: true;
    _all?: true;
  };

  export type PaymentAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Payments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Payments
     **/
    _count?: true | PaymentCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: PaymentAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: PaymentSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PaymentMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PaymentMaxAggregateInputType;
  };

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
    [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>;
  };

  export type PaymentGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[];
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum;
    having?: PaymentScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PaymentCountAggregateInputType | true;
    _avg?: PaymentAvgAggregateInputType;
    _sum?: PaymentSumAggregateInputType;
    _min?: PaymentMinAggregateInputType;
    _max?: PaymentMaxAggregateInputType;
  };

  export type PaymentGroupByOutputType = {
    id: string;
    orderId: string;
    amount: number;
    currency: string;
    method: string;
    status: string;
    createdAt: Date;
    updatedAt: Date;
    paymentScreenshot: string | null;
    senderPhone: string | null;
    notes: string | null;
    _count: PaymentCountAggregateOutputType | null;
    _avg: PaymentAvgAggregateOutputType | null;
    _sum: PaymentSumAggregateOutputType | null;
    _min: PaymentMinAggregateOutputType | null;
    _max: PaymentMaxAggregateOutputType | null;
  };

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> & {
        [P in keyof T & keyof PaymentGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
          : GetScalarType<T[P], PaymentGroupByOutputType[P]>;
      }
    >
  >;

  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        orderId?: boolean;
        amount?: boolean;
        currency?: boolean;
        method?: boolean;
        status?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        paymentScreenshot?: boolean;
        senderPhone?: boolean;
        notes?: boolean;
        order?: boolean | OrderDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['payment']
    >;

  export type PaymentSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      orderId?: boolean;
      amount?: boolean;
      currency?: boolean;
      method?: boolean;
      status?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      paymentScreenshot?: boolean;
      senderPhone?: boolean;
      notes?: boolean;
      order?: boolean | OrderDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['payment']
  >;

  export type PaymentSelectScalar = {
    id?: boolean;
    orderId?: boolean;
    amount?: boolean;
    currency?: boolean;
    method?: boolean;
    status?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    paymentScreenshot?: boolean;
    senderPhone?: boolean;
    notes?: boolean;
  };

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>;
  };
  export type PaymentIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    order?: boolean | OrderDefaultArgs<ExtArgs>;
  };

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Payment';
      objects: {
        order: Prisma.$OrderPayload<ExtArgs>;
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          orderId: string;
          amount: number;
          currency: string;
          method: string;
          status: string;
          createdAt: Date;
          updatedAt: Date;
          paymentScreenshot: string | null;
          senderPhone: string | null;
          notes: string | null;
        },
        ExtArgs['result']['payment']
      >;
      composites: {};
    };

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> =
    $Result.GetResult<Prisma.$PaymentPayload, S>;

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    PaymentFindManyArgs,
    'select' | 'include' | 'distinct'
  > & {
    select?: PaymentCountAggregateInputType | true;
  };

  export interface PaymentDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment']; meta: { name: 'Payment' } };
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(
      args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(
      args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(
      args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     *
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PaymentFindManyArgs>(
      args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     *
     */
    create<T extends PaymentCreateArgs>(
      args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PaymentCreateManyArgs>(
      args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(
      args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     *
     */
    delete<T extends PaymentDeleteArgs>(
      args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PaymentUpdateArgs>(
      args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PaymentDeleteManyArgs>(
      args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PaymentUpdateManyArgs>(
      args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(
      args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
     **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PaymentAggregateArgs>(
      args: Subset<T, PaymentAggregateArgs>
    ): Prisma.PrismaPromise<GetPaymentAggregateType<T>>;

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Payment model
     */
    readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrderDefaultArgs<ExtArgs>>
    ): Prisma__OrderClient<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<'Payment', 'String'>;
    readonly orderId: FieldRef<'Payment', 'String'>;
    readonly amount: FieldRef<'Payment', 'Int'>;
    readonly currency: FieldRef<'Payment', 'String'>;
    readonly method: FieldRef<'Payment', 'String'>;
    readonly status: FieldRef<'Payment', 'String'>;
    readonly createdAt: FieldRef<'Payment', 'DateTime'>;
    readonly updatedAt: FieldRef<'Payment', 'DateTime'>;
    readonly paymentScreenshot: FieldRef<'Payment', 'String'>;
    readonly senderPhone: FieldRef<'Payment', 'String'>;
    readonly notes: FieldRef<'Payment', 'String'>;
  }

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput;
  };

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput;
  };

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Payments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[];
  };

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Payments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[];
  };

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Payments.
     */
    skip?: number;
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[];
  };

  /**
   * Payment create
   */
  export type PaymentCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>;
  };

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>;
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput;
  };

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>;
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput;
  };

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput;
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>;
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>;
  };

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput;
  };

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput;
  };

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
  };

  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null;
    _min: AuditLogMinAggregateOutputType | null;
    _max: AuditLogMaxAggregateOutputType | null;
  };

  export type AuditLogMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    action: string | null;
    entityType: string | null;
    entityId: string | null;
    oldValues: string | null;
    newValues: string | null;
    ipAddress: string | null;
    userAgent: string | null;
    createdAt: Date | null;
  };

  export type AuditLogMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    action: string | null;
    entityType: string | null;
    entityId: string | null;
    oldValues: string | null;
    newValues: string | null;
    ipAddress: string | null;
    userAgent: string | null;
    createdAt: Date | null;
  };

  export type AuditLogCountAggregateOutputType = {
    id: number;
    userId: number;
    action: number;
    entityType: number;
    entityId: number;
    oldValues: number;
    newValues: number;
    ipAddress: number;
    userAgent: number;
    createdAt: number;
    _all: number;
  };

  export type AuditLogMinAggregateInputType = {
    id?: true;
    userId?: true;
    action?: true;
    entityType?: true;
    entityId?: true;
    oldValues?: true;
    newValues?: true;
    ipAddress?: true;
    userAgent?: true;
    createdAt?: true;
  };

  export type AuditLogMaxAggregateInputType = {
    id?: true;
    userId?: true;
    action?: true;
    entityType?: true;
    entityId?: true;
    oldValues?: true;
    newValues?: true;
    ipAddress?: true;
    userAgent?: true;
    createdAt?: true;
  };

  export type AuditLogCountAggregateInputType = {
    id?: true;
    userId?: true;
    action?: true;
    entityType?: true;
    entityId?: true;
    oldValues?: true;
    newValues?: true;
    ipAddress?: true;
    userAgent?: true;
    createdAt?: true;
    _all?: true;
  };

  export type AuditLogAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned AuditLogs
     **/
    _count?: true | AuditLogCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AuditLogMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AuditLogMaxAggregateInputType;
  };

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
    [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>;
  };

  export type AuditLogGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AuditLogWhereInput;
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[];
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum;
    having?: AuditLogScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AuditLogCountAggregateInputType | true;
    _min?: AuditLogMinAggregateInputType;
    _max?: AuditLogMaxAggregateInputType;
  };

  export type AuditLogGroupByOutputType = {
    id: string;
    userId: string | null;
    action: string;
    entityType: string;
    entityId: string | null;
    oldValues: string | null;
    newValues: string | null;
    ipAddress: string | null;
    userAgent: string | null;
    createdAt: Date;
    _count: AuditLogCountAggregateOutputType | null;
    _min: AuditLogMinAggregateOutputType | null;
    _max: AuditLogMaxAggregateOutputType | null;
  };

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> & {
        [P in keyof T & keyof AuditLogGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
          : GetScalarType<T[P], AuditLogGroupByOutputType[P]>;
      }
    >
  >;

  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        userId?: boolean;
        action?: boolean;
        entityType?: boolean;
        entityId?: boolean;
        oldValues?: boolean;
        newValues?: boolean;
        ipAddress?: boolean;
        userAgent?: boolean;
        createdAt?: boolean;
        user?: boolean | AuditLog$userArgs<ExtArgs>;
      },
      ExtArgs['result']['auditLog']
    >;

  export type AuditLogSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      action?: boolean;
      entityType?: boolean;
      entityId?: boolean;
      oldValues?: boolean;
      newValues?: boolean;
      ipAddress?: boolean;
      userAgent?: boolean;
      createdAt?: boolean;
      user?: boolean | AuditLog$userArgs<ExtArgs>;
    },
    ExtArgs['result']['auditLog']
  >;

  export type AuditLogSelectScalar = {
    id?: boolean;
    userId?: boolean;
    action?: boolean;
    entityType?: boolean;
    entityId?: boolean;
    oldValues?: boolean;
    newValues?: boolean;
    ipAddress?: boolean;
    userAgent?: boolean;
    createdAt?: boolean;
  };

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      user?: boolean | AuditLog$userArgs<ExtArgs>;
    };
  export type AuditLogIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | AuditLog$userArgs<ExtArgs>;
  };

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'AuditLog';
      objects: {
        user: Prisma.$UserPayload<ExtArgs> | null;
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          userId: string | null;
          action: string;
          entityType: string;
          entityId: string | null;
          oldValues: string | null;
          newValues: string | null;
          ipAddress: string | null;
          userAgent: string | null;
          createdAt: Date;
        },
        ExtArgs['result']['auditLog']
      >;
      composites: {};
    };

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> =
    $Result.GetResult<Prisma.$AuditLogPayload, S>;

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    AuditLogFindManyArgs,
    'select' | 'include' | 'distinct'
  > & {
    select?: AuditLogCountAggregateInputType | true;
  };

  export interface AuditLogDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'];
      meta: { name: 'AuditLog' };
    };
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(
      args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(
      args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     *
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AuditLogFindManyArgs>(
      args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     *
     */
    create<T extends AuditLogCreateArgs>(
      args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AuditLogCreateManyArgs>(
      args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(
      args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     *
     */
    delete<T extends AuditLogDeleteArgs>(
      args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AuditLogUpdateArgs>(
      args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(
      args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AuditLogUpdateManyArgs>(
      args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(
      args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
     **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AuditLogAggregateArgs>(
      args: Subset<T, AuditLogAggregateArgs>
    ): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>;

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the AuditLog model
     */
    readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(
      args?: Subset<T, AuditLog$userArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null,
      null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<'AuditLog', 'String'>;
    readonly userId: FieldRef<'AuditLog', 'String'>;
    readonly action: FieldRef<'AuditLog', 'String'>;
    readonly entityType: FieldRef<'AuditLog', 'String'>;
    readonly entityId: FieldRef<'AuditLog', 'String'>;
    readonly oldValues: FieldRef<'AuditLog', 'String'>;
    readonly newValues: FieldRef<'AuditLog', 'String'>;
    readonly ipAddress: FieldRef<'AuditLog', 'String'>;
    readonly userAgent: FieldRef<'AuditLog', 'String'>;
    readonly createdAt: FieldRef<'AuditLog', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>;
  };

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>;
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>;
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput;
  };

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput;
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>;
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>;
  };

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput;
  };

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
  };

  /**
   * Model FAQ
   */

  export type AggregateFAQ = {
    _count: FAQCountAggregateOutputType | null;
    _avg: FAQAvgAggregateOutputType | null;
    _sum: FAQSumAggregateOutputType | null;
    _min: FAQMinAggregateOutputType | null;
    _max: FAQMaxAggregateOutputType | null;
  };

  export type FAQAvgAggregateOutputType = {
    orderIndex: number | null;
  };

  export type FAQSumAggregateOutputType = {
    orderIndex: number | null;
  };

  export type FAQMinAggregateOutputType = {
    id: string | null;
    question: string | null;
    answer: string | null;
    orderIndex: number | null;
    active: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type FAQMaxAggregateOutputType = {
    id: string | null;
    question: string | null;
    answer: string | null;
    orderIndex: number | null;
    active: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type FAQCountAggregateOutputType = {
    id: number;
    question: number;
    answer: number;
    orderIndex: number;
    active: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type FAQAvgAggregateInputType = {
    orderIndex?: true;
  };

  export type FAQSumAggregateInputType = {
    orderIndex?: true;
  };

  export type FAQMinAggregateInputType = {
    id?: true;
    question?: true;
    answer?: true;
    orderIndex?: true;
    active?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type FAQMaxAggregateInputType = {
    id?: true;
    question?: true;
    answer?: true;
    orderIndex?: true;
    active?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type FAQCountAggregateInputType = {
    id?: true;
    question?: true;
    answer?: true;
    orderIndex?: true;
    active?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type FAQAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Filter which FAQ to aggregate.
       */
      where?: FAQWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of FAQS to fetch.
       */
      orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the start position
       */
      cursor?: FAQWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` FAQS from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` FAQS.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Count returned FAQS
       **/
      _count?: true | FAQCountAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to average
       **/
      _avg?: FAQAvgAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to sum
       **/
      _sum?: FAQSumAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the minimum value
       **/
      _min?: FAQMinAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the maximum value
       **/
      _max?: FAQMaxAggregateInputType;
    };

  export type GetFAQAggregateType<T extends FAQAggregateArgs> = {
    [P in keyof T & keyof AggregateFAQ]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFAQ[P]>
      : GetScalarType<T[P], AggregateFAQ[P]>;
  };

  export type FAQGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FAQWhereInput;
    orderBy?: FAQOrderByWithAggregationInput | FAQOrderByWithAggregationInput[];
    by: FAQScalarFieldEnum[] | FAQScalarFieldEnum;
    having?: FAQScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: FAQCountAggregateInputType | true;
    _avg?: FAQAvgAggregateInputType;
    _sum?: FAQSumAggregateInputType;
    _min?: FAQMinAggregateInputType;
    _max?: FAQMaxAggregateInputType;
  };

  export type FAQGroupByOutputType = {
    id: string;
    question: string;
    answer: string;
    orderIndex: number;
    active: boolean;
    createdAt: Date;
    updatedAt: Date;
    _count: FAQCountAggregateOutputType | null;
    _avg: FAQAvgAggregateOutputType | null;
    _sum: FAQSumAggregateOutputType | null;
    _min: FAQMinAggregateOutputType | null;
    _max: FAQMaxAggregateOutputType | null;
  };

  type GetFAQGroupByPayload<T extends FAQGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FAQGroupByOutputType, T['by']> & {
        [P in keyof T & keyof FAQGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], FAQGroupByOutputType[P]>
          : GetScalarType<T[P], FAQGroupByOutputType[P]>;
      }
    >
  >;

  export type FAQSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        question?: boolean;
        answer?: boolean;
        orderIndex?: boolean;
        active?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
      },
      ExtArgs['result']['fAQ']
    >;

  export type FAQSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      question?: boolean;
      answer?: boolean;
      orderIndex?: boolean;
      active?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['fAQ']
  >;

  export type FAQSelectScalar = {
    id?: boolean;
    question?: boolean;
    answer?: boolean;
    orderIndex?: boolean;
    active?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type $FAQPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: 'FAQ';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        question: string;
        answer: string;
        orderIndex: number;
        active: boolean;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['fAQ']
    >;
    composites: {};
  };

  type FAQGetPayload<S extends boolean | null | undefined | FAQDefaultArgs> = $Result.GetResult<
    Prisma.$FAQPayload,
    S
  >;

  type FAQCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    FAQFindManyArgs,
    'select' | 'include' | 'distinct'
  > & {
    select?: FAQCountAggregateInputType | true;
  };

  export interface FAQDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FAQ']; meta: { name: 'FAQ' } };
    /**
     * Find zero or one FAQ that matches the filter.
     * @param {FAQFindUniqueArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FAQFindUniqueArgs>(
      args: SelectSubset<T, FAQFindUniqueArgs<ExtArgs>>
    ): Prisma__FAQClient<
      $Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one FAQ that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FAQFindUniqueOrThrowArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FAQFindUniqueOrThrowArgs>(
      args: SelectSubset<T, FAQFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FAQClient<
      $Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first FAQ that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQFindFirstArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FAQFindFirstArgs>(
      args?: SelectSubset<T, FAQFindFirstArgs<ExtArgs>>
    ): Prisma__FAQClient<
      $Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first FAQ that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQFindFirstOrThrowArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FAQFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FAQFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FAQClient<
      $Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more FAQS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FAQS
     * const fAQS = await prisma.fAQ.findMany()
     *
     * // Get first 10 FAQS
     * const fAQS = await prisma.fAQ.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const fAQWithIdOnly = await prisma.fAQ.findMany({ select: { id: true } })
     *
     */
    findMany<T extends FAQFindManyArgs>(
      args?: SelectSubset<T, FAQFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a FAQ.
     * @param {FAQCreateArgs} args - Arguments to create a FAQ.
     * @example
     * // Create one FAQ
     * const FAQ = await prisma.fAQ.create({
     *   data: {
     *     // ... data to create a FAQ
     *   }
     * })
     *
     */
    create<T extends FAQCreateArgs>(
      args: SelectSubset<T, FAQCreateArgs<ExtArgs>>
    ): Prisma__FAQClient<
      $Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many FAQS.
     * @param {FAQCreateManyArgs} args - Arguments to create many FAQS.
     * @example
     * // Create many FAQS
     * const fAQ = await prisma.fAQ.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FAQCreateManyArgs>(
      args?: SelectSubset<T, FAQCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many FAQS and returns the data saved in the database.
     * @param {FAQCreateManyAndReturnArgs} args - Arguments to create many FAQS.
     * @example
     * // Create many FAQS
     * const fAQ = await prisma.fAQ.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many FAQS and only return the `id`
     * const fAQWithIdOnly = await prisma.fAQ.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends FAQCreateManyAndReturnArgs>(
      args?: SelectSubset<T, FAQCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a FAQ.
     * @param {FAQDeleteArgs} args - Arguments to delete one FAQ.
     * @example
     * // Delete one FAQ
     * const FAQ = await prisma.fAQ.delete({
     *   where: {
     *     // ... filter to delete one FAQ
     *   }
     * })
     *
     */
    delete<T extends FAQDeleteArgs>(
      args: SelectSubset<T, FAQDeleteArgs<ExtArgs>>
    ): Prisma__FAQClient<
      $Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one FAQ.
     * @param {FAQUpdateArgs} args - Arguments to update one FAQ.
     * @example
     * // Update one FAQ
     * const fAQ = await prisma.fAQ.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FAQUpdateArgs>(
      args: SelectSubset<T, FAQUpdateArgs<ExtArgs>>
    ): Prisma__FAQClient<
      $Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more FAQS.
     * @param {FAQDeleteManyArgs} args - Arguments to filter FAQS to delete.
     * @example
     * // Delete a few FAQS
     * const { count } = await prisma.fAQ.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FAQDeleteManyArgs>(
      args?: SelectSubset<T, FAQDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more FAQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FAQS
     * const fAQ = await prisma.fAQ.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FAQUpdateManyArgs>(
      args: SelectSubset<T, FAQUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one FAQ.
     * @param {FAQUpsertArgs} args - Arguments to update or create a FAQ.
     * @example
     * // Update or create a FAQ
     * const fAQ = await prisma.fAQ.upsert({
     *   create: {
     *     // ... data to create a FAQ
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FAQ we want to update
     *   }
     * })
     */
    upsert<T extends FAQUpsertArgs>(
      args: SelectSubset<T, FAQUpsertArgs<ExtArgs>>
    ): Prisma__FAQClient<
      $Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of FAQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQCountArgs} args - Arguments to filter FAQS to count.
     * @example
     * // Count the number of FAQS
     * const count = await prisma.fAQ.count({
     *   where: {
     *     // ... the filter for the FAQS we want to count
     *   }
     * })
     **/
    count<T extends FAQCountArgs>(
      args?: Subset<T, FAQCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FAQCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a FAQ.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FAQAggregateArgs>(
      args: Subset<T, FAQAggregateArgs>
    ): Prisma.PrismaPromise<GetFAQAggregateType<T>>;

    /**
     * Group by FAQ.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FAQGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FAQGroupByArgs['orderBy'] }
        : { orderBy?: FAQGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, FAQGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetFAQGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the FAQ model
     */
    readonly fields: FAQFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FAQ.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FAQClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the FAQ model
   */
  interface FAQFieldRefs {
    readonly id: FieldRef<'FAQ', 'String'>;
    readonly question: FieldRef<'FAQ', 'String'>;
    readonly answer: FieldRef<'FAQ', 'String'>;
    readonly orderIndex: FieldRef<'FAQ', 'Int'>;
    readonly active: FieldRef<'FAQ', 'Boolean'>;
    readonly createdAt: FieldRef<'FAQ', 'DateTime'>;
    readonly updatedAt: FieldRef<'FAQ', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * FAQ findUnique
   */
  export type FAQFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null;
    /**
     * Filter, which FAQ to fetch.
     */
    where: FAQWhereUniqueInput;
  };

  /**
   * FAQ findUniqueOrThrow
   */
  export type FAQFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null;
    /**
     * Filter, which FAQ to fetch.
     */
    where: FAQWhereUniqueInput;
  };

  /**
   * FAQ findFirst
   */
  export type FAQFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the FAQ
       */
      select?: FAQSelect<ExtArgs> | null;
      /**
       * Filter, which FAQ to fetch.
       */
      where?: FAQWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of FAQS to fetch.
       */
      orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for FAQS.
       */
      cursor?: FAQWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` FAQS from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` FAQS.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of FAQS.
       */
      distinct?: FAQScalarFieldEnum | FAQScalarFieldEnum[];
    };

  /**
   * FAQ findFirstOrThrow
   */
  export type FAQFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null;
    /**
     * Filter, which FAQ to fetch.
     */
    where?: FAQWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FAQS.
     */
    cursor?: FAQWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FAQS.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FAQS.
     */
    distinct?: FAQScalarFieldEnum | FAQScalarFieldEnum[];
  };

  /**
   * FAQ findMany
   */
  export type FAQFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the FAQ
       */
      select?: FAQSelect<ExtArgs> | null;
      /**
       * Filter, which FAQS to fetch.
       */
      where?: FAQWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of FAQS to fetch.
       */
      orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing FAQS.
       */
      cursor?: FAQWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` FAQS from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` FAQS.
       */
      skip?: number;
      distinct?: FAQScalarFieldEnum | FAQScalarFieldEnum[];
    };

  /**
   * FAQ create
   */
  export type FAQCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null;
    /**
     * The data needed to create a FAQ.
     */
    data: XOR<FAQCreateInput, FAQUncheckedCreateInput>;
  };

  /**
   * FAQ createMany
   */
  export type FAQCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many FAQS.
     */
    data: FAQCreateManyInput | FAQCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * FAQ createManyAndReturn
   */
  export type FAQCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many FAQS.
     */
    data: FAQCreateManyInput | FAQCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * FAQ update
   */
  export type FAQUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null;
    /**
     * The data needed to update a FAQ.
     */
    data: XOR<FAQUpdateInput, FAQUncheckedUpdateInput>;
    /**
     * Choose, which FAQ to update.
     */
    where: FAQWhereUniqueInput;
  };

  /**
   * FAQ updateMany
   */
  export type FAQUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update FAQS.
     */
    data: XOR<FAQUpdateManyMutationInput, FAQUncheckedUpdateManyInput>;
    /**
     * Filter which FAQS to update
     */
    where?: FAQWhereInput;
  };

  /**
   * FAQ upsert
   */
  export type FAQUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null;
    /**
     * The filter to search for the FAQ to update in case it exists.
     */
    where: FAQWhereUniqueInput;
    /**
     * In case the FAQ found by the `where` argument doesn't exist, create a new FAQ with this data.
     */
    create: XOR<FAQCreateInput, FAQUncheckedCreateInput>;
    /**
     * In case the FAQ was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FAQUpdateInput, FAQUncheckedUpdateInput>;
  };

  /**
   * FAQ delete
   */
  export type FAQDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null;
    /**
     * Filter which FAQ to delete.
     */
    where: FAQWhereUniqueInput;
  };

  /**
   * FAQ deleteMany
   */
  export type FAQDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FAQS to delete
     */
    where?: FAQWhereInput;
  };

  /**
   * FAQ without action
   */
  export type FAQDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null;
  };

  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null;
    _avg: DocumentAvgAggregateOutputType | null;
    _sum: DocumentSumAggregateOutputType | null;
    _min: DocumentMinAggregateOutputType | null;
    _max: DocumentMaxAggregateOutputType | null;
  };

  export type DocumentAvgAggregateOutputType = {
    fileSize: number | null;
  };

  export type DocumentSumAggregateOutputType = {
    fileSize: number | null;
  };

  export type DocumentMinAggregateOutputType = {
    id: string | null;
    orderId: string | null;
    fileName: string | null;
    filePath: string | null;
    fileType: string | null;
    fileSize: number | null;
    uploadedAt: Date | null;
  };

  export type DocumentMaxAggregateOutputType = {
    id: string | null;
    orderId: string | null;
    fileName: string | null;
    filePath: string | null;
    fileType: string | null;
    fileSize: number | null;
    uploadedAt: Date | null;
  };

  export type DocumentCountAggregateOutputType = {
    id: number;
    orderId: number;
    fileName: number;
    filePath: number;
    fileType: number;
    fileSize: number;
    uploadedAt: number;
    _all: number;
  };

  export type DocumentAvgAggregateInputType = {
    fileSize?: true;
  };

  export type DocumentSumAggregateInputType = {
    fileSize?: true;
  };

  export type DocumentMinAggregateInputType = {
    id?: true;
    orderId?: true;
    fileName?: true;
    filePath?: true;
    fileType?: true;
    fileSize?: true;
    uploadedAt?: true;
  };

  export type DocumentMaxAggregateInputType = {
    id?: true;
    orderId?: true;
    fileName?: true;
    filePath?: true;
    fileType?: true;
    fileSize?: true;
    uploadedAt?: true;
  };

  export type DocumentCountAggregateInputType = {
    id?: true;
    orderId?: true;
    fileName?: true;
    filePath?: true;
    fileType?: true;
    fileSize?: true;
    uploadedAt?: true;
    _all?: true;
  };

  export type DocumentAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Documents.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Documents
     **/
    _count?: true | DocumentCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: DocumentAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: DocumentSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: DocumentMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: DocumentMaxAggregateInputType;
  };

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
    [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>;
  };

  export type DocumentGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: DocumentWhereInput;
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[];
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum;
    having?: DocumentScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: DocumentCountAggregateInputType | true;
    _avg?: DocumentAvgAggregateInputType;
    _sum?: DocumentSumAggregateInputType;
    _min?: DocumentMinAggregateInputType;
    _max?: DocumentMaxAggregateInputType;
  };

  export type DocumentGroupByOutputType = {
    id: string;
    orderId: string;
    fileName: string;
    filePath: string;
    fileType: string;
    fileSize: number;
    uploadedAt: Date;
    _count: DocumentCountAggregateOutputType | null;
    _avg: DocumentAvgAggregateOutputType | null;
    _sum: DocumentSumAggregateOutputType | null;
    _min: DocumentMinAggregateOutputType | null;
    _max: DocumentMaxAggregateOutputType | null;
  };

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> & {
        [P in keyof T & keyof DocumentGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
          : GetScalarType<T[P], DocumentGroupByOutputType[P]>;
      }
    >
  >;

  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        orderId?: boolean;
        fileName?: boolean;
        filePath?: boolean;
        fileType?: boolean;
        fileSize?: boolean;
        uploadedAt?: boolean;
        order?: boolean | OrderDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['document']
    >;

  export type DocumentSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      orderId?: boolean;
      fileName?: boolean;
      filePath?: boolean;
      fileType?: boolean;
      fileSize?: boolean;
      uploadedAt?: boolean;
      order?: boolean | OrderDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['document']
  >;

  export type DocumentSelectScalar = {
    id?: boolean;
    orderId?: boolean;
    fileName?: boolean;
    filePath?: boolean;
    fileType?: boolean;
    fileSize?: boolean;
    uploadedAt?: boolean;
  };

  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      order?: boolean | OrderDefaultArgs<ExtArgs>;
    };
  export type DocumentIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    order?: boolean | OrderDefaultArgs<ExtArgs>;
  };

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Document';
      objects: {
        order: Prisma.$OrderPayload<ExtArgs>;
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          orderId: string;
          fileName: string;
          filePath: string;
          fileType: string;
          fileSize: number;
          uploadedAt: Date;
        },
        ExtArgs['result']['document']
      >;
      composites: {};
    };

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> =
    $Result.GetResult<Prisma.$DocumentPayload, S>;

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    DocumentFindManyArgs,
    'select' | 'include' | 'distinct'
  > & {
    select?: DocumentCountAggregateInputType | true;
  };

  export interface DocumentDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Document'];
      meta: { name: 'Document' };
    };
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(
      args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>
    ): Prisma__DocumentClient<
      $Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(
      args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<
      $Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(
      args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>
    ): Prisma__DocumentClient<
      $Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<
      $Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     *
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     *
     */
    findMany<T extends DocumentFindManyArgs>(
      args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     *
     */
    create<T extends DocumentCreateArgs>(
      args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>
    ): Prisma__DocumentClient<
      $Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends DocumentCreateManyArgs>(
      args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(
      args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     *
     */
    delete<T extends DocumentDeleteArgs>(
      args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>
    ): Prisma__DocumentClient<
      $Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends DocumentUpdateArgs>(
      args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>
    ): Prisma__DocumentClient<
      $Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends DocumentDeleteManyArgs>(
      args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends DocumentUpdateManyArgs>(
      args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(
      args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>
    ): Prisma__DocumentClient<
      $Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
     **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends DocumentAggregateArgs>(
      args: Subset<T, DocumentAggregateArgs>
    ): Prisma.PrismaPromise<GetDocumentAggregateType<T>>;

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Document model
     */
    readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrderDefaultArgs<ExtArgs>>
    ): Prisma__OrderClient<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<'Document', 'String'>;
    readonly orderId: FieldRef<'Document', 'String'>;
    readonly fileName: FieldRef<'Document', 'String'>;
    readonly filePath: FieldRef<'Document', 'String'>;
    readonly fileType: FieldRef<'Document', 'String'>;
    readonly fileSize: FieldRef<'Document', 'Int'>;
    readonly uploadedAt: FieldRef<'Document', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput;
  };

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput;
  };

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Documents.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[];
  };

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Documents.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[];
  };

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Documents.
     */
    skip?: number;
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[];
  };

  /**
   * Document create
   */
  export type DocumentCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>;
  };

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Document update
   */
  export type DocumentUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>;
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput;
  };

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>;
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput;
  };

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput;
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>;
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>;
  };

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput;
  };

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput;
  };

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null;
  };

  /**
   * Model OrderDocument
   */

  export type AggregateOrderDocument = {
    _count: OrderDocumentCountAggregateOutputType | null;
    _avg: OrderDocumentAvgAggregateOutputType | null;
    _sum: OrderDocumentSumAggregateOutputType | null;
    _min: OrderDocumentMinAggregateOutputType | null;
    _max: OrderDocumentMaxAggregateOutputType | null;
  };

  export type OrderDocumentAvgAggregateOutputType = {
    fileSize: number | null;
  };

  export type OrderDocumentSumAggregateOutputType = {
    fileSize: number | null;
  };

  export type OrderDocumentMinAggregateOutputType = {
    id: string | null;
    orderId: string | null;
    fileName: string | null;
    filePath: string | null;
    fileSize: number | null;
    fileType: string | null;
    documentType: string | null;
    uploadedAt: Date | null;
  };

  export type OrderDocumentMaxAggregateOutputType = {
    id: string | null;
    orderId: string | null;
    fileName: string | null;
    filePath: string | null;
    fileSize: number | null;
    fileType: string | null;
    documentType: string | null;
    uploadedAt: Date | null;
  };

  export type OrderDocumentCountAggregateOutputType = {
    id: number;
    orderId: number;
    fileName: number;
    filePath: number;
    fileSize: number;
    fileType: number;
    documentType: number;
    uploadedAt: number;
    _all: number;
  };

  export type OrderDocumentAvgAggregateInputType = {
    fileSize?: true;
  };

  export type OrderDocumentSumAggregateInputType = {
    fileSize?: true;
  };

  export type OrderDocumentMinAggregateInputType = {
    id?: true;
    orderId?: true;
    fileName?: true;
    filePath?: true;
    fileSize?: true;
    fileType?: true;
    documentType?: true;
    uploadedAt?: true;
  };

  export type OrderDocumentMaxAggregateInputType = {
    id?: true;
    orderId?: true;
    fileName?: true;
    filePath?: true;
    fileSize?: true;
    fileType?: true;
    documentType?: true;
    uploadedAt?: true;
  };

  export type OrderDocumentCountAggregateInputType = {
    id?: true;
    orderId?: true;
    fileName?: true;
    filePath?: true;
    fileSize?: true;
    fileType?: true;
    documentType?: true;
    uploadedAt?: true;
    _all?: true;
  };

  export type OrderDocumentAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which OrderDocument to aggregate.
     */
    where?: OrderDocumentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of OrderDocuments to fetch.
     */
    orderBy?: OrderDocumentOrderByWithRelationInput | OrderDocumentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: OrderDocumentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` OrderDocuments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` OrderDocuments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned OrderDocuments
     **/
    _count?: true | OrderDocumentCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: OrderDocumentAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: OrderDocumentSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: OrderDocumentMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: OrderDocumentMaxAggregateInputType;
  };

  export type GetOrderDocumentAggregateType<T extends OrderDocumentAggregateArgs> = {
    [P in keyof T & keyof AggregateOrderDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderDocument[P]>
      : GetScalarType<T[P], AggregateOrderDocument[P]>;
  };

  export type OrderDocumentGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: OrderDocumentWhereInput;
    orderBy?: OrderDocumentOrderByWithAggregationInput | OrderDocumentOrderByWithAggregationInput[];
    by: OrderDocumentScalarFieldEnum[] | OrderDocumentScalarFieldEnum;
    having?: OrderDocumentScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: OrderDocumentCountAggregateInputType | true;
    _avg?: OrderDocumentAvgAggregateInputType;
    _sum?: OrderDocumentSumAggregateInputType;
    _min?: OrderDocumentMinAggregateInputType;
    _max?: OrderDocumentMaxAggregateInputType;
  };

  export type OrderDocumentGroupByOutputType = {
    id: string;
    orderId: string;
    fileName: string;
    filePath: string;
    fileSize: number;
    fileType: string;
    documentType: string;
    uploadedAt: Date;
    _count: OrderDocumentCountAggregateOutputType | null;
    _avg: OrderDocumentAvgAggregateOutputType | null;
    _sum: OrderDocumentSumAggregateOutputType | null;
    _min: OrderDocumentMinAggregateOutputType | null;
    _max: OrderDocumentMaxAggregateOutputType | null;
  };

  type GetOrderDocumentGroupByPayload<T extends OrderDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderDocumentGroupByOutputType, T['by']> & {
        [P in keyof T & keyof OrderDocumentGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], OrderDocumentGroupByOutputType[P]>
          : GetScalarType<T[P], OrderDocumentGroupByOutputType[P]>;
      }
    >
  >;

  export type OrderDocumentSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      orderId?: boolean;
      fileName?: boolean;
      filePath?: boolean;
      fileSize?: boolean;
      fileType?: boolean;
      documentType?: boolean;
      uploadedAt?: boolean;
      order?: boolean | OrderDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['orderDocument']
  >;

  export type OrderDocumentSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      orderId?: boolean;
      fileName?: boolean;
      filePath?: boolean;
      fileSize?: boolean;
      fileType?: boolean;
      documentType?: boolean;
      uploadedAt?: boolean;
      order?: boolean | OrderDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['orderDocument']
  >;

  export type OrderDocumentSelectScalar = {
    id?: boolean;
    orderId?: boolean;
    fileName?: boolean;
    filePath?: boolean;
    fileSize?: boolean;
    fileType?: boolean;
    documentType?: boolean;
    uploadedAt?: boolean;
  };

  export type OrderDocumentInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    order?: boolean | OrderDefaultArgs<ExtArgs>;
  };
  export type OrderDocumentIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    order?: boolean | OrderDefaultArgs<ExtArgs>;
  };

  export type $OrderDocumentPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'OrderDocument';
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        orderId: string;
        fileName: string;
        filePath: string;
        fileSize: number;
        fileType: string;
        documentType: string;
        uploadedAt: Date;
      },
      ExtArgs['result']['orderDocument']
    >;
    composites: {};
  };

  type OrderDocumentGetPayload<S extends boolean | null | undefined | OrderDocumentDefaultArgs> =
    $Result.GetResult<Prisma.$OrderDocumentPayload, S>;

  type OrderDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderDocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderDocumentCountAggregateInputType | true;
    };

  export interface OrderDocumentDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['OrderDocument'];
      meta: { name: 'OrderDocument' };
    };
    /**
     * Find zero or one OrderDocument that matches the filter.
     * @param {OrderDocumentFindUniqueArgs} args - Arguments to find a OrderDocument
     * @example
     * // Get one OrderDocument
     * const orderDocument = await prisma.orderDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderDocumentFindUniqueArgs>(
      args: SelectSubset<T, OrderDocumentFindUniqueArgs<ExtArgs>>
    ): Prisma__OrderDocumentClient<
      $Result.GetResult<Prisma.$OrderDocumentPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one OrderDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderDocumentFindUniqueOrThrowArgs} args - Arguments to find a OrderDocument
     * @example
     * // Get one OrderDocument
     * const orderDocument = await prisma.orderDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderDocumentFindUniqueOrThrowArgs>(
      args: SelectSubset<T, OrderDocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrderDocumentClient<
      $Result.GetResult<Prisma.$OrderDocumentPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first OrderDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDocumentFindFirstArgs} args - Arguments to find a OrderDocument
     * @example
     * // Get one OrderDocument
     * const orderDocument = await prisma.orderDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderDocumentFindFirstArgs>(
      args?: SelectSubset<T, OrderDocumentFindFirstArgs<ExtArgs>>
    ): Prisma__OrderDocumentClient<
      $Result.GetResult<Prisma.$OrderDocumentPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first OrderDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDocumentFindFirstOrThrowArgs} args - Arguments to find a OrderDocument
     * @example
     * // Get one OrderDocument
     * const orderDocument = await prisma.orderDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderDocumentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrderDocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrderDocumentClient<
      $Result.GetResult<Prisma.$OrderDocumentPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more OrderDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderDocuments
     * const orderDocuments = await prisma.orderDocument.findMany()
     *
     * // Get first 10 OrderDocuments
     * const orderDocuments = await prisma.orderDocument.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const orderDocumentWithIdOnly = await prisma.orderDocument.findMany({ select: { id: true } })
     *
     */
    findMany<T extends OrderDocumentFindManyArgs>(
      args?: SelectSubset<T, OrderDocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$OrderDocumentPayload<ExtArgs>, T, 'findMany'>
    >;

    /**
     * Create a OrderDocument.
     * @param {OrderDocumentCreateArgs} args - Arguments to create a OrderDocument.
     * @example
     * // Create one OrderDocument
     * const OrderDocument = await prisma.orderDocument.create({
     *   data: {
     *     // ... data to create a OrderDocument
     *   }
     * })
     *
     */
    create<T extends OrderDocumentCreateArgs>(
      args: SelectSubset<T, OrderDocumentCreateArgs<ExtArgs>>
    ): Prisma__OrderDocumentClient<
      $Result.GetResult<Prisma.$OrderDocumentPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many OrderDocuments.
     * @param {OrderDocumentCreateManyArgs} args - Arguments to create many OrderDocuments.
     * @example
     * // Create many OrderDocuments
     * const orderDocument = await prisma.orderDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends OrderDocumentCreateManyArgs>(
      args?: SelectSubset<T, OrderDocumentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many OrderDocuments and returns the data saved in the database.
     * @param {OrderDocumentCreateManyAndReturnArgs} args - Arguments to create many OrderDocuments.
     * @example
     * // Create many OrderDocuments
     * const orderDocument = await prisma.orderDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many OrderDocuments and only return the `id`
     * const orderDocumentWithIdOnly = await prisma.orderDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends OrderDocumentCreateManyAndReturnArgs>(
      args?: SelectSubset<T, OrderDocumentCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$OrderDocumentPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a OrderDocument.
     * @param {OrderDocumentDeleteArgs} args - Arguments to delete one OrderDocument.
     * @example
     * // Delete one OrderDocument
     * const OrderDocument = await prisma.orderDocument.delete({
     *   where: {
     *     // ... filter to delete one OrderDocument
     *   }
     * })
     *
     */
    delete<T extends OrderDocumentDeleteArgs>(
      args: SelectSubset<T, OrderDocumentDeleteArgs<ExtArgs>>
    ): Prisma__OrderDocumentClient<
      $Result.GetResult<Prisma.$OrderDocumentPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one OrderDocument.
     * @param {OrderDocumentUpdateArgs} args - Arguments to update one OrderDocument.
     * @example
     * // Update one OrderDocument
     * const orderDocument = await prisma.orderDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends OrderDocumentUpdateArgs>(
      args: SelectSubset<T, OrderDocumentUpdateArgs<ExtArgs>>
    ): Prisma__OrderDocumentClient<
      $Result.GetResult<Prisma.$OrderDocumentPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more OrderDocuments.
     * @param {OrderDocumentDeleteManyArgs} args - Arguments to filter OrderDocuments to delete.
     * @example
     * // Delete a few OrderDocuments
     * const { count } = await prisma.orderDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends OrderDocumentDeleteManyArgs>(
      args?: SelectSubset<T, OrderDocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more OrderDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderDocuments
     * const orderDocument = await prisma.orderDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends OrderDocumentUpdateManyArgs>(
      args: SelectSubset<T, OrderDocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one OrderDocument.
     * @param {OrderDocumentUpsertArgs} args - Arguments to update or create a OrderDocument.
     * @example
     * // Update or create a OrderDocument
     * const orderDocument = await prisma.orderDocument.upsert({
     *   create: {
     *     // ... data to create a OrderDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderDocument we want to update
     *   }
     * })
     */
    upsert<T extends OrderDocumentUpsertArgs>(
      args: SelectSubset<T, OrderDocumentUpsertArgs<ExtArgs>>
    ): Prisma__OrderDocumentClient<
      $Result.GetResult<Prisma.$OrderDocumentPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of OrderDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDocumentCountArgs} args - Arguments to filter OrderDocuments to count.
     * @example
     * // Count the number of OrderDocuments
     * const count = await prisma.orderDocument.count({
     *   where: {
     *     // ... the filter for the OrderDocuments we want to count
     *   }
     * })
     **/
    count<T extends OrderDocumentCountArgs>(
      args?: Subset<T, OrderDocumentCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderDocumentCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a OrderDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends OrderDocumentAggregateArgs>(
      args: Subset<T, OrderDocumentAggregateArgs>
    ): Prisma.PrismaPromise<GetOrderDocumentAggregateType<T>>;

    /**
     * Group by OrderDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends OrderDocumentGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderDocumentGroupByArgs['orderBy'] }
        : { orderBy?: OrderDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, OrderDocumentGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetOrderDocumentGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the OrderDocument model
     */
    readonly fields: OrderDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderDocumentClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, OrderDefaultArgs<ExtArgs>>
    ): Prisma__OrderClient<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the OrderDocument model
   */
  interface OrderDocumentFieldRefs {
    readonly id: FieldRef<'OrderDocument', 'String'>;
    readonly orderId: FieldRef<'OrderDocument', 'String'>;
    readonly fileName: FieldRef<'OrderDocument', 'String'>;
    readonly filePath: FieldRef<'OrderDocument', 'String'>;
    readonly fileSize: FieldRef<'OrderDocument', 'Int'>;
    readonly fileType: FieldRef<'OrderDocument', 'String'>;
    readonly documentType: FieldRef<'OrderDocument', 'String'>;
    readonly uploadedAt: FieldRef<'OrderDocument', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * OrderDocument findUnique
   */
  export type OrderDocumentFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderDocument
     */
    select?: OrderDocumentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDocumentInclude<ExtArgs> | null;
    /**
     * Filter, which OrderDocument to fetch.
     */
    where: OrderDocumentWhereUniqueInput;
  };

  /**
   * OrderDocument findUniqueOrThrow
   */
  export type OrderDocumentFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderDocument
     */
    select?: OrderDocumentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDocumentInclude<ExtArgs> | null;
    /**
     * Filter, which OrderDocument to fetch.
     */
    where: OrderDocumentWhereUniqueInput;
  };

  /**
   * OrderDocument findFirst
   */
  export type OrderDocumentFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderDocument
     */
    select?: OrderDocumentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDocumentInclude<ExtArgs> | null;
    /**
     * Filter, which OrderDocument to fetch.
     */
    where?: OrderDocumentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of OrderDocuments to fetch.
     */
    orderBy?: OrderDocumentOrderByWithRelationInput | OrderDocumentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for OrderDocuments.
     */
    cursor?: OrderDocumentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` OrderDocuments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` OrderDocuments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of OrderDocuments.
     */
    distinct?: OrderDocumentScalarFieldEnum | OrderDocumentScalarFieldEnum[];
  };

  /**
   * OrderDocument findFirstOrThrow
   */
  export type OrderDocumentFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderDocument
     */
    select?: OrderDocumentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDocumentInclude<ExtArgs> | null;
    /**
     * Filter, which OrderDocument to fetch.
     */
    where?: OrderDocumentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of OrderDocuments to fetch.
     */
    orderBy?: OrderDocumentOrderByWithRelationInput | OrderDocumentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for OrderDocuments.
     */
    cursor?: OrderDocumentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` OrderDocuments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` OrderDocuments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of OrderDocuments.
     */
    distinct?: OrderDocumentScalarFieldEnum | OrderDocumentScalarFieldEnum[];
  };

  /**
   * OrderDocument findMany
   */
  export type OrderDocumentFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderDocument
     */
    select?: OrderDocumentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDocumentInclude<ExtArgs> | null;
    /**
     * Filter, which OrderDocuments to fetch.
     */
    where?: OrderDocumentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of OrderDocuments to fetch.
     */
    orderBy?: OrderDocumentOrderByWithRelationInput | OrderDocumentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing OrderDocuments.
     */
    cursor?: OrderDocumentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` OrderDocuments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` OrderDocuments.
     */
    skip?: number;
    distinct?: OrderDocumentScalarFieldEnum | OrderDocumentScalarFieldEnum[];
  };

  /**
   * OrderDocument create
   */
  export type OrderDocumentCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderDocument
     */
    select?: OrderDocumentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDocumentInclude<ExtArgs> | null;
    /**
     * The data needed to create a OrderDocument.
     */
    data: XOR<OrderDocumentCreateInput, OrderDocumentUncheckedCreateInput>;
  };

  /**
   * OrderDocument createMany
   */
  export type OrderDocumentCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many OrderDocuments.
     */
    data: OrderDocumentCreateManyInput | OrderDocumentCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * OrderDocument createManyAndReturn
   */
  export type OrderDocumentCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderDocument
     */
    select?: OrderDocumentSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many OrderDocuments.
     */
    data: OrderDocumentCreateManyInput | OrderDocumentCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDocumentIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * OrderDocument update
   */
  export type OrderDocumentUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderDocument
     */
    select?: OrderDocumentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDocumentInclude<ExtArgs> | null;
    /**
     * The data needed to update a OrderDocument.
     */
    data: XOR<OrderDocumentUpdateInput, OrderDocumentUncheckedUpdateInput>;
    /**
     * Choose, which OrderDocument to update.
     */
    where: OrderDocumentWhereUniqueInput;
  };

  /**
   * OrderDocument updateMany
   */
  export type OrderDocumentUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update OrderDocuments.
     */
    data: XOR<OrderDocumentUpdateManyMutationInput, OrderDocumentUncheckedUpdateManyInput>;
    /**
     * Filter which OrderDocuments to update
     */
    where?: OrderDocumentWhereInput;
  };

  /**
   * OrderDocument upsert
   */
  export type OrderDocumentUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderDocument
     */
    select?: OrderDocumentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDocumentInclude<ExtArgs> | null;
    /**
     * The filter to search for the OrderDocument to update in case it exists.
     */
    where: OrderDocumentWhereUniqueInput;
    /**
     * In case the OrderDocument found by the `where` argument doesn't exist, create a new OrderDocument with this data.
     */
    create: XOR<OrderDocumentCreateInput, OrderDocumentUncheckedCreateInput>;
    /**
     * In case the OrderDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderDocumentUpdateInput, OrderDocumentUncheckedUpdateInput>;
  };

  /**
   * OrderDocument delete
   */
  export type OrderDocumentDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderDocument
     */
    select?: OrderDocumentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDocumentInclude<ExtArgs> | null;
    /**
     * Filter which OrderDocument to delete.
     */
    where: OrderDocumentWhereUniqueInput;
  };

  /**
   * OrderDocument deleteMany
   */
  export type OrderDocumentDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which OrderDocuments to delete
     */
    where?: OrderDocumentWhereInput;
  };

  /**
   * OrderDocument without action
   */
  export type OrderDocumentDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the OrderDocument
     */
    select?: OrderDocumentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderDocumentInclude<ExtArgs> | null;
  };

  /**
   * Model ServiceDocument
   */

  export type AggregateServiceDocument = {
    _count: ServiceDocumentCountAggregateOutputType | null;
    _avg: ServiceDocumentAvgAggregateOutputType | null;
    _sum: ServiceDocumentSumAggregateOutputType | null;
    _min: ServiceDocumentMinAggregateOutputType | null;
    _max: ServiceDocumentMaxAggregateOutputType | null;
  };

  export type ServiceDocumentAvgAggregateOutputType = {
    orderIndex: number | null;
  };

  export type ServiceDocumentSumAggregateOutputType = {
    orderIndex: number | null;
  };

  export type ServiceDocumentMinAggregateOutputType = {
    id: string | null;
    serviceId: string | null;
    title: string | null;
    description: string | null;
    required: boolean | null;
    showIf: string | null;
    orderIndex: number | null;
    active: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ServiceDocumentMaxAggregateOutputType = {
    id: string | null;
    serviceId: string | null;
    title: string | null;
    description: string | null;
    required: boolean | null;
    showIf: string | null;
    orderIndex: number | null;
    active: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ServiceDocumentCountAggregateOutputType = {
    id: number;
    serviceId: number;
    title: number;
    description: number;
    required: number;
    showIf: number;
    orderIndex: number;
    active: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type ServiceDocumentAvgAggregateInputType = {
    orderIndex?: true;
  };

  export type ServiceDocumentSumAggregateInputType = {
    orderIndex?: true;
  };

  export type ServiceDocumentMinAggregateInputType = {
    id?: true;
    serviceId?: true;
    title?: true;
    description?: true;
    required?: true;
    showIf?: true;
    orderIndex?: true;
    active?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ServiceDocumentMaxAggregateInputType = {
    id?: true;
    serviceId?: true;
    title?: true;
    description?: true;
    required?: true;
    showIf?: true;
    orderIndex?: true;
    active?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ServiceDocumentCountAggregateInputType = {
    id?: true;
    serviceId?: true;
    title?: true;
    description?: true;
    required?: true;
    showIf?: true;
    orderIndex?: true;
    active?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type ServiceDocumentAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ServiceDocument to aggregate.
     */
    where?: ServiceDocumentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ServiceDocuments to fetch.
     */
    orderBy?: ServiceDocumentOrderByWithRelationInput | ServiceDocumentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ServiceDocumentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ServiceDocuments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ServiceDocuments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ServiceDocuments
     **/
    _count?: true | ServiceDocumentCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ServiceDocumentAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ServiceDocumentSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ServiceDocumentMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ServiceDocumentMaxAggregateInputType;
  };

  export type GetServiceDocumentAggregateType<T extends ServiceDocumentAggregateArgs> = {
    [P in keyof T & keyof AggregateServiceDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceDocument[P]>
      : GetScalarType<T[P], AggregateServiceDocument[P]>;
  };

  export type ServiceDocumentGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ServiceDocumentWhereInput;
    orderBy?:
      | ServiceDocumentOrderByWithAggregationInput
      | ServiceDocumentOrderByWithAggregationInput[];
    by: ServiceDocumentScalarFieldEnum[] | ServiceDocumentScalarFieldEnum;
    having?: ServiceDocumentScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ServiceDocumentCountAggregateInputType | true;
    _avg?: ServiceDocumentAvgAggregateInputType;
    _sum?: ServiceDocumentSumAggregateInputType;
    _min?: ServiceDocumentMinAggregateInputType;
    _max?: ServiceDocumentMaxAggregateInputType;
  };

  export type ServiceDocumentGroupByOutputType = {
    id: string;
    serviceId: string;
    title: string;
    description: string | null;
    required: boolean;
    showIf: string | null;
    orderIndex: number;
    active: boolean;
    createdAt: Date;
    updatedAt: Date;
    _count: ServiceDocumentCountAggregateOutputType | null;
    _avg: ServiceDocumentAvgAggregateOutputType | null;
    _sum: ServiceDocumentSumAggregateOutputType | null;
    _min: ServiceDocumentMinAggregateOutputType | null;
    _max: ServiceDocumentMaxAggregateOutputType | null;
  };

  type GetServiceDocumentGroupByPayload<T extends ServiceDocumentGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ServiceDocumentGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ServiceDocumentGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceDocumentGroupByOutputType[P]>;
        }
      >
    >;

  export type ServiceDocumentSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      serviceId?: boolean;
      title?: boolean;
      description?: boolean;
      required?: boolean;
      showIf?: boolean;
      orderIndex?: boolean;
      active?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      service?: boolean | ServiceDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['serviceDocument']
  >;

  export type ServiceDocumentSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      serviceId?: boolean;
      title?: boolean;
      description?: boolean;
      required?: boolean;
      showIf?: boolean;
      orderIndex?: boolean;
      active?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      service?: boolean | ServiceDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['serviceDocument']
  >;

  export type ServiceDocumentSelectScalar = {
    id?: boolean;
    serviceId?: boolean;
    title?: boolean;
    description?: boolean;
    required?: boolean;
    showIf?: boolean;
    orderIndex?: boolean;
    active?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type ServiceDocumentInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>;
  };
  export type ServiceDocumentIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>;
  };

  export type $ServiceDocumentPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'ServiceDocument';
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        serviceId: string;
        title: string;
        description: string | null;
        required: boolean;
        showIf: string | null;
        orderIndex: number;
        active: boolean;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['serviceDocument']
    >;
    composites: {};
  };

  type ServiceDocumentGetPayload<
    S extends boolean | null | undefined | ServiceDocumentDefaultArgs,
  > = $Result.GetResult<Prisma.$ServiceDocumentPayload, S>;

  type ServiceDocumentCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<ServiceDocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
    select?: ServiceDocumentCountAggregateInputType | true;
  };

  export interface ServiceDocumentDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ServiceDocument'];
      meta: { name: 'ServiceDocument' };
    };
    /**
     * Find zero or one ServiceDocument that matches the filter.
     * @param {ServiceDocumentFindUniqueArgs} args - Arguments to find a ServiceDocument
     * @example
     * // Get one ServiceDocument
     * const serviceDocument = await prisma.serviceDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceDocumentFindUniqueArgs>(
      args: SelectSubset<T, ServiceDocumentFindUniqueArgs<ExtArgs>>
    ): Prisma__ServiceDocumentClient<
      $Result.GetResult<Prisma.$ServiceDocumentPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one ServiceDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceDocumentFindUniqueOrThrowArgs} args - Arguments to find a ServiceDocument
     * @example
     * // Get one ServiceDocument
     * const serviceDocument = await prisma.serviceDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceDocumentFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ServiceDocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceDocumentClient<
      $Result.GetResult<Prisma.$ServiceDocumentPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first ServiceDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceDocumentFindFirstArgs} args - Arguments to find a ServiceDocument
     * @example
     * // Get one ServiceDocument
     * const serviceDocument = await prisma.serviceDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceDocumentFindFirstArgs>(
      args?: SelectSubset<T, ServiceDocumentFindFirstArgs<ExtArgs>>
    ): Prisma__ServiceDocumentClient<
      $Result.GetResult<Prisma.$ServiceDocumentPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first ServiceDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceDocumentFindFirstOrThrowArgs} args - Arguments to find a ServiceDocument
     * @example
     * // Get one ServiceDocument
     * const serviceDocument = await prisma.serviceDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceDocumentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ServiceDocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceDocumentClient<
      $Result.GetResult<Prisma.$ServiceDocumentPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more ServiceDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceDocuments
     * const serviceDocuments = await prisma.serviceDocument.findMany()
     *
     * // Get first 10 ServiceDocuments
     * const serviceDocuments = await prisma.serviceDocument.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const serviceDocumentWithIdOnly = await prisma.serviceDocument.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ServiceDocumentFindManyArgs>(
      args?: SelectSubset<T, ServiceDocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ServiceDocumentPayload<ExtArgs>, T, 'findMany'>
    >;

    /**
     * Create a ServiceDocument.
     * @param {ServiceDocumentCreateArgs} args - Arguments to create a ServiceDocument.
     * @example
     * // Create one ServiceDocument
     * const ServiceDocument = await prisma.serviceDocument.create({
     *   data: {
     *     // ... data to create a ServiceDocument
     *   }
     * })
     *
     */
    create<T extends ServiceDocumentCreateArgs>(
      args: SelectSubset<T, ServiceDocumentCreateArgs<ExtArgs>>
    ): Prisma__ServiceDocumentClient<
      $Result.GetResult<Prisma.$ServiceDocumentPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many ServiceDocuments.
     * @param {ServiceDocumentCreateManyArgs} args - Arguments to create many ServiceDocuments.
     * @example
     * // Create many ServiceDocuments
     * const serviceDocument = await prisma.serviceDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ServiceDocumentCreateManyArgs>(
      args?: SelectSubset<T, ServiceDocumentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ServiceDocuments and returns the data saved in the database.
     * @param {ServiceDocumentCreateManyAndReturnArgs} args - Arguments to create many ServiceDocuments.
     * @example
     * // Create many ServiceDocuments
     * const serviceDocument = await prisma.serviceDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ServiceDocuments and only return the `id`
     * const serviceDocumentWithIdOnly = await prisma.serviceDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ServiceDocumentCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ServiceDocumentCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ServiceDocumentPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a ServiceDocument.
     * @param {ServiceDocumentDeleteArgs} args - Arguments to delete one ServiceDocument.
     * @example
     * // Delete one ServiceDocument
     * const ServiceDocument = await prisma.serviceDocument.delete({
     *   where: {
     *     // ... filter to delete one ServiceDocument
     *   }
     * })
     *
     */
    delete<T extends ServiceDocumentDeleteArgs>(
      args: SelectSubset<T, ServiceDocumentDeleteArgs<ExtArgs>>
    ): Prisma__ServiceDocumentClient<
      $Result.GetResult<Prisma.$ServiceDocumentPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one ServiceDocument.
     * @param {ServiceDocumentUpdateArgs} args - Arguments to update one ServiceDocument.
     * @example
     * // Update one ServiceDocument
     * const serviceDocument = await prisma.serviceDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ServiceDocumentUpdateArgs>(
      args: SelectSubset<T, ServiceDocumentUpdateArgs<ExtArgs>>
    ): Prisma__ServiceDocumentClient<
      $Result.GetResult<Prisma.$ServiceDocumentPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more ServiceDocuments.
     * @param {ServiceDocumentDeleteManyArgs} args - Arguments to filter ServiceDocuments to delete.
     * @example
     * // Delete a few ServiceDocuments
     * const { count } = await prisma.serviceDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ServiceDocumentDeleteManyArgs>(
      args?: SelectSubset<T, ServiceDocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ServiceDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceDocuments
     * const serviceDocument = await prisma.serviceDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ServiceDocumentUpdateManyArgs>(
      args: SelectSubset<T, ServiceDocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one ServiceDocument.
     * @param {ServiceDocumentUpsertArgs} args - Arguments to update or create a ServiceDocument.
     * @example
     * // Update or create a ServiceDocument
     * const serviceDocument = await prisma.serviceDocument.upsert({
     *   create: {
     *     // ... data to create a ServiceDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceDocument we want to update
     *   }
     * })
     */
    upsert<T extends ServiceDocumentUpsertArgs>(
      args: SelectSubset<T, ServiceDocumentUpsertArgs<ExtArgs>>
    ): Prisma__ServiceDocumentClient<
      $Result.GetResult<Prisma.$ServiceDocumentPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of ServiceDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceDocumentCountArgs} args - Arguments to filter ServiceDocuments to count.
     * @example
     * // Count the number of ServiceDocuments
     * const count = await prisma.serviceDocument.count({
     *   where: {
     *     // ... the filter for the ServiceDocuments we want to count
     *   }
     * })
     **/
    count<T extends ServiceDocumentCountArgs>(
      args?: Subset<T, ServiceDocumentCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceDocumentCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ServiceDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ServiceDocumentAggregateArgs>(
      args: Subset<T, ServiceDocumentAggregateArgs>
    ): Prisma.PrismaPromise<GetServiceDocumentAggregateType<T>>;

    /**
     * Group by ServiceDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ServiceDocumentGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceDocumentGroupByArgs['orderBy'] }
        : { orderBy?: ServiceDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ServiceDocumentGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetServiceDocumentGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ServiceDocument model
     */
    readonly fields: ServiceDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceDocumentClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ServiceDefaultArgs<ExtArgs>>
    ): Prisma__ServiceClient<
      $Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ServiceDocument model
   */
  interface ServiceDocumentFieldRefs {
    readonly id: FieldRef<'ServiceDocument', 'String'>;
    readonly serviceId: FieldRef<'ServiceDocument', 'String'>;
    readonly title: FieldRef<'ServiceDocument', 'String'>;
    readonly description: FieldRef<'ServiceDocument', 'String'>;
    readonly required: FieldRef<'ServiceDocument', 'Boolean'>;
    readonly showIf: FieldRef<'ServiceDocument', 'String'>;
    readonly orderIndex: FieldRef<'ServiceDocument', 'Int'>;
    readonly active: FieldRef<'ServiceDocument', 'Boolean'>;
    readonly createdAt: FieldRef<'ServiceDocument', 'DateTime'>;
    readonly updatedAt: FieldRef<'ServiceDocument', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * ServiceDocument findUnique
   */
  export type ServiceDocumentFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceDocument
     */
    select?: ServiceDocumentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDocumentInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceDocument to fetch.
     */
    where: ServiceDocumentWhereUniqueInput;
  };

  /**
   * ServiceDocument findUniqueOrThrow
   */
  export type ServiceDocumentFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceDocument
     */
    select?: ServiceDocumentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDocumentInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceDocument to fetch.
     */
    where: ServiceDocumentWhereUniqueInput;
  };

  /**
   * ServiceDocument findFirst
   */
  export type ServiceDocumentFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceDocument
     */
    select?: ServiceDocumentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDocumentInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceDocument to fetch.
     */
    where?: ServiceDocumentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ServiceDocuments to fetch.
     */
    orderBy?: ServiceDocumentOrderByWithRelationInput | ServiceDocumentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ServiceDocuments.
     */
    cursor?: ServiceDocumentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ServiceDocuments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ServiceDocuments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ServiceDocuments.
     */
    distinct?: ServiceDocumentScalarFieldEnum | ServiceDocumentScalarFieldEnum[];
  };

  /**
   * ServiceDocument findFirstOrThrow
   */
  export type ServiceDocumentFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceDocument
     */
    select?: ServiceDocumentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDocumentInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceDocument to fetch.
     */
    where?: ServiceDocumentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ServiceDocuments to fetch.
     */
    orderBy?: ServiceDocumentOrderByWithRelationInput | ServiceDocumentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ServiceDocuments.
     */
    cursor?: ServiceDocumentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ServiceDocuments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ServiceDocuments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ServiceDocuments.
     */
    distinct?: ServiceDocumentScalarFieldEnum | ServiceDocumentScalarFieldEnum[];
  };

  /**
   * ServiceDocument findMany
   */
  export type ServiceDocumentFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceDocument
     */
    select?: ServiceDocumentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDocumentInclude<ExtArgs> | null;
    /**
     * Filter, which ServiceDocuments to fetch.
     */
    where?: ServiceDocumentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ServiceDocuments to fetch.
     */
    orderBy?: ServiceDocumentOrderByWithRelationInput | ServiceDocumentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ServiceDocuments.
     */
    cursor?: ServiceDocumentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ServiceDocuments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ServiceDocuments.
     */
    skip?: number;
    distinct?: ServiceDocumentScalarFieldEnum | ServiceDocumentScalarFieldEnum[];
  };

  /**
   * ServiceDocument create
   */
  export type ServiceDocumentCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceDocument
     */
    select?: ServiceDocumentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDocumentInclude<ExtArgs> | null;
    /**
     * The data needed to create a ServiceDocument.
     */
    data: XOR<ServiceDocumentCreateInput, ServiceDocumentUncheckedCreateInput>;
  };

  /**
   * ServiceDocument createMany
   */
  export type ServiceDocumentCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ServiceDocuments.
     */
    data: ServiceDocumentCreateManyInput | ServiceDocumentCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ServiceDocument createManyAndReturn
   */
  export type ServiceDocumentCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceDocument
     */
    select?: ServiceDocumentSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many ServiceDocuments.
     */
    data: ServiceDocumentCreateManyInput | ServiceDocumentCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDocumentIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ServiceDocument update
   */
  export type ServiceDocumentUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceDocument
     */
    select?: ServiceDocumentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDocumentInclude<ExtArgs> | null;
    /**
     * The data needed to update a ServiceDocument.
     */
    data: XOR<ServiceDocumentUpdateInput, ServiceDocumentUncheckedUpdateInput>;
    /**
     * Choose, which ServiceDocument to update.
     */
    where: ServiceDocumentWhereUniqueInput;
  };

  /**
   * ServiceDocument updateMany
   */
  export type ServiceDocumentUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ServiceDocuments.
     */
    data: XOR<ServiceDocumentUpdateManyMutationInput, ServiceDocumentUncheckedUpdateManyInput>;
    /**
     * Filter which ServiceDocuments to update
     */
    where?: ServiceDocumentWhereInput;
  };

  /**
   * ServiceDocument upsert
   */
  export type ServiceDocumentUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceDocument
     */
    select?: ServiceDocumentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDocumentInclude<ExtArgs> | null;
    /**
     * The filter to search for the ServiceDocument to update in case it exists.
     */
    where: ServiceDocumentWhereUniqueInput;
    /**
     * In case the ServiceDocument found by the `where` argument doesn't exist, create a new ServiceDocument with this data.
     */
    create: XOR<ServiceDocumentCreateInput, ServiceDocumentUncheckedCreateInput>;
    /**
     * In case the ServiceDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceDocumentUpdateInput, ServiceDocumentUncheckedUpdateInput>;
  };

  /**
   * ServiceDocument delete
   */
  export type ServiceDocumentDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceDocument
     */
    select?: ServiceDocumentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDocumentInclude<ExtArgs> | null;
    /**
     * Filter which ServiceDocument to delete.
     */
    where: ServiceDocumentWhereUniqueInput;
  };

  /**
   * ServiceDocument deleteMany
   */
  export type ServiceDocumentDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ServiceDocuments to delete
     */
    where?: ServiceDocumentWhereInput;
  };

  /**
   * ServiceDocument without action
   */
  export type ServiceDocumentDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceDocument
     */
    select?: ServiceDocumentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDocumentInclude<ExtArgs> | null;
  };

  /**
   * Model SystemSettings
   */

  export type AggregateSystemSettings = {
    _count: SystemSettingsCountAggregateOutputType | null;
    _min: SystemSettingsMinAggregateOutputType | null;
    _max: SystemSettingsMaxAggregateOutputType | null;
  };

  export type SystemSettingsMinAggregateOutputType = {
    id: string | null;
    siteName: string | null;
    siteDescription: string | null;
    contactEmail: string | null;
    contactPhone: string | null;
    address: string | null;
    workingHours: string | null;
    socialLinks: string | null;
    seoSettings: string | null;
    updatedAt: Date | null;
  };

  export type SystemSettingsMaxAggregateOutputType = {
    id: string | null;
    siteName: string | null;
    siteDescription: string | null;
    contactEmail: string | null;
    contactPhone: string | null;
    address: string | null;
    workingHours: string | null;
    socialLinks: string | null;
    seoSettings: string | null;
    updatedAt: Date | null;
  };

  export type SystemSettingsCountAggregateOutputType = {
    id: number;
    siteName: number;
    siteDescription: number;
    contactEmail: number;
    contactPhone: number;
    address: number;
    workingHours: number;
    socialLinks: number;
    seoSettings: number;
    updatedAt: number;
    _all: number;
  };

  export type SystemSettingsMinAggregateInputType = {
    id?: true;
    siteName?: true;
    siteDescription?: true;
    contactEmail?: true;
    contactPhone?: true;
    address?: true;
    workingHours?: true;
    socialLinks?: true;
    seoSettings?: true;
    updatedAt?: true;
  };

  export type SystemSettingsMaxAggregateInputType = {
    id?: true;
    siteName?: true;
    siteDescription?: true;
    contactEmail?: true;
    contactPhone?: true;
    address?: true;
    workingHours?: true;
    socialLinks?: true;
    seoSettings?: true;
    updatedAt?: true;
  };

  export type SystemSettingsCountAggregateInputType = {
    id?: true;
    siteName?: true;
    siteDescription?: true;
    contactEmail?: true;
    contactPhone?: true;
    address?: true;
    workingHours?: true;
    socialLinks?: true;
    seoSettings?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type SystemSettingsAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which SystemSettings to aggregate.
     */
    where?: SystemSettingsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SystemSettingsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SystemSettings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned SystemSettings
     **/
    _count?: true | SystemSettingsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SystemSettingsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SystemSettingsMaxAggregateInputType;
  };

  export type GetSystemSettingsAggregateType<T extends SystemSettingsAggregateArgs> = {
    [P in keyof T & keyof AggregateSystemSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSettings[P]>
      : GetScalarType<T[P], AggregateSystemSettings[P]>;
  };

  export type SystemSettingsGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SystemSettingsWhereInput;
    orderBy?:
      | SystemSettingsOrderByWithAggregationInput
      | SystemSettingsOrderByWithAggregationInput[];
    by: SystemSettingsScalarFieldEnum[] | SystemSettingsScalarFieldEnum;
    having?: SystemSettingsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SystemSettingsCountAggregateInputType | true;
    _min?: SystemSettingsMinAggregateInputType;
    _max?: SystemSettingsMaxAggregateInputType;
  };

  export type SystemSettingsGroupByOutputType = {
    id: string;
    siteName: string;
    siteDescription: string | null;
    contactEmail: string | null;
    contactPhone: string | null;
    address: string | null;
    workingHours: string | null;
    socialLinks: string | null;
    seoSettings: string | null;
    updatedAt: Date;
    _count: SystemSettingsCountAggregateOutputType | null;
    _min: SystemSettingsMinAggregateOutputType | null;
    _max: SystemSettingsMaxAggregateOutputType | null;
  };

  type GetSystemSettingsGroupByPayload<T extends SystemSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingsGroupByOutputType, T['by']> & {
        [P in keyof T & keyof SystemSettingsGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], SystemSettingsGroupByOutputType[P]>
          : GetScalarType<T[P], SystemSettingsGroupByOutputType[P]>;
      }
    >
  >;

  export type SystemSettingsSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      siteName?: boolean;
      siteDescription?: boolean;
      contactEmail?: boolean;
      contactPhone?: boolean;
      address?: boolean;
      workingHours?: boolean;
      socialLinks?: boolean;
      seoSettings?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['systemSettings']
  >;

  export type SystemSettingsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      siteName?: boolean;
      siteDescription?: boolean;
      contactEmail?: boolean;
      contactPhone?: boolean;
      address?: boolean;
      workingHours?: boolean;
      socialLinks?: boolean;
      seoSettings?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['systemSettings']
  >;

  export type SystemSettingsSelectScalar = {
    id?: boolean;
    siteName?: boolean;
    siteDescription?: boolean;
    contactEmail?: boolean;
    contactPhone?: boolean;
    address?: boolean;
    workingHours?: boolean;
    socialLinks?: boolean;
    seoSettings?: boolean;
    updatedAt?: boolean;
  };

  export type $SystemSettingsPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'SystemSettings';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        siteName: string;
        siteDescription: string | null;
        contactEmail: string | null;
        contactPhone: string | null;
        address: string | null;
        workingHours: string | null;
        socialLinks: string | null;
        seoSettings: string | null;
        updatedAt: Date;
      },
      ExtArgs['result']['systemSettings']
    >;
    composites: {};
  };

  type SystemSettingsGetPayload<S extends boolean | null | undefined | SystemSettingsDefaultArgs> =
    $Result.GetResult<Prisma.$SystemSettingsPayload, S>;

  type SystemSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemSettingsCountAggregateInputType | true;
    };

  export interface SystemSettingsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['SystemSettings'];
      meta: { name: 'SystemSettings' };
    };
    /**
     * Find zero or one SystemSettings that matches the filter.
     * @param {SystemSettingsFindUniqueArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemSettingsFindUniqueArgs>(
      args: SelectSubset<T, SystemSettingsFindUniqueArgs<ExtArgs>>
    ): Prisma__SystemSettingsClient<
      $Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one SystemSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemSettingsFindUniqueOrThrowArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemSettingsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SystemSettingsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SystemSettingsClient<
      $Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindFirstArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemSettingsFindFirstArgs>(
      args?: SelectSubset<T, SystemSettingsFindFirstArgs<ExtArgs>>
    ): Prisma__SystemSettingsClient<
      $Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first SystemSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindFirstOrThrowArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemSettingsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SystemSettingsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SystemSettingsClient<
      $Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSettings.findMany()
     *
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSettings.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const systemSettingsWithIdOnly = await prisma.systemSettings.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SystemSettingsFindManyArgs>(
      args?: SelectSubset<T, SystemSettingsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, 'findMany'>
    >;

    /**
     * Create a SystemSettings.
     * @param {SystemSettingsCreateArgs} args - Arguments to create a SystemSettings.
     * @example
     * // Create one SystemSettings
     * const SystemSettings = await prisma.systemSettings.create({
     *   data: {
     *     // ... data to create a SystemSettings
     *   }
     * })
     *
     */
    create<T extends SystemSettingsCreateArgs>(
      args: SelectSubset<T, SystemSettingsCreateArgs<ExtArgs>>
    ): Prisma__SystemSettingsClient<
      $Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many SystemSettings.
     * @param {SystemSettingsCreateManyArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSettings = await prisma.systemSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SystemSettingsCreateManyArgs>(
      args?: SelectSubset<T, SystemSettingsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many SystemSettings and returns the data saved in the database.
     * @param {SystemSettingsCreateManyAndReturnArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSettings = await prisma.systemSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many SystemSettings and only return the `id`
     * const systemSettingsWithIdOnly = await prisma.systemSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SystemSettingsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, SystemSettingsCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a SystemSettings.
     * @param {SystemSettingsDeleteArgs} args - Arguments to delete one SystemSettings.
     * @example
     * // Delete one SystemSettings
     * const SystemSettings = await prisma.systemSettings.delete({
     *   where: {
     *     // ... filter to delete one SystemSettings
     *   }
     * })
     *
     */
    delete<T extends SystemSettingsDeleteArgs>(
      args: SelectSubset<T, SystemSettingsDeleteArgs<ExtArgs>>
    ): Prisma__SystemSettingsClient<
      $Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one SystemSettings.
     * @param {SystemSettingsUpdateArgs} args - Arguments to update one SystemSettings.
     * @example
     * // Update one SystemSettings
     * const systemSettings = await prisma.systemSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SystemSettingsUpdateArgs>(
      args: SelectSubset<T, SystemSettingsUpdateArgs<ExtArgs>>
    ): Prisma__SystemSettingsClient<
      $Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingsDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SystemSettingsDeleteManyArgs>(
      args?: SelectSubset<T, SystemSettingsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSettings = await prisma.systemSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SystemSettingsUpdateManyArgs>(
      args: SelectSubset<T, SystemSettingsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one SystemSettings.
     * @param {SystemSettingsUpsertArgs} args - Arguments to update or create a SystemSettings.
     * @example
     * // Update or create a SystemSettings
     * const systemSettings = await prisma.systemSettings.upsert({
     *   create: {
     *     // ... data to create a SystemSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSettings we want to update
     *   }
     * })
     */
    upsert<T extends SystemSettingsUpsertArgs>(
      args: SelectSubset<T, SystemSettingsUpsertArgs<ExtArgs>>
    ): Prisma__SystemSettingsClient<
      $Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSettings.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
     **/
    count<T extends SystemSettingsCountArgs>(
      args?: Subset<T, SystemSettingsCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SystemSettingsAggregateArgs>(
      args: Subset<T, SystemSettingsAggregateArgs>
    ): Prisma.PrismaPromise<GetSystemSettingsAggregateType<T>>;

    /**
     * Group by SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SystemSettingsGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingsGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SystemSettingsGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetSystemSettingsGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the SystemSettings model
     */
    readonly fields: SystemSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the SystemSettings model
   */
  interface SystemSettingsFieldRefs {
    readonly id: FieldRef<'SystemSettings', 'String'>;
    readonly siteName: FieldRef<'SystemSettings', 'String'>;
    readonly siteDescription: FieldRef<'SystemSettings', 'String'>;
    readonly contactEmail: FieldRef<'SystemSettings', 'String'>;
    readonly contactPhone: FieldRef<'SystemSettings', 'String'>;
    readonly address: FieldRef<'SystemSettings', 'String'>;
    readonly workingHours: FieldRef<'SystemSettings', 'String'>;
    readonly socialLinks: FieldRef<'SystemSettings', 'String'>;
    readonly seoSettings: FieldRef<'SystemSettings', 'String'>;
    readonly updatedAt: FieldRef<'SystemSettings', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * SystemSettings findUnique
   */
  export type SystemSettingsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null;
    /**
     * Filter, which SystemSettings to fetch.
     */
    where: SystemSettingsWhereUniqueInput;
  };

  /**
   * SystemSettings findUniqueOrThrow
   */
  export type SystemSettingsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null;
    /**
     * Filter, which SystemSettings to fetch.
     */
    where: SystemSettingsWhereUniqueInput;
  };

  /**
   * SystemSettings findFirst
   */
  export type SystemSettingsFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null;
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SystemSettings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[];
  };

  /**
   * SystemSettings findFirstOrThrow
   */
  export type SystemSettingsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null;
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SystemSettings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[];
  };

  /**
   * SystemSettings findMany
   */
  export type SystemSettingsFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null;
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SystemSettings.
     */
    skip?: number;
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[];
  };

  /**
   * SystemSettings create
   */
  export type SystemSettingsCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null;
    /**
     * The data needed to create a SystemSettings.
     */
    data: XOR<SystemSettingsCreateInput, SystemSettingsUncheckedCreateInput>;
  };

  /**
   * SystemSettings createMany
   */
  export type SystemSettingsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingsCreateManyInput | SystemSettingsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * SystemSettings createManyAndReturn
   */
  export type SystemSettingsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingsCreateManyInput | SystemSettingsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * SystemSettings update
   */
  export type SystemSettingsUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null;
    /**
     * The data needed to update a SystemSettings.
     */
    data: XOR<SystemSettingsUpdateInput, SystemSettingsUncheckedUpdateInput>;
    /**
     * Choose, which SystemSettings to update.
     */
    where: SystemSettingsWhereUniqueInput;
  };

  /**
   * SystemSettings updateMany
   */
  export type SystemSettingsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingsUpdateManyMutationInput, SystemSettingsUncheckedUpdateManyInput>;
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingsWhereInput;
  };

  /**
   * SystemSettings upsert
   */
  export type SystemSettingsUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null;
    /**
     * The filter to search for the SystemSettings to update in case it exists.
     */
    where: SystemSettingsWhereUniqueInput;
    /**
     * In case the SystemSettings found by the `where` argument doesn't exist, create a new SystemSettings with this data.
     */
    create: XOR<SystemSettingsCreateInput, SystemSettingsUncheckedCreateInput>;
    /**
     * In case the SystemSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingsUpdateInput, SystemSettingsUncheckedUpdateInput>;
  };

  /**
   * SystemSettings delete
   */
  export type SystemSettingsDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null;
    /**
     * Filter which SystemSettings to delete.
     */
    where: SystemSettingsWhereUniqueInput;
  };

  /**
   * SystemSettings deleteMany
   */
  export type SystemSettingsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingsWhereInput;
  };

  /**
   * SystemSettings without action
   */
  export type SystemSettingsDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null;
  };

  /**
   * Model FormType
   */

  export type AggregateFormType = {
    _count: FormTypeCountAggregateOutputType | null;
    _min: FormTypeMinAggregateOutputType | null;
    _max: FormTypeMaxAggregateOutputType | null;
  };

  export type FormTypeMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    active: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type FormTypeMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    active: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type FormTypeCountAggregateOutputType = {
    id: number;
    name: number;
    description: number;
    active: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type FormTypeMinAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    active?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type FormTypeMaxAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    active?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type FormTypeCountAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    active?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type FormTypeAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FormType to aggregate.
     */
    where?: FormTypeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FormTypes to fetch.
     */
    orderBy?: FormTypeOrderByWithRelationInput | FormTypeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: FormTypeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FormTypes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FormTypes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned FormTypes
     **/
    _count?: true | FormTypeCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FormTypeMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FormTypeMaxAggregateInputType;
  };

  export type GetFormTypeAggregateType<T extends FormTypeAggregateArgs> = {
    [P in keyof T & keyof AggregateFormType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormType[P]>
      : GetScalarType<T[P], AggregateFormType[P]>;
  };

  export type FormTypeGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FormTypeWhereInput;
    orderBy?: FormTypeOrderByWithAggregationInput | FormTypeOrderByWithAggregationInput[];
    by: FormTypeScalarFieldEnum[] | FormTypeScalarFieldEnum;
    having?: FormTypeScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: FormTypeCountAggregateInputType | true;
    _min?: FormTypeMinAggregateInputType;
    _max?: FormTypeMaxAggregateInputType;
  };

  export type FormTypeGroupByOutputType = {
    id: string;
    name: string;
    description: string | null;
    active: boolean;
    createdAt: Date;
    updatedAt: Date;
    _count: FormTypeCountAggregateOutputType | null;
    _min: FormTypeMinAggregateOutputType | null;
    _max: FormTypeMaxAggregateOutputType | null;
  };

  type GetFormTypeGroupByPayload<T extends FormTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormTypeGroupByOutputType, T['by']> & {
        [P in keyof T & keyof FormTypeGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], FormTypeGroupByOutputType[P]>
          : GetScalarType<T[P], FormTypeGroupByOutputType[P]>;
      }
    >
  >;

  export type FormTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        name?: boolean;
        description?: boolean;
        active?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        variantLinks?: boolean | FormType$variantLinksArgs<ExtArgs>;
        serials?: boolean | FormType$serialsArgs<ExtArgs>;
        _count?: boolean | FormTypeCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['formType']
    >;

  export type FormTypeSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      active?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['formType']
  >;

  export type FormTypeSelectScalar = {
    id?: boolean;
    name?: boolean;
    description?: boolean;
    active?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type FormTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      variantLinks?: boolean | FormType$variantLinksArgs<ExtArgs>;
      serials?: boolean | FormType$serialsArgs<ExtArgs>;
      _count?: boolean | FormTypeCountOutputTypeDefaultArgs<ExtArgs>;
    };
  export type FormTypeIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $FormTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'FormType';
      objects: {
        variantLinks: Prisma.$FormTypeVariantPayload<ExtArgs>[];
        serials: Prisma.$FormSerialPayload<ExtArgs>[];
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          name: string;
          description: string | null;
          active: boolean;
          createdAt: Date;
          updatedAt: Date;
        },
        ExtArgs['result']['formType']
      >;
      composites: {};
    };

  type FormTypeGetPayload<S extends boolean | null | undefined | FormTypeDefaultArgs> =
    $Result.GetResult<Prisma.$FormTypePayload, S>;

  type FormTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    FormTypeFindManyArgs,
    'select' | 'include' | 'distinct'
  > & {
    select?: FormTypeCountAggregateInputType | true;
  };

  export interface FormTypeDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['FormType'];
      meta: { name: 'FormType' };
    };
    /**
     * Find zero or one FormType that matches the filter.
     * @param {FormTypeFindUniqueArgs} args - Arguments to find a FormType
     * @example
     * // Get one FormType
     * const formType = await prisma.formType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FormTypeFindUniqueArgs>(
      args: SelectSubset<T, FormTypeFindUniqueArgs<ExtArgs>>
    ): Prisma__FormTypeClient<
      $Result.GetResult<Prisma.$FormTypePayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one FormType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FormTypeFindUniqueOrThrowArgs} args - Arguments to find a FormType
     * @example
     * // Get one FormType
     * const formType = await prisma.formType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FormTypeFindUniqueOrThrowArgs>(
      args: SelectSubset<T, FormTypeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FormTypeClient<
      $Result.GetResult<Prisma.$FormTypePayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first FormType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTypeFindFirstArgs} args - Arguments to find a FormType
     * @example
     * // Get one FormType
     * const formType = await prisma.formType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FormTypeFindFirstArgs>(
      args?: SelectSubset<T, FormTypeFindFirstArgs<ExtArgs>>
    ): Prisma__FormTypeClient<
      $Result.GetResult<Prisma.$FormTypePayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first FormType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTypeFindFirstOrThrowArgs} args - Arguments to find a FormType
     * @example
     * // Get one FormType
     * const formType = await prisma.formType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FormTypeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FormTypeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FormTypeClient<
      $Result.GetResult<Prisma.$FormTypePayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more FormTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormTypes
     * const formTypes = await prisma.formType.findMany()
     *
     * // Get first 10 FormTypes
     * const formTypes = await prisma.formType.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const formTypeWithIdOnly = await prisma.formType.findMany({ select: { id: true } })
     *
     */
    findMany<T extends FormTypeFindManyArgs>(
      args?: SelectSubset<T, FormTypeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormTypePayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a FormType.
     * @param {FormTypeCreateArgs} args - Arguments to create a FormType.
     * @example
     * // Create one FormType
     * const FormType = await prisma.formType.create({
     *   data: {
     *     // ... data to create a FormType
     *   }
     * })
     *
     */
    create<T extends FormTypeCreateArgs>(
      args: SelectSubset<T, FormTypeCreateArgs<ExtArgs>>
    ): Prisma__FormTypeClient<
      $Result.GetResult<Prisma.$FormTypePayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many FormTypes.
     * @param {FormTypeCreateManyArgs} args - Arguments to create many FormTypes.
     * @example
     * // Create many FormTypes
     * const formType = await prisma.formType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FormTypeCreateManyArgs>(
      args?: SelectSubset<T, FormTypeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many FormTypes and returns the data saved in the database.
     * @param {FormTypeCreateManyAndReturnArgs} args - Arguments to create many FormTypes.
     * @example
     * // Create many FormTypes
     * const formType = await prisma.formType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many FormTypes and only return the `id`
     * const formTypeWithIdOnly = await prisma.formType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends FormTypeCreateManyAndReturnArgs>(
      args?: SelectSubset<T, FormTypeCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$FormTypePayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a FormType.
     * @param {FormTypeDeleteArgs} args - Arguments to delete one FormType.
     * @example
     * // Delete one FormType
     * const FormType = await prisma.formType.delete({
     *   where: {
     *     // ... filter to delete one FormType
     *   }
     * })
     *
     */
    delete<T extends FormTypeDeleteArgs>(
      args: SelectSubset<T, FormTypeDeleteArgs<ExtArgs>>
    ): Prisma__FormTypeClient<
      $Result.GetResult<Prisma.$FormTypePayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one FormType.
     * @param {FormTypeUpdateArgs} args - Arguments to update one FormType.
     * @example
     * // Update one FormType
     * const formType = await prisma.formType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FormTypeUpdateArgs>(
      args: SelectSubset<T, FormTypeUpdateArgs<ExtArgs>>
    ): Prisma__FormTypeClient<
      $Result.GetResult<Prisma.$FormTypePayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more FormTypes.
     * @param {FormTypeDeleteManyArgs} args - Arguments to filter FormTypes to delete.
     * @example
     * // Delete a few FormTypes
     * const { count } = await prisma.formType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FormTypeDeleteManyArgs>(
      args?: SelectSubset<T, FormTypeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more FormTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormTypes
     * const formType = await prisma.formType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FormTypeUpdateManyArgs>(
      args: SelectSubset<T, FormTypeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one FormType.
     * @param {FormTypeUpsertArgs} args - Arguments to update or create a FormType.
     * @example
     * // Update or create a FormType
     * const formType = await prisma.formType.upsert({
     *   create: {
     *     // ... data to create a FormType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormType we want to update
     *   }
     * })
     */
    upsert<T extends FormTypeUpsertArgs>(
      args: SelectSubset<T, FormTypeUpsertArgs<ExtArgs>>
    ): Prisma__FormTypeClient<
      $Result.GetResult<Prisma.$FormTypePayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of FormTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTypeCountArgs} args - Arguments to filter FormTypes to count.
     * @example
     * // Count the number of FormTypes
     * const count = await prisma.formType.count({
     *   where: {
     *     // ... the filter for the FormTypes we want to count
     *   }
     * })
     **/
    count<T extends FormTypeCountArgs>(
      args?: Subset<T, FormTypeCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormTypeCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a FormType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FormTypeAggregateArgs>(
      args: Subset<T, FormTypeAggregateArgs>
    ): Prisma.PrismaPromise<GetFormTypeAggregateType<T>>;

    /**
     * Group by FormType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FormTypeGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormTypeGroupByArgs['orderBy'] }
        : { orderBy?: FormTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, FormTypeGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetFormTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the FormType model
     */
    readonly fields: FormTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FormType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormTypeClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    variantLinks<T extends FormType$variantLinksArgs<ExtArgs> = {}>(
      args?: Subset<T, FormType$variantLinksArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$FormTypeVariantPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    serials<T extends FormType$serialsArgs<ExtArgs> = {}>(
      args?: Subset<T, FormType$serialsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$FormSerialPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the FormType model
   */
  interface FormTypeFieldRefs {
    readonly id: FieldRef<'FormType', 'String'>;
    readonly name: FieldRef<'FormType', 'String'>;
    readonly description: FieldRef<'FormType', 'String'>;
    readonly active: FieldRef<'FormType', 'Boolean'>;
    readonly createdAt: FieldRef<'FormType', 'DateTime'>;
    readonly updatedAt: FieldRef<'FormType', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * FormType findUnique
   */
  export type FormTypeFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormType
     */
    select?: FormTypeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTypeInclude<ExtArgs> | null;
    /**
     * Filter, which FormType to fetch.
     */
    where: FormTypeWhereUniqueInput;
  };

  /**
   * FormType findUniqueOrThrow
   */
  export type FormTypeFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormType
     */
    select?: FormTypeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTypeInclude<ExtArgs> | null;
    /**
     * Filter, which FormType to fetch.
     */
    where: FormTypeWhereUniqueInput;
  };

  /**
   * FormType findFirst
   */
  export type FormTypeFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormType
     */
    select?: FormTypeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTypeInclude<ExtArgs> | null;
    /**
     * Filter, which FormType to fetch.
     */
    where?: FormTypeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FormTypes to fetch.
     */
    orderBy?: FormTypeOrderByWithRelationInput | FormTypeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FormTypes.
     */
    cursor?: FormTypeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FormTypes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FormTypes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FormTypes.
     */
    distinct?: FormTypeScalarFieldEnum | FormTypeScalarFieldEnum[];
  };

  /**
   * FormType findFirstOrThrow
   */
  export type FormTypeFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormType
     */
    select?: FormTypeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTypeInclude<ExtArgs> | null;
    /**
     * Filter, which FormType to fetch.
     */
    where?: FormTypeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FormTypes to fetch.
     */
    orderBy?: FormTypeOrderByWithRelationInput | FormTypeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FormTypes.
     */
    cursor?: FormTypeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FormTypes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FormTypes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FormTypes.
     */
    distinct?: FormTypeScalarFieldEnum | FormTypeScalarFieldEnum[];
  };

  /**
   * FormType findMany
   */
  export type FormTypeFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormType
     */
    select?: FormTypeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTypeInclude<ExtArgs> | null;
    /**
     * Filter, which FormTypes to fetch.
     */
    where?: FormTypeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FormTypes to fetch.
     */
    orderBy?: FormTypeOrderByWithRelationInput | FormTypeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing FormTypes.
     */
    cursor?: FormTypeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FormTypes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FormTypes.
     */
    skip?: number;
    distinct?: FormTypeScalarFieldEnum | FormTypeScalarFieldEnum[];
  };

  /**
   * FormType create
   */
  export type FormTypeCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormType
     */
    select?: FormTypeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTypeInclude<ExtArgs> | null;
    /**
     * The data needed to create a FormType.
     */
    data: XOR<FormTypeCreateInput, FormTypeUncheckedCreateInput>;
  };

  /**
   * FormType createMany
   */
  export type FormTypeCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many FormTypes.
     */
    data: FormTypeCreateManyInput | FormTypeCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * FormType createManyAndReturn
   */
  export type FormTypeCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormType
     */
    select?: FormTypeSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many FormTypes.
     */
    data: FormTypeCreateManyInput | FormTypeCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * FormType update
   */
  export type FormTypeUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormType
     */
    select?: FormTypeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTypeInclude<ExtArgs> | null;
    /**
     * The data needed to update a FormType.
     */
    data: XOR<FormTypeUpdateInput, FormTypeUncheckedUpdateInput>;
    /**
     * Choose, which FormType to update.
     */
    where: FormTypeWhereUniqueInput;
  };

  /**
   * FormType updateMany
   */
  export type FormTypeUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update FormTypes.
     */
    data: XOR<FormTypeUpdateManyMutationInput, FormTypeUncheckedUpdateManyInput>;
    /**
     * Filter which FormTypes to update
     */
    where?: FormTypeWhereInput;
  };

  /**
   * FormType upsert
   */
  export type FormTypeUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormType
     */
    select?: FormTypeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTypeInclude<ExtArgs> | null;
    /**
     * The filter to search for the FormType to update in case it exists.
     */
    where: FormTypeWhereUniqueInput;
    /**
     * In case the FormType found by the `where` argument doesn't exist, create a new FormType with this data.
     */
    create: XOR<FormTypeCreateInput, FormTypeUncheckedCreateInput>;
    /**
     * In case the FormType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormTypeUpdateInput, FormTypeUncheckedUpdateInput>;
  };

  /**
   * FormType delete
   */
  export type FormTypeDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormType
     */
    select?: FormTypeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTypeInclude<ExtArgs> | null;
    /**
     * Filter which FormType to delete.
     */
    where: FormTypeWhereUniqueInput;
  };

  /**
   * FormType deleteMany
   */
  export type FormTypeDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FormTypes to delete
     */
    where?: FormTypeWhereInput;
  };

  /**
   * FormType.variantLinks
   */
  export type FormType$variantLinksArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormTypeVariant
     */
    select?: FormTypeVariantSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTypeVariantInclude<ExtArgs> | null;
    where?: FormTypeVariantWhereInput;
    orderBy?: FormTypeVariantOrderByWithRelationInput | FormTypeVariantOrderByWithRelationInput[];
    cursor?: FormTypeVariantWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: FormTypeVariantScalarFieldEnum | FormTypeVariantScalarFieldEnum[];
  };

  /**
   * FormType.serials
   */
  export type FormType$serialsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormSerial
     */
    select?: FormSerialSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSerialInclude<ExtArgs> | null;
    where?: FormSerialWhereInput;
    orderBy?: FormSerialOrderByWithRelationInput | FormSerialOrderByWithRelationInput[];
    cursor?: FormSerialWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: FormSerialScalarFieldEnum | FormSerialScalarFieldEnum[];
  };

  /**
   * FormType without action
   */
  export type FormTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormType
     */
    select?: FormTypeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTypeInclude<ExtArgs> | null;
  };

  /**
   * Model FormTypeVariant
   */

  export type AggregateFormTypeVariant = {
    _count: FormTypeVariantCountAggregateOutputType | null;
    _min: FormTypeVariantMinAggregateOutputType | null;
    _max: FormTypeVariantMaxAggregateOutputType | null;
  };

  export type FormTypeVariantMinAggregateOutputType = {
    id: string | null;
    formTypeId: string | null;
    serviceVariantId: string | null;
    createdAt: Date | null;
  };

  export type FormTypeVariantMaxAggregateOutputType = {
    id: string | null;
    formTypeId: string | null;
    serviceVariantId: string | null;
    createdAt: Date | null;
  };

  export type FormTypeVariantCountAggregateOutputType = {
    id: number;
    formTypeId: number;
    serviceVariantId: number;
    createdAt: number;
    _all: number;
  };

  export type FormTypeVariantMinAggregateInputType = {
    id?: true;
    formTypeId?: true;
    serviceVariantId?: true;
    createdAt?: true;
  };

  export type FormTypeVariantMaxAggregateInputType = {
    id?: true;
    formTypeId?: true;
    serviceVariantId?: true;
    createdAt?: true;
  };

  export type FormTypeVariantCountAggregateInputType = {
    id?: true;
    formTypeId?: true;
    serviceVariantId?: true;
    createdAt?: true;
    _all?: true;
  };

  export type FormTypeVariantAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FormTypeVariant to aggregate.
     */
    where?: FormTypeVariantWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FormTypeVariants to fetch.
     */
    orderBy?: FormTypeVariantOrderByWithRelationInput | FormTypeVariantOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: FormTypeVariantWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FormTypeVariants from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FormTypeVariants.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned FormTypeVariants
     **/
    _count?: true | FormTypeVariantCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FormTypeVariantMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FormTypeVariantMaxAggregateInputType;
  };

  export type GetFormTypeVariantAggregateType<T extends FormTypeVariantAggregateArgs> = {
    [P in keyof T & keyof AggregateFormTypeVariant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormTypeVariant[P]>
      : GetScalarType<T[P], AggregateFormTypeVariant[P]>;
  };

  export type FormTypeVariantGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FormTypeVariantWhereInput;
    orderBy?:
      | FormTypeVariantOrderByWithAggregationInput
      | FormTypeVariantOrderByWithAggregationInput[];
    by: FormTypeVariantScalarFieldEnum[] | FormTypeVariantScalarFieldEnum;
    having?: FormTypeVariantScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: FormTypeVariantCountAggregateInputType | true;
    _min?: FormTypeVariantMinAggregateInputType;
    _max?: FormTypeVariantMaxAggregateInputType;
  };

  export type FormTypeVariantGroupByOutputType = {
    id: string;
    formTypeId: string;
    serviceVariantId: string;
    createdAt: Date;
    _count: FormTypeVariantCountAggregateOutputType | null;
    _min: FormTypeVariantMinAggregateOutputType | null;
    _max: FormTypeVariantMaxAggregateOutputType | null;
  };

  type GetFormTypeVariantGroupByPayload<T extends FormTypeVariantGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<FormTypeVariantGroupByOutputType, T['by']> & {
          [P in keyof T & keyof FormTypeVariantGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormTypeVariantGroupByOutputType[P]>
            : GetScalarType<T[P], FormTypeVariantGroupByOutputType[P]>;
        }
      >
    >;

  export type FormTypeVariantSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      formTypeId?: boolean;
      serviceVariantId?: boolean;
      createdAt?: boolean;
      formType?: boolean | FormTypeDefaultArgs<ExtArgs>;
      serviceVariant?: boolean | ServiceVariantDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['formTypeVariant']
  >;

  export type FormTypeVariantSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      formTypeId?: boolean;
      serviceVariantId?: boolean;
      createdAt?: boolean;
      formType?: boolean | FormTypeDefaultArgs<ExtArgs>;
      serviceVariant?: boolean | ServiceVariantDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['formTypeVariant']
  >;

  export type FormTypeVariantSelectScalar = {
    id?: boolean;
    formTypeId?: boolean;
    serviceVariantId?: boolean;
    createdAt?: boolean;
  };

  export type FormTypeVariantInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    formType?: boolean | FormTypeDefaultArgs<ExtArgs>;
    serviceVariant?: boolean | ServiceVariantDefaultArgs<ExtArgs>;
  };
  export type FormTypeVariantIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    formType?: boolean | FormTypeDefaultArgs<ExtArgs>;
    serviceVariant?: boolean | ServiceVariantDefaultArgs<ExtArgs>;
  };

  export type $FormTypeVariantPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'FormTypeVariant';
    objects: {
      formType: Prisma.$FormTypePayload<ExtArgs>;
      serviceVariant: Prisma.$ServiceVariantPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        formTypeId: string;
        serviceVariantId: string;
        createdAt: Date;
      },
      ExtArgs['result']['formTypeVariant']
    >;
    composites: {};
  };

  type FormTypeVariantGetPayload<
    S extends boolean | null | undefined | FormTypeVariantDefaultArgs,
  > = $Result.GetResult<Prisma.$FormTypeVariantPayload, S>;

  type FormTypeVariantCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<FormTypeVariantFindManyArgs, 'select' | 'include' | 'distinct'> & {
    select?: FormTypeVariantCountAggregateInputType | true;
  };

  export interface FormTypeVariantDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['FormTypeVariant'];
      meta: { name: 'FormTypeVariant' };
    };
    /**
     * Find zero or one FormTypeVariant that matches the filter.
     * @param {FormTypeVariantFindUniqueArgs} args - Arguments to find a FormTypeVariant
     * @example
     * // Get one FormTypeVariant
     * const formTypeVariant = await prisma.formTypeVariant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FormTypeVariantFindUniqueArgs>(
      args: SelectSubset<T, FormTypeVariantFindUniqueArgs<ExtArgs>>
    ): Prisma__FormTypeVariantClient<
      $Result.GetResult<Prisma.$FormTypeVariantPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one FormTypeVariant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FormTypeVariantFindUniqueOrThrowArgs} args - Arguments to find a FormTypeVariant
     * @example
     * // Get one FormTypeVariant
     * const formTypeVariant = await prisma.formTypeVariant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FormTypeVariantFindUniqueOrThrowArgs>(
      args: SelectSubset<T, FormTypeVariantFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FormTypeVariantClient<
      $Result.GetResult<Prisma.$FormTypeVariantPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first FormTypeVariant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTypeVariantFindFirstArgs} args - Arguments to find a FormTypeVariant
     * @example
     * // Get one FormTypeVariant
     * const formTypeVariant = await prisma.formTypeVariant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FormTypeVariantFindFirstArgs>(
      args?: SelectSubset<T, FormTypeVariantFindFirstArgs<ExtArgs>>
    ): Prisma__FormTypeVariantClient<
      $Result.GetResult<Prisma.$FormTypeVariantPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first FormTypeVariant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTypeVariantFindFirstOrThrowArgs} args - Arguments to find a FormTypeVariant
     * @example
     * // Get one FormTypeVariant
     * const formTypeVariant = await prisma.formTypeVariant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FormTypeVariantFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FormTypeVariantFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FormTypeVariantClient<
      $Result.GetResult<Prisma.$FormTypeVariantPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more FormTypeVariants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTypeVariantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormTypeVariants
     * const formTypeVariants = await prisma.formTypeVariant.findMany()
     *
     * // Get first 10 FormTypeVariants
     * const formTypeVariants = await prisma.formTypeVariant.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const formTypeVariantWithIdOnly = await prisma.formTypeVariant.findMany({ select: { id: true } })
     *
     */
    findMany<T extends FormTypeVariantFindManyArgs>(
      args?: SelectSubset<T, FormTypeVariantFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$FormTypeVariantPayload<ExtArgs>, T, 'findMany'>
    >;

    /**
     * Create a FormTypeVariant.
     * @param {FormTypeVariantCreateArgs} args - Arguments to create a FormTypeVariant.
     * @example
     * // Create one FormTypeVariant
     * const FormTypeVariant = await prisma.formTypeVariant.create({
     *   data: {
     *     // ... data to create a FormTypeVariant
     *   }
     * })
     *
     */
    create<T extends FormTypeVariantCreateArgs>(
      args: SelectSubset<T, FormTypeVariantCreateArgs<ExtArgs>>
    ): Prisma__FormTypeVariantClient<
      $Result.GetResult<Prisma.$FormTypeVariantPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many FormTypeVariants.
     * @param {FormTypeVariantCreateManyArgs} args - Arguments to create many FormTypeVariants.
     * @example
     * // Create many FormTypeVariants
     * const formTypeVariant = await prisma.formTypeVariant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FormTypeVariantCreateManyArgs>(
      args?: SelectSubset<T, FormTypeVariantCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many FormTypeVariants and returns the data saved in the database.
     * @param {FormTypeVariantCreateManyAndReturnArgs} args - Arguments to create many FormTypeVariants.
     * @example
     * // Create many FormTypeVariants
     * const formTypeVariant = await prisma.formTypeVariant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many FormTypeVariants and only return the `id`
     * const formTypeVariantWithIdOnly = await prisma.formTypeVariant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends FormTypeVariantCreateManyAndReturnArgs>(
      args?: SelectSubset<T, FormTypeVariantCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$FormTypeVariantPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a FormTypeVariant.
     * @param {FormTypeVariantDeleteArgs} args - Arguments to delete one FormTypeVariant.
     * @example
     * // Delete one FormTypeVariant
     * const FormTypeVariant = await prisma.formTypeVariant.delete({
     *   where: {
     *     // ... filter to delete one FormTypeVariant
     *   }
     * })
     *
     */
    delete<T extends FormTypeVariantDeleteArgs>(
      args: SelectSubset<T, FormTypeVariantDeleteArgs<ExtArgs>>
    ): Prisma__FormTypeVariantClient<
      $Result.GetResult<Prisma.$FormTypeVariantPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one FormTypeVariant.
     * @param {FormTypeVariantUpdateArgs} args - Arguments to update one FormTypeVariant.
     * @example
     * // Update one FormTypeVariant
     * const formTypeVariant = await prisma.formTypeVariant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FormTypeVariantUpdateArgs>(
      args: SelectSubset<T, FormTypeVariantUpdateArgs<ExtArgs>>
    ): Prisma__FormTypeVariantClient<
      $Result.GetResult<Prisma.$FormTypeVariantPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more FormTypeVariants.
     * @param {FormTypeVariantDeleteManyArgs} args - Arguments to filter FormTypeVariants to delete.
     * @example
     * // Delete a few FormTypeVariants
     * const { count } = await prisma.formTypeVariant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FormTypeVariantDeleteManyArgs>(
      args?: SelectSubset<T, FormTypeVariantDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more FormTypeVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTypeVariantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormTypeVariants
     * const formTypeVariant = await prisma.formTypeVariant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FormTypeVariantUpdateManyArgs>(
      args: SelectSubset<T, FormTypeVariantUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one FormTypeVariant.
     * @param {FormTypeVariantUpsertArgs} args - Arguments to update or create a FormTypeVariant.
     * @example
     * // Update or create a FormTypeVariant
     * const formTypeVariant = await prisma.formTypeVariant.upsert({
     *   create: {
     *     // ... data to create a FormTypeVariant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormTypeVariant we want to update
     *   }
     * })
     */
    upsert<T extends FormTypeVariantUpsertArgs>(
      args: SelectSubset<T, FormTypeVariantUpsertArgs<ExtArgs>>
    ): Prisma__FormTypeVariantClient<
      $Result.GetResult<Prisma.$FormTypeVariantPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of FormTypeVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTypeVariantCountArgs} args - Arguments to filter FormTypeVariants to count.
     * @example
     * // Count the number of FormTypeVariants
     * const count = await prisma.formTypeVariant.count({
     *   where: {
     *     // ... the filter for the FormTypeVariants we want to count
     *   }
     * })
     **/
    count<T extends FormTypeVariantCountArgs>(
      args?: Subset<T, FormTypeVariantCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormTypeVariantCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a FormTypeVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTypeVariantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FormTypeVariantAggregateArgs>(
      args: Subset<T, FormTypeVariantAggregateArgs>
    ): Prisma.PrismaPromise<GetFormTypeVariantAggregateType<T>>;

    /**
     * Group by FormTypeVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTypeVariantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FormTypeVariantGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormTypeVariantGroupByArgs['orderBy'] }
        : { orderBy?: FormTypeVariantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, FormTypeVariantGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetFormTypeVariantGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the FormTypeVariant model
     */
    readonly fields: FormTypeVariantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FormTypeVariant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormTypeVariantClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    formType<T extends FormTypeDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, FormTypeDefaultArgs<ExtArgs>>
    ): Prisma__FormTypeClient<
      $Result.GetResult<Prisma.$FormTypePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    serviceVariant<T extends ServiceVariantDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ServiceVariantDefaultArgs<ExtArgs>>
    ): Prisma__ServiceVariantClient<
      $Result.GetResult<Prisma.$ServiceVariantPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the FormTypeVariant model
   */
  interface FormTypeVariantFieldRefs {
    readonly id: FieldRef<'FormTypeVariant', 'String'>;
    readonly formTypeId: FieldRef<'FormTypeVariant', 'String'>;
    readonly serviceVariantId: FieldRef<'FormTypeVariant', 'String'>;
    readonly createdAt: FieldRef<'FormTypeVariant', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * FormTypeVariant findUnique
   */
  export type FormTypeVariantFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormTypeVariant
     */
    select?: FormTypeVariantSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTypeVariantInclude<ExtArgs> | null;
    /**
     * Filter, which FormTypeVariant to fetch.
     */
    where: FormTypeVariantWhereUniqueInput;
  };

  /**
   * FormTypeVariant findUniqueOrThrow
   */
  export type FormTypeVariantFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormTypeVariant
     */
    select?: FormTypeVariantSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTypeVariantInclude<ExtArgs> | null;
    /**
     * Filter, which FormTypeVariant to fetch.
     */
    where: FormTypeVariantWhereUniqueInput;
  };

  /**
   * FormTypeVariant findFirst
   */
  export type FormTypeVariantFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormTypeVariant
     */
    select?: FormTypeVariantSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTypeVariantInclude<ExtArgs> | null;
    /**
     * Filter, which FormTypeVariant to fetch.
     */
    where?: FormTypeVariantWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FormTypeVariants to fetch.
     */
    orderBy?: FormTypeVariantOrderByWithRelationInput | FormTypeVariantOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FormTypeVariants.
     */
    cursor?: FormTypeVariantWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FormTypeVariants from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FormTypeVariants.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FormTypeVariants.
     */
    distinct?: FormTypeVariantScalarFieldEnum | FormTypeVariantScalarFieldEnum[];
  };

  /**
   * FormTypeVariant findFirstOrThrow
   */
  export type FormTypeVariantFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormTypeVariant
     */
    select?: FormTypeVariantSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTypeVariantInclude<ExtArgs> | null;
    /**
     * Filter, which FormTypeVariant to fetch.
     */
    where?: FormTypeVariantWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FormTypeVariants to fetch.
     */
    orderBy?: FormTypeVariantOrderByWithRelationInput | FormTypeVariantOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FormTypeVariants.
     */
    cursor?: FormTypeVariantWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FormTypeVariants from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FormTypeVariants.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FormTypeVariants.
     */
    distinct?: FormTypeVariantScalarFieldEnum | FormTypeVariantScalarFieldEnum[];
  };

  /**
   * FormTypeVariant findMany
   */
  export type FormTypeVariantFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormTypeVariant
     */
    select?: FormTypeVariantSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTypeVariantInclude<ExtArgs> | null;
    /**
     * Filter, which FormTypeVariants to fetch.
     */
    where?: FormTypeVariantWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FormTypeVariants to fetch.
     */
    orderBy?: FormTypeVariantOrderByWithRelationInput | FormTypeVariantOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing FormTypeVariants.
     */
    cursor?: FormTypeVariantWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FormTypeVariants from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FormTypeVariants.
     */
    skip?: number;
    distinct?: FormTypeVariantScalarFieldEnum | FormTypeVariantScalarFieldEnum[];
  };

  /**
   * FormTypeVariant create
   */
  export type FormTypeVariantCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormTypeVariant
     */
    select?: FormTypeVariantSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTypeVariantInclude<ExtArgs> | null;
    /**
     * The data needed to create a FormTypeVariant.
     */
    data: XOR<FormTypeVariantCreateInput, FormTypeVariantUncheckedCreateInput>;
  };

  /**
   * FormTypeVariant createMany
   */
  export type FormTypeVariantCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many FormTypeVariants.
     */
    data: FormTypeVariantCreateManyInput | FormTypeVariantCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * FormTypeVariant createManyAndReturn
   */
  export type FormTypeVariantCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormTypeVariant
     */
    select?: FormTypeVariantSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many FormTypeVariants.
     */
    data: FormTypeVariantCreateManyInput | FormTypeVariantCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTypeVariantIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * FormTypeVariant update
   */
  export type FormTypeVariantUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormTypeVariant
     */
    select?: FormTypeVariantSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTypeVariantInclude<ExtArgs> | null;
    /**
     * The data needed to update a FormTypeVariant.
     */
    data: XOR<FormTypeVariantUpdateInput, FormTypeVariantUncheckedUpdateInput>;
    /**
     * Choose, which FormTypeVariant to update.
     */
    where: FormTypeVariantWhereUniqueInput;
  };

  /**
   * FormTypeVariant updateMany
   */
  export type FormTypeVariantUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update FormTypeVariants.
     */
    data: XOR<FormTypeVariantUpdateManyMutationInput, FormTypeVariantUncheckedUpdateManyInput>;
    /**
     * Filter which FormTypeVariants to update
     */
    where?: FormTypeVariantWhereInput;
  };

  /**
   * FormTypeVariant upsert
   */
  export type FormTypeVariantUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormTypeVariant
     */
    select?: FormTypeVariantSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTypeVariantInclude<ExtArgs> | null;
    /**
     * The filter to search for the FormTypeVariant to update in case it exists.
     */
    where: FormTypeVariantWhereUniqueInput;
    /**
     * In case the FormTypeVariant found by the `where` argument doesn't exist, create a new FormTypeVariant with this data.
     */
    create: XOR<FormTypeVariantCreateInput, FormTypeVariantUncheckedCreateInput>;
    /**
     * In case the FormTypeVariant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormTypeVariantUpdateInput, FormTypeVariantUncheckedUpdateInput>;
  };

  /**
   * FormTypeVariant delete
   */
  export type FormTypeVariantDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormTypeVariant
     */
    select?: FormTypeVariantSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTypeVariantInclude<ExtArgs> | null;
    /**
     * Filter which FormTypeVariant to delete.
     */
    where: FormTypeVariantWhereUniqueInput;
  };

  /**
   * FormTypeVariant deleteMany
   */
  export type FormTypeVariantDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FormTypeVariants to delete
     */
    where?: FormTypeVariantWhereInput;
  };

  /**
   * FormTypeVariant without action
   */
  export type FormTypeVariantDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormTypeVariant
     */
    select?: FormTypeVariantSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTypeVariantInclude<ExtArgs> | null;
  };

  /**
   * Model FormSerial
   */

  export type AggregateFormSerial = {
    _count: FormSerialCountAggregateOutputType | null;
    _min: FormSerialMinAggregateOutputType | null;
    _max: FormSerialMaxAggregateOutputType | null;
  };

  export type FormSerialMinAggregateOutputType = {
    id: string | null;
    formTypeId: string | null;
    serialNumber: string | null;
    orderId: string | null;
    consumed: boolean | null;
    consumedAt: Date | null;
    addedByAdminId: string | null;
    consumedByAdminId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type FormSerialMaxAggregateOutputType = {
    id: string | null;
    formTypeId: string | null;
    serialNumber: string | null;
    orderId: string | null;
    consumed: boolean | null;
    consumedAt: Date | null;
    addedByAdminId: string | null;
    consumedByAdminId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type FormSerialCountAggregateOutputType = {
    id: number;
    formTypeId: number;
    serialNumber: number;
    orderId: number;
    consumed: number;
    consumedAt: number;
    addedByAdminId: number;
    consumedByAdminId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type FormSerialMinAggregateInputType = {
    id?: true;
    formTypeId?: true;
    serialNumber?: true;
    orderId?: true;
    consumed?: true;
    consumedAt?: true;
    addedByAdminId?: true;
    consumedByAdminId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type FormSerialMaxAggregateInputType = {
    id?: true;
    formTypeId?: true;
    serialNumber?: true;
    orderId?: true;
    consumed?: true;
    consumedAt?: true;
    addedByAdminId?: true;
    consumedByAdminId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type FormSerialCountAggregateInputType = {
    id?: true;
    formTypeId?: true;
    serialNumber?: true;
    orderId?: true;
    consumed?: true;
    consumedAt?: true;
    addedByAdminId?: true;
    consumedByAdminId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type FormSerialAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FormSerial to aggregate.
     */
    where?: FormSerialWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FormSerials to fetch.
     */
    orderBy?: FormSerialOrderByWithRelationInput | FormSerialOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: FormSerialWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FormSerials from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FormSerials.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned FormSerials
     **/
    _count?: true | FormSerialCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FormSerialMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FormSerialMaxAggregateInputType;
  };

  export type GetFormSerialAggregateType<T extends FormSerialAggregateArgs> = {
    [P in keyof T & keyof AggregateFormSerial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormSerial[P]>
      : GetScalarType<T[P], AggregateFormSerial[P]>;
  };

  export type FormSerialGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FormSerialWhereInput;
    orderBy?: FormSerialOrderByWithAggregationInput | FormSerialOrderByWithAggregationInput[];
    by: FormSerialScalarFieldEnum[] | FormSerialScalarFieldEnum;
    having?: FormSerialScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: FormSerialCountAggregateInputType | true;
    _min?: FormSerialMinAggregateInputType;
    _max?: FormSerialMaxAggregateInputType;
  };

  export type FormSerialGroupByOutputType = {
    id: string;
    formTypeId: string;
    serialNumber: string;
    orderId: string | null;
    consumed: boolean;
    consumedAt: Date | null;
    addedByAdminId: string | null;
    consumedByAdminId: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: FormSerialCountAggregateOutputType | null;
    _min: FormSerialMinAggregateOutputType | null;
    _max: FormSerialMaxAggregateOutputType | null;
  };

  type GetFormSerialGroupByPayload<T extends FormSerialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormSerialGroupByOutputType, T['by']> & {
        [P in keyof T & keyof FormSerialGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], FormSerialGroupByOutputType[P]>
          : GetScalarType<T[P], FormSerialGroupByOutputType[P]>;
      }
    >
  >;

  export type FormSerialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        formTypeId?: boolean;
        serialNumber?: boolean;
        orderId?: boolean;
        consumed?: boolean;
        consumedAt?: boolean;
        addedByAdminId?: boolean;
        consumedByAdminId?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        formType?: boolean | FormTypeDefaultArgs<ExtArgs>;
        order?: boolean | FormSerial$orderArgs<ExtArgs>;
        addedByAdmin?: boolean | FormSerial$addedByAdminArgs<ExtArgs>;
        consumedByAdmin?: boolean | FormSerial$consumedByAdminArgs<ExtArgs>;
      },
      ExtArgs['result']['formSerial']
    >;

  export type FormSerialSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      formTypeId?: boolean;
      serialNumber?: boolean;
      orderId?: boolean;
      consumed?: boolean;
      consumedAt?: boolean;
      addedByAdminId?: boolean;
      consumedByAdminId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      formType?: boolean | FormTypeDefaultArgs<ExtArgs>;
      order?: boolean | FormSerial$orderArgs<ExtArgs>;
      addedByAdmin?: boolean | FormSerial$addedByAdminArgs<ExtArgs>;
      consumedByAdmin?: boolean | FormSerial$consumedByAdminArgs<ExtArgs>;
    },
    ExtArgs['result']['formSerial']
  >;

  export type FormSerialSelectScalar = {
    id?: boolean;
    formTypeId?: boolean;
    serialNumber?: boolean;
    orderId?: boolean;
    consumed?: boolean;
    consumedAt?: boolean;
    addedByAdminId?: boolean;
    consumedByAdminId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type FormSerialInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    formType?: boolean | FormTypeDefaultArgs<ExtArgs>;
    order?: boolean | FormSerial$orderArgs<ExtArgs>;
    addedByAdmin?: boolean | FormSerial$addedByAdminArgs<ExtArgs>;
    consumedByAdmin?: boolean | FormSerial$consumedByAdminArgs<ExtArgs>;
  };
  export type FormSerialIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    formType?: boolean | FormTypeDefaultArgs<ExtArgs>;
    order?: boolean | FormSerial$orderArgs<ExtArgs>;
    addedByAdmin?: boolean | FormSerial$addedByAdminArgs<ExtArgs>;
    consumedByAdmin?: boolean | FormSerial$consumedByAdminArgs<ExtArgs>;
  };

  export type $FormSerialPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'FormSerial';
    objects: {
      formType: Prisma.$FormTypePayload<ExtArgs>;
      order: Prisma.$OrderPayload<ExtArgs> | null;
      addedByAdmin: Prisma.$UserPayload<ExtArgs> | null;
      consumedByAdmin: Prisma.$UserPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        formTypeId: string;
        serialNumber: string;
        orderId: string | null;
        consumed: boolean;
        consumedAt: Date | null;
        addedByAdminId: string | null;
        consumedByAdminId: string | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['formSerial']
    >;
    composites: {};
  };

  type FormSerialGetPayload<S extends boolean | null | undefined | FormSerialDefaultArgs> =
    $Result.GetResult<Prisma.$FormSerialPayload, S>;

  type FormSerialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FormSerialFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FormSerialCountAggregateInputType | true;
    };

  export interface FormSerialDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['FormSerial'];
      meta: { name: 'FormSerial' };
    };
    /**
     * Find zero or one FormSerial that matches the filter.
     * @param {FormSerialFindUniqueArgs} args - Arguments to find a FormSerial
     * @example
     * // Get one FormSerial
     * const formSerial = await prisma.formSerial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FormSerialFindUniqueArgs>(
      args: SelectSubset<T, FormSerialFindUniqueArgs<ExtArgs>>
    ): Prisma__FormSerialClient<
      $Result.GetResult<Prisma.$FormSerialPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one FormSerial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FormSerialFindUniqueOrThrowArgs} args - Arguments to find a FormSerial
     * @example
     * // Get one FormSerial
     * const formSerial = await prisma.formSerial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FormSerialFindUniqueOrThrowArgs>(
      args: SelectSubset<T, FormSerialFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FormSerialClient<
      $Result.GetResult<Prisma.$FormSerialPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first FormSerial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSerialFindFirstArgs} args - Arguments to find a FormSerial
     * @example
     * // Get one FormSerial
     * const formSerial = await prisma.formSerial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FormSerialFindFirstArgs>(
      args?: SelectSubset<T, FormSerialFindFirstArgs<ExtArgs>>
    ): Prisma__FormSerialClient<
      $Result.GetResult<Prisma.$FormSerialPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first FormSerial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSerialFindFirstOrThrowArgs} args - Arguments to find a FormSerial
     * @example
     * // Get one FormSerial
     * const formSerial = await prisma.formSerial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FormSerialFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FormSerialFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FormSerialClient<
      $Result.GetResult<Prisma.$FormSerialPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more FormSerials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSerialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormSerials
     * const formSerials = await prisma.formSerial.findMany()
     *
     * // Get first 10 FormSerials
     * const formSerials = await prisma.formSerial.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const formSerialWithIdOnly = await prisma.formSerial.findMany({ select: { id: true } })
     *
     */
    findMany<T extends FormSerialFindManyArgs>(
      args?: SelectSubset<T, FormSerialFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormSerialPayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a FormSerial.
     * @param {FormSerialCreateArgs} args - Arguments to create a FormSerial.
     * @example
     * // Create one FormSerial
     * const FormSerial = await prisma.formSerial.create({
     *   data: {
     *     // ... data to create a FormSerial
     *   }
     * })
     *
     */
    create<T extends FormSerialCreateArgs>(
      args: SelectSubset<T, FormSerialCreateArgs<ExtArgs>>
    ): Prisma__FormSerialClient<
      $Result.GetResult<Prisma.$FormSerialPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many FormSerials.
     * @param {FormSerialCreateManyArgs} args - Arguments to create many FormSerials.
     * @example
     * // Create many FormSerials
     * const formSerial = await prisma.formSerial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FormSerialCreateManyArgs>(
      args?: SelectSubset<T, FormSerialCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many FormSerials and returns the data saved in the database.
     * @param {FormSerialCreateManyAndReturnArgs} args - Arguments to create many FormSerials.
     * @example
     * // Create many FormSerials
     * const formSerial = await prisma.formSerial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many FormSerials and only return the `id`
     * const formSerialWithIdOnly = await prisma.formSerial.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends FormSerialCreateManyAndReturnArgs>(
      args?: SelectSubset<T, FormSerialCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$FormSerialPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a FormSerial.
     * @param {FormSerialDeleteArgs} args - Arguments to delete one FormSerial.
     * @example
     * // Delete one FormSerial
     * const FormSerial = await prisma.formSerial.delete({
     *   where: {
     *     // ... filter to delete one FormSerial
     *   }
     * })
     *
     */
    delete<T extends FormSerialDeleteArgs>(
      args: SelectSubset<T, FormSerialDeleteArgs<ExtArgs>>
    ): Prisma__FormSerialClient<
      $Result.GetResult<Prisma.$FormSerialPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one FormSerial.
     * @param {FormSerialUpdateArgs} args - Arguments to update one FormSerial.
     * @example
     * // Update one FormSerial
     * const formSerial = await prisma.formSerial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FormSerialUpdateArgs>(
      args: SelectSubset<T, FormSerialUpdateArgs<ExtArgs>>
    ): Prisma__FormSerialClient<
      $Result.GetResult<Prisma.$FormSerialPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more FormSerials.
     * @param {FormSerialDeleteManyArgs} args - Arguments to filter FormSerials to delete.
     * @example
     * // Delete a few FormSerials
     * const { count } = await prisma.formSerial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FormSerialDeleteManyArgs>(
      args?: SelectSubset<T, FormSerialDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more FormSerials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSerialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormSerials
     * const formSerial = await prisma.formSerial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FormSerialUpdateManyArgs>(
      args: SelectSubset<T, FormSerialUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one FormSerial.
     * @param {FormSerialUpsertArgs} args - Arguments to update or create a FormSerial.
     * @example
     * // Update or create a FormSerial
     * const formSerial = await prisma.formSerial.upsert({
     *   create: {
     *     // ... data to create a FormSerial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormSerial we want to update
     *   }
     * })
     */
    upsert<T extends FormSerialUpsertArgs>(
      args: SelectSubset<T, FormSerialUpsertArgs<ExtArgs>>
    ): Prisma__FormSerialClient<
      $Result.GetResult<Prisma.$FormSerialPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of FormSerials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSerialCountArgs} args - Arguments to filter FormSerials to count.
     * @example
     * // Count the number of FormSerials
     * const count = await prisma.formSerial.count({
     *   where: {
     *     // ... the filter for the FormSerials we want to count
     *   }
     * })
     **/
    count<T extends FormSerialCountArgs>(
      args?: Subset<T, FormSerialCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormSerialCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a FormSerial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSerialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FormSerialAggregateArgs>(
      args: Subset<T, FormSerialAggregateArgs>
    ): Prisma.PrismaPromise<GetFormSerialAggregateType<T>>;

    /**
     * Group by FormSerial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSerialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FormSerialGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormSerialGroupByArgs['orderBy'] }
        : { orderBy?: FormSerialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, FormSerialGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetFormSerialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the FormSerial model
     */
    readonly fields: FormSerialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FormSerial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormSerialClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    formType<T extends FormTypeDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, FormTypeDefaultArgs<ExtArgs>>
    ): Prisma__FormTypeClient<
      $Result.GetResult<Prisma.$FormTypePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    order<T extends FormSerial$orderArgs<ExtArgs> = {}>(
      args?: Subset<T, FormSerial$orderArgs<ExtArgs>>
    ): Prisma__OrderClient<
      $Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null,
      null,
      ExtArgs
    >;
    addedByAdmin<T extends FormSerial$addedByAdminArgs<ExtArgs> = {}>(
      args?: Subset<T, FormSerial$addedByAdminArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null,
      null,
      ExtArgs
    >;
    consumedByAdmin<T extends FormSerial$consumedByAdminArgs<ExtArgs> = {}>(
      args?: Subset<T, FormSerial$consumedByAdminArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null,
      null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the FormSerial model
   */
  interface FormSerialFieldRefs {
    readonly id: FieldRef<'FormSerial', 'String'>;
    readonly formTypeId: FieldRef<'FormSerial', 'String'>;
    readonly serialNumber: FieldRef<'FormSerial', 'String'>;
    readonly orderId: FieldRef<'FormSerial', 'String'>;
    readonly consumed: FieldRef<'FormSerial', 'Boolean'>;
    readonly consumedAt: FieldRef<'FormSerial', 'DateTime'>;
    readonly addedByAdminId: FieldRef<'FormSerial', 'String'>;
    readonly consumedByAdminId: FieldRef<'FormSerial', 'String'>;
    readonly createdAt: FieldRef<'FormSerial', 'DateTime'>;
    readonly updatedAt: FieldRef<'FormSerial', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * FormSerial findUnique
   */
  export type FormSerialFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormSerial
     */
    select?: FormSerialSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSerialInclude<ExtArgs> | null;
    /**
     * Filter, which FormSerial to fetch.
     */
    where: FormSerialWhereUniqueInput;
  };

  /**
   * FormSerial findUniqueOrThrow
   */
  export type FormSerialFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormSerial
     */
    select?: FormSerialSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSerialInclude<ExtArgs> | null;
    /**
     * Filter, which FormSerial to fetch.
     */
    where: FormSerialWhereUniqueInput;
  };

  /**
   * FormSerial findFirst
   */
  export type FormSerialFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormSerial
     */
    select?: FormSerialSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSerialInclude<ExtArgs> | null;
    /**
     * Filter, which FormSerial to fetch.
     */
    where?: FormSerialWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FormSerials to fetch.
     */
    orderBy?: FormSerialOrderByWithRelationInput | FormSerialOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FormSerials.
     */
    cursor?: FormSerialWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FormSerials from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FormSerials.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FormSerials.
     */
    distinct?: FormSerialScalarFieldEnum | FormSerialScalarFieldEnum[];
  };

  /**
   * FormSerial findFirstOrThrow
   */
  export type FormSerialFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormSerial
     */
    select?: FormSerialSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSerialInclude<ExtArgs> | null;
    /**
     * Filter, which FormSerial to fetch.
     */
    where?: FormSerialWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FormSerials to fetch.
     */
    orderBy?: FormSerialOrderByWithRelationInput | FormSerialOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FormSerials.
     */
    cursor?: FormSerialWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FormSerials from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FormSerials.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FormSerials.
     */
    distinct?: FormSerialScalarFieldEnum | FormSerialScalarFieldEnum[];
  };

  /**
   * FormSerial findMany
   */
  export type FormSerialFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormSerial
     */
    select?: FormSerialSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSerialInclude<ExtArgs> | null;
    /**
     * Filter, which FormSerials to fetch.
     */
    where?: FormSerialWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FormSerials to fetch.
     */
    orderBy?: FormSerialOrderByWithRelationInput | FormSerialOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing FormSerials.
     */
    cursor?: FormSerialWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FormSerials from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FormSerials.
     */
    skip?: number;
    distinct?: FormSerialScalarFieldEnum | FormSerialScalarFieldEnum[];
  };

  /**
   * FormSerial create
   */
  export type FormSerialCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormSerial
     */
    select?: FormSerialSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSerialInclude<ExtArgs> | null;
    /**
     * The data needed to create a FormSerial.
     */
    data: XOR<FormSerialCreateInput, FormSerialUncheckedCreateInput>;
  };

  /**
   * FormSerial createMany
   */
  export type FormSerialCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many FormSerials.
     */
    data: FormSerialCreateManyInput | FormSerialCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * FormSerial createManyAndReturn
   */
  export type FormSerialCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormSerial
     */
    select?: FormSerialSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many FormSerials.
     */
    data: FormSerialCreateManyInput | FormSerialCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSerialIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * FormSerial update
   */
  export type FormSerialUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormSerial
     */
    select?: FormSerialSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSerialInclude<ExtArgs> | null;
    /**
     * The data needed to update a FormSerial.
     */
    data: XOR<FormSerialUpdateInput, FormSerialUncheckedUpdateInput>;
    /**
     * Choose, which FormSerial to update.
     */
    where: FormSerialWhereUniqueInput;
  };

  /**
   * FormSerial updateMany
   */
  export type FormSerialUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update FormSerials.
     */
    data: XOR<FormSerialUpdateManyMutationInput, FormSerialUncheckedUpdateManyInput>;
    /**
     * Filter which FormSerials to update
     */
    where?: FormSerialWhereInput;
  };

  /**
   * FormSerial upsert
   */
  export type FormSerialUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormSerial
     */
    select?: FormSerialSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSerialInclude<ExtArgs> | null;
    /**
     * The filter to search for the FormSerial to update in case it exists.
     */
    where: FormSerialWhereUniqueInput;
    /**
     * In case the FormSerial found by the `where` argument doesn't exist, create a new FormSerial with this data.
     */
    create: XOR<FormSerialCreateInput, FormSerialUncheckedCreateInput>;
    /**
     * In case the FormSerial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormSerialUpdateInput, FormSerialUncheckedUpdateInput>;
  };

  /**
   * FormSerial delete
   */
  export type FormSerialDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormSerial
     */
    select?: FormSerialSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSerialInclude<ExtArgs> | null;
    /**
     * Filter which FormSerial to delete.
     */
    where: FormSerialWhereUniqueInput;
  };

  /**
   * FormSerial deleteMany
   */
  export type FormSerialDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FormSerials to delete
     */
    where?: FormSerialWhereInput;
  };

  /**
   * FormSerial.order
   */
  export type FormSerial$orderArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    where?: OrderWhereInput;
  };

  /**
   * FormSerial.addedByAdmin
   */
  export type FormSerial$addedByAdminArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * FormSerial.consumedByAdmin
   */
  export type FormSerial$consumedByAdminArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * FormSerial without action
   */
  export type FormSerialDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FormSerial
     */
    select?: FormSerialSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSerialInclude<ExtArgs> | null;
  };

  /**
   * Model Dependent
   */

  export type AggregateDependent = {
    _count: DependentCountAggregateOutputType | null;
    _min: DependentMinAggregateOutputType | null;
    _max: DependentMaxAggregateOutputType | null;
  };

  export type DependentMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    createdByAdminId: string | null;
  };

  export type DependentMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    createdByAdminId: string | null;
  };

  export type DependentCountAggregateOutputType = {
    id: number;
    name: number;
    createdAt: number;
    updatedAt: number;
    createdByAdminId: number;
    _all: number;
  };

  export type DependentMinAggregateInputType = {
    id?: true;
    name?: true;
    createdAt?: true;
    updatedAt?: true;
    createdByAdminId?: true;
  };

  export type DependentMaxAggregateInputType = {
    id?: true;
    name?: true;
    createdAt?: true;
    updatedAt?: true;
    createdByAdminId?: true;
  };

  export type DependentCountAggregateInputType = {
    id?: true;
    name?: true;
    createdAt?: true;
    updatedAt?: true;
    createdByAdminId?: true;
    _all?: true;
  };

  export type DependentAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Dependent to aggregate.
     */
    where?: DependentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Dependents to fetch.
     */
    orderBy?: DependentOrderByWithRelationInput | DependentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: DependentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Dependents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Dependents.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Dependents
     **/
    _count?: true | DependentCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: DependentMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: DependentMaxAggregateInputType;
  };

  export type GetDependentAggregateType<T extends DependentAggregateArgs> = {
    [P in keyof T & keyof AggregateDependent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDependent[P]>
      : GetScalarType<T[P], AggregateDependent[P]>;
  };

  export type DependentGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: DependentWhereInput;
    orderBy?: DependentOrderByWithAggregationInput | DependentOrderByWithAggregationInput[];
    by: DependentScalarFieldEnum[] | DependentScalarFieldEnum;
    having?: DependentScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: DependentCountAggregateInputType | true;
    _min?: DependentMinAggregateInputType;
    _max?: DependentMaxAggregateInputType;
  };

  export type DependentGroupByOutputType = {
    id: string;
    name: string;
    createdAt: Date;
    updatedAt: Date;
    createdByAdminId: string | null;
    _count: DependentCountAggregateOutputType | null;
    _min: DependentMinAggregateOutputType | null;
    _max: DependentMaxAggregateOutputType | null;
  };

  type GetDependentGroupByPayload<T extends DependentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DependentGroupByOutputType, T['by']> & {
        [P in keyof T & keyof DependentGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], DependentGroupByOutputType[P]>
          : GetScalarType<T[P], DependentGroupByOutputType[P]>;
      }
    >
  >;

  export type DependentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        name?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        createdByAdminId?: boolean;
        createdByAdmin?: boolean | Dependent$createdByAdminArgs<ExtArgs>;
      },
      ExtArgs['result']['dependent']
    >;

  export type DependentSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      createdByAdminId?: boolean;
      createdByAdmin?: boolean | Dependent$createdByAdminArgs<ExtArgs>;
    },
    ExtArgs['result']['dependent']
  >;

  export type DependentSelectScalar = {
    id?: boolean;
    name?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    createdByAdminId?: boolean;
  };

  export type DependentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      createdByAdmin?: boolean | Dependent$createdByAdminArgs<ExtArgs>;
    };
  export type DependentIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    createdByAdmin?: boolean | Dependent$createdByAdminArgs<ExtArgs>;
  };

  export type $DependentPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Dependent';
    objects: {
      createdByAdmin: Prisma.$UserPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        createdAt: Date;
        updatedAt: Date;
        createdByAdminId: string | null;
      },
      ExtArgs['result']['dependent']
    >;
    composites: {};
  };

  type DependentGetPayload<S extends boolean | null | undefined | DependentDefaultArgs> =
    $Result.GetResult<Prisma.$DependentPayload, S>;

  type DependentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DependentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DependentCountAggregateInputType | true;
    };

  export interface DependentDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Dependent'];
      meta: { name: 'Dependent' };
    };
    /**
     * Find zero or one Dependent that matches the filter.
     * @param {DependentFindUniqueArgs} args - Arguments to find a Dependent
     * @example
     * // Get one Dependent
     * const dependent = await prisma.dependent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DependentFindUniqueArgs>(
      args: SelectSubset<T, DependentFindUniqueArgs<ExtArgs>>
    ): Prisma__DependentClient<
      $Result.GetResult<Prisma.$DependentPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Dependent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DependentFindUniqueOrThrowArgs} args - Arguments to find a Dependent
     * @example
     * // Get one Dependent
     * const dependent = await prisma.dependent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DependentFindUniqueOrThrowArgs>(
      args: SelectSubset<T, DependentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DependentClient<
      $Result.GetResult<Prisma.$DependentPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first Dependent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependentFindFirstArgs} args - Arguments to find a Dependent
     * @example
     * // Get one Dependent
     * const dependent = await prisma.dependent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DependentFindFirstArgs>(
      args?: SelectSubset<T, DependentFindFirstArgs<ExtArgs>>
    ): Prisma__DependentClient<
      $Result.GetResult<Prisma.$DependentPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Dependent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependentFindFirstOrThrowArgs} args - Arguments to find a Dependent
     * @example
     * // Get one Dependent
     * const dependent = await prisma.dependent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DependentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DependentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DependentClient<
      $Result.GetResult<Prisma.$DependentPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Dependents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dependents
     * const dependents = await prisma.dependent.findMany()
     *
     * // Get first 10 Dependents
     * const dependents = await prisma.dependent.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const dependentWithIdOnly = await prisma.dependent.findMany({ select: { id: true } })
     *
     */
    findMany<T extends DependentFindManyArgs>(
      args?: SelectSubset<T, DependentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DependentPayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a Dependent.
     * @param {DependentCreateArgs} args - Arguments to create a Dependent.
     * @example
     * // Create one Dependent
     * const Dependent = await prisma.dependent.create({
     *   data: {
     *     // ... data to create a Dependent
     *   }
     * })
     *
     */
    create<T extends DependentCreateArgs>(
      args: SelectSubset<T, DependentCreateArgs<ExtArgs>>
    ): Prisma__DependentClient<
      $Result.GetResult<Prisma.$DependentPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many Dependents.
     * @param {DependentCreateManyArgs} args - Arguments to create many Dependents.
     * @example
     * // Create many Dependents
     * const dependent = await prisma.dependent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends DependentCreateManyArgs>(
      args?: SelectSubset<T, DependentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Dependents and returns the data saved in the database.
     * @param {DependentCreateManyAndReturnArgs} args - Arguments to create many Dependents.
     * @example
     * // Create many Dependents
     * const dependent = await prisma.dependent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Dependents and only return the `id`
     * const dependentWithIdOnly = await prisma.dependent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends DependentCreateManyAndReturnArgs>(
      args?: SelectSubset<T, DependentCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$DependentPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a Dependent.
     * @param {DependentDeleteArgs} args - Arguments to delete one Dependent.
     * @example
     * // Delete one Dependent
     * const Dependent = await prisma.dependent.delete({
     *   where: {
     *     // ... filter to delete one Dependent
     *   }
     * })
     *
     */
    delete<T extends DependentDeleteArgs>(
      args: SelectSubset<T, DependentDeleteArgs<ExtArgs>>
    ): Prisma__DependentClient<
      $Result.GetResult<Prisma.$DependentPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one Dependent.
     * @param {DependentUpdateArgs} args - Arguments to update one Dependent.
     * @example
     * // Update one Dependent
     * const dependent = await prisma.dependent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends DependentUpdateArgs>(
      args: SelectSubset<T, DependentUpdateArgs<ExtArgs>>
    ): Prisma__DependentClient<
      $Result.GetResult<Prisma.$DependentPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Dependents.
     * @param {DependentDeleteManyArgs} args - Arguments to filter Dependents to delete.
     * @example
     * // Delete a few Dependents
     * const { count } = await prisma.dependent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends DependentDeleteManyArgs>(
      args?: SelectSubset<T, DependentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Dependents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dependents
     * const dependent = await prisma.dependent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends DependentUpdateManyArgs>(
      args: SelectSubset<T, DependentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Dependent.
     * @param {DependentUpsertArgs} args - Arguments to update or create a Dependent.
     * @example
     * // Update or create a Dependent
     * const dependent = await prisma.dependent.upsert({
     *   create: {
     *     // ... data to create a Dependent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dependent we want to update
     *   }
     * })
     */
    upsert<T extends DependentUpsertArgs>(
      args: SelectSubset<T, DependentUpsertArgs<ExtArgs>>
    ): Prisma__DependentClient<
      $Result.GetResult<Prisma.$DependentPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Dependents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependentCountArgs} args - Arguments to filter Dependents to count.
     * @example
     * // Count the number of Dependents
     * const count = await prisma.dependent.count({
     *   where: {
     *     // ... the filter for the Dependents we want to count
     *   }
     * })
     **/
    count<T extends DependentCountArgs>(
      args?: Subset<T, DependentCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DependentCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Dependent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends DependentAggregateArgs>(
      args: Subset<T, DependentAggregateArgs>
    ): Prisma.PrismaPromise<GetDependentAggregateType<T>>;

    /**
     * Group by Dependent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends DependentGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DependentGroupByArgs['orderBy'] }
        : { orderBy?: DependentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, DependentGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetDependentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Dependent model
     */
    readonly fields: DependentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dependent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DependentClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    createdByAdmin<T extends Dependent$createdByAdminArgs<ExtArgs> = {}>(
      args?: Subset<T, Dependent$createdByAdminArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null,
      null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Dependent model
   */
  interface DependentFieldRefs {
    readonly id: FieldRef<'Dependent', 'String'>;
    readonly name: FieldRef<'Dependent', 'String'>;
    readonly createdAt: FieldRef<'Dependent', 'DateTime'>;
    readonly updatedAt: FieldRef<'Dependent', 'DateTime'>;
    readonly createdByAdminId: FieldRef<'Dependent', 'String'>;
  }

  // Custom InputTypes
  /**
   * Dependent findUnique
   */
  export type DependentFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Dependent
     */
    select?: DependentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependentInclude<ExtArgs> | null;
    /**
     * Filter, which Dependent to fetch.
     */
    where: DependentWhereUniqueInput;
  };

  /**
   * Dependent findUniqueOrThrow
   */
  export type DependentFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Dependent
     */
    select?: DependentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependentInclude<ExtArgs> | null;
    /**
     * Filter, which Dependent to fetch.
     */
    where: DependentWhereUniqueInput;
  };

  /**
   * Dependent findFirst
   */
  export type DependentFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Dependent
     */
    select?: DependentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependentInclude<ExtArgs> | null;
    /**
     * Filter, which Dependent to fetch.
     */
    where?: DependentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Dependents to fetch.
     */
    orderBy?: DependentOrderByWithRelationInput | DependentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Dependents.
     */
    cursor?: DependentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Dependents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Dependents.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Dependents.
     */
    distinct?: DependentScalarFieldEnum | DependentScalarFieldEnum[];
  };

  /**
   * Dependent findFirstOrThrow
   */
  export type DependentFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Dependent
     */
    select?: DependentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependentInclude<ExtArgs> | null;
    /**
     * Filter, which Dependent to fetch.
     */
    where?: DependentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Dependents to fetch.
     */
    orderBy?: DependentOrderByWithRelationInput | DependentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Dependents.
     */
    cursor?: DependentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Dependents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Dependents.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Dependents.
     */
    distinct?: DependentScalarFieldEnum | DependentScalarFieldEnum[];
  };

  /**
   * Dependent findMany
   */
  export type DependentFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Dependent
     */
    select?: DependentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependentInclude<ExtArgs> | null;
    /**
     * Filter, which Dependents to fetch.
     */
    where?: DependentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Dependents to fetch.
     */
    orderBy?: DependentOrderByWithRelationInput | DependentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Dependents.
     */
    cursor?: DependentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Dependents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Dependents.
     */
    skip?: number;
    distinct?: DependentScalarFieldEnum | DependentScalarFieldEnum[];
  };

  /**
   * Dependent create
   */
  export type DependentCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Dependent
     */
    select?: DependentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependentInclude<ExtArgs> | null;
    /**
     * The data needed to create a Dependent.
     */
    data: XOR<DependentCreateInput, DependentUncheckedCreateInput>;
  };

  /**
   * Dependent createMany
   */
  export type DependentCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Dependents.
     */
    data: DependentCreateManyInput | DependentCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Dependent createManyAndReturn
   */
  export type DependentCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Dependent
     */
    select?: DependentSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many Dependents.
     */
    data: DependentCreateManyInput | DependentCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependentIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Dependent update
   */
  export type DependentUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Dependent
     */
    select?: DependentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependentInclude<ExtArgs> | null;
    /**
     * The data needed to update a Dependent.
     */
    data: XOR<DependentUpdateInput, DependentUncheckedUpdateInput>;
    /**
     * Choose, which Dependent to update.
     */
    where: DependentWhereUniqueInput;
  };

  /**
   * Dependent updateMany
   */
  export type DependentUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Dependents.
     */
    data: XOR<DependentUpdateManyMutationInput, DependentUncheckedUpdateManyInput>;
    /**
     * Filter which Dependents to update
     */
    where?: DependentWhereInput;
  };

  /**
   * Dependent upsert
   */
  export type DependentUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Dependent
     */
    select?: DependentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependentInclude<ExtArgs> | null;
    /**
     * The filter to search for the Dependent to update in case it exists.
     */
    where: DependentWhereUniqueInput;
    /**
     * In case the Dependent found by the `where` argument doesn't exist, create a new Dependent with this data.
     */
    create: XOR<DependentCreateInput, DependentUncheckedCreateInput>;
    /**
     * In case the Dependent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DependentUpdateInput, DependentUncheckedUpdateInput>;
  };

  /**
   * Dependent delete
   */
  export type DependentDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Dependent
     */
    select?: DependentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependentInclude<ExtArgs> | null;
    /**
     * Filter which Dependent to delete.
     */
    where: DependentWhereUniqueInput;
  };

  /**
   * Dependent deleteMany
   */
  export type DependentDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Dependents to delete
     */
    where?: DependentWhereInput;
  };

  /**
   * Dependent.createdByAdmin
   */
  export type Dependent$createdByAdminArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * Dependent without action
   */
  export type DependentDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Dependent
     */
    select?: DependentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependentInclude<ExtArgs> | null;
  };

  /**
   * Model PromoCode
   */

  export type AggregatePromoCode = {
    _count: PromoCodeCountAggregateOutputType | null;
    _avg: PromoCodeAvgAggregateOutputType | null;
    _sum: PromoCodeSumAggregateOutputType | null;
    _min: PromoCodeMinAggregateOutputType | null;
    _max: PromoCodeMaxAggregateOutputType | null;
  };

  export type PromoCodeAvgAggregateOutputType = {
    value: number | null;
    minOrderAmount: number | null;
    maxDiscount: number | null;
    usageLimit: number | null;
    currentUsage: number | null;
  };

  export type PromoCodeSumAggregateOutputType = {
    value: number | null;
    minOrderAmount: number | null;
    maxDiscount: number | null;
    usageLimit: number | null;
    currentUsage: number | null;
  };

  export type PromoCodeMinAggregateOutputType = {
    id: string | null;
    code: string | null;
    type: string | null;
    value: number | null;
    minOrderAmount: number | null;
    maxDiscount: number | null;
    startDate: Date | null;
    endDate: Date | null;
    usageLimit: number | null;
    currentUsage: number | null;
    isActive: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type PromoCodeMaxAggregateOutputType = {
    id: string | null;
    code: string | null;
    type: string | null;
    value: number | null;
    minOrderAmount: number | null;
    maxDiscount: number | null;
    startDate: Date | null;
    endDate: Date | null;
    usageLimit: number | null;
    currentUsage: number | null;
    isActive: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type PromoCodeCountAggregateOutputType = {
    id: number;
    code: number;
    type: number;
    value: number;
    minOrderAmount: number;
    maxDiscount: number;
    startDate: number;
    endDate: number;
    usageLimit: number;
    currentUsage: number;
    isActive: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type PromoCodeAvgAggregateInputType = {
    value?: true;
    minOrderAmount?: true;
    maxDiscount?: true;
    usageLimit?: true;
    currentUsage?: true;
  };

  export type PromoCodeSumAggregateInputType = {
    value?: true;
    minOrderAmount?: true;
    maxDiscount?: true;
    usageLimit?: true;
    currentUsage?: true;
  };

  export type PromoCodeMinAggregateInputType = {
    id?: true;
    code?: true;
    type?: true;
    value?: true;
    minOrderAmount?: true;
    maxDiscount?: true;
    startDate?: true;
    endDate?: true;
    usageLimit?: true;
    currentUsage?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type PromoCodeMaxAggregateInputType = {
    id?: true;
    code?: true;
    type?: true;
    value?: true;
    minOrderAmount?: true;
    maxDiscount?: true;
    startDate?: true;
    endDate?: true;
    usageLimit?: true;
    currentUsage?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type PromoCodeCountAggregateInputType = {
    id?: true;
    code?: true;
    type?: true;
    value?: true;
    minOrderAmount?: true;
    maxDiscount?: true;
    startDate?: true;
    endDate?: true;
    usageLimit?: true;
    currentUsage?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type PromoCodeAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which PromoCode to aggregate.
     */
    where?: PromoCodeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PromoCodeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PromoCodes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned PromoCodes
     **/
    _count?: true | PromoCodeCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: PromoCodeAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: PromoCodeSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PromoCodeMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PromoCodeMaxAggregateInputType;
  };

  export type GetPromoCodeAggregateType<T extends PromoCodeAggregateArgs> = {
    [P in keyof T & keyof AggregatePromoCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromoCode[P]>
      : GetScalarType<T[P], AggregatePromoCode[P]>;
  };

  export type PromoCodeGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PromoCodeWhereInput;
    orderBy?: PromoCodeOrderByWithAggregationInput | PromoCodeOrderByWithAggregationInput[];
    by: PromoCodeScalarFieldEnum[] | PromoCodeScalarFieldEnum;
    having?: PromoCodeScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PromoCodeCountAggregateInputType | true;
    _avg?: PromoCodeAvgAggregateInputType;
    _sum?: PromoCodeSumAggregateInputType;
    _min?: PromoCodeMinAggregateInputType;
    _max?: PromoCodeMaxAggregateInputType;
  };

  export type PromoCodeGroupByOutputType = {
    id: string;
    code: string;
    type: string;
    value: number;
    minOrderAmount: number | null;
    maxDiscount: number | null;
    startDate: Date | null;
    endDate: Date | null;
    usageLimit: number | null;
    currentUsage: number;
    isActive: boolean;
    createdAt: Date;
    updatedAt: Date;
    _count: PromoCodeCountAggregateOutputType | null;
    _avg: PromoCodeAvgAggregateOutputType | null;
    _sum: PromoCodeSumAggregateOutputType | null;
    _min: PromoCodeMinAggregateOutputType | null;
    _max: PromoCodeMaxAggregateOutputType | null;
  };

  type GetPromoCodeGroupByPayload<T extends PromoCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromoCodeGroupByOutputType, T['by']> & {
        [P in keyof T & keyof PromoCodeGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], PromoCodeGroupByOutputType[P]>
          : GetScalarType<T[P], PromoCodeGroupByOutputType[P]>;
      }
    >
  >;

  export type PromoCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        code?: boolean;
        type?: boolean;
        value?: boolean;
        minOrderAmount?: boolean;
        maxDiscount?: boolean;
        startDate?: boolean;
        endDate?: boolean;
        usageLimit?: boolean;
        currentUsage?: boolean;
        isActive?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        orders?: boolean | PromoCode$ordersArgs<ExtArgs>;
        _count?: boolean | PromoCodeCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['promoCode']
    >;

  export type PromoCodeSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      code?: boolean;
      type?: boolean;
      value?: boolean;
      minOrderAmount?: boolean;
      maxDiscount?: boolean;
      startDate?: boolean;
      endDate?: boolean;
      usageLimit?: boolean;
      currentUsage?: boolean;
      isActive?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['promoCode']
  >;

  export type PromoCodeSelectScalar = {
    id?: boolean;
    code?: boolean;
    type?: boolean;
    value?: boolean;
    minOrderAmount?: boolean;
    maxDiscount?: boolean;
    startDate?: boolean;
    endDate?: boolean;
    usageLimit?: boolean;
    currentUsage?: boolean;
    isActive?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type PromoCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      orders?: boolean | PromoCode$ordersArgs<ExtArgs>;
      _count?: boolean | PromoCodeCountOutputTypeDefaultArgs<ExtArgs>;
    };
  export type PromoCodeIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $PromoCodePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'PromoCode';
    objects: {
      orders: Prisma.$OrderPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        code: string;
        type: string;
        value: number;
        minOrderAmount: number | null;
        maxDiscount: number | null;
        startDate: Date | null;
        endDate: Date | null;
        usageLimit: number | null;
        currentUsage: number;
        isActive: boolean;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['promoCode']
    >;
    composites: {};
  };

  type PromoCodeGetPayload<S extends boolean | null | undefined | PromoCodeDefaultArgs> =
    $Result.GetResult<Prisma.$PromoCodePayload, S>;

  type PromoCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PromoCodeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PromoCodeCountAggregateInputType | true;
    };

  export interface PromoCodeDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['PromoCode'];
      meta: { name: 'PromoCode' };
    };
    /**
     * Find zero or one PromoCode that matches the filter.
     * @param {PromoCodeFindUniqueArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromoCodeFindUniqueArgs>(
      args: SelectSubset<T, PromoCodeFindUniqueArgs<ExtArgs>>
    ): Prisma__PromoCodeClient<
      $Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one PromoCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PromoCodeFindUniqueOrThrowArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromoCodeFindUniqueOrThrowArgs>(
      args: SelectSubset<T, PromoCodeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PromoCodeClient<
      $Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first PromoCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindFirstArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromoCodeFindFirstArgs>(
      args?: SelectSubset<T, PromoCodeFindFirstArgs<ExtArgs>>
    ): Prisma__PromoCodeClient<
      $Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first PromoCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindFirstOrThrowArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromoCodeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PromoCodeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PromoCodeClient<
      $Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more PromoCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromoCodes
     * const promoCodes = await prisma.promoCode.findMany()
     *
     * // Get first 10 PromoCodes
     * const promoCodes = await prisma.promoCode.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const promoCodeWithIdOnly = await prisma.promoCode.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PromoCodeFindManyArgs>(
      args?: SelectSubset<T, PromoCodeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a PromoCode.
     * @param {PromoCodeCreateArgs} args - Arguments to create a PromoCode.
     * @example
     * // Create one PromoCode
     * const PromoCode = await prisma.promoCode.create({
     *   data: {
     *     // ... data to create a PromoCode
     *   }
     * })
     *
     */
    create<T extends PromoCodeCreateArgs>(
      args: SelectSubset<T, PromoCodeCreateArgs<ExtArgs>>
    ): Prisma__PromoCodeClient<
      $Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many PromoCodes.
     * @param {PromoCodeCreateManyArgs} args - Arguments to create many PromoCodes.
     * @example
     * // Create many PromoCodes
     * const promoCode = await prisma.promoCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PromoCodeCreateManyArgs>(
      args?: SelectSubset<T, PromoCodeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many PromoCodes and returns the data saved in the database.
     * @param {PromoCodeCreateManyAndReturnArgs} args - Arguments to create many PromoCodes.
     * @example
     * // Create many PromoCodes
     * const promoCode = await prisma.promoCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many PromoCodes and only return the `id`
     * const promoCodeWithIdOnly = await prisma.promoCode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends PromoCodeCreateManyAndReturnArgs>(
      args?: SelectSubset<T, PromoCodeCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a PromoCode.
     * @param {PromoCodeDeleteArgs} args - Arguments to delete one PromoCode.
     * @example
     * // Delete one PromoCode
     * const PromoCode = await prisma.promoCode.delete({
     *   where: {
     *     // ... filter to delete one PromoCode
     *   }
     * })
     *
     */
    delete<T extends PromoCodeDeleteArgs>(
      args: SelectSubset<T, PromoCodeDeleteArgs<ExtArgs>>
    ): Prisma__PromoCodeClient<
      $Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one PromoCode.
     * @param {PromoCodeUpdateArgs} args - Arguments to update one PromoCode.
     * @example
     * // Update one PromoCode
     * const promoCode = await prisma.promoCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PromoCodeUpdateArgs>(
      args: SelectSubset<T, PromoCodeUpdateArgs<ExtArgs>>
    ): Prisma__PromoCodeClient<
      $Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more PromoCodes.
     * @param {PromoCodeDeleteManyArgs} args - Arguments to filter PromoCodes to delete.
     * @example
     * // Delete a few PromoCodes
     * const { count } = await prisma.promoCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PromoCodeDeleteManyArgs>(
      args?: SelectSubset<T, PromoCodeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more PromoCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromoCodes
     * const promoCode = await prisma.promoCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PromoCodeUpdateManyArgs>(
      args: SelectSubset<T, PromoCodeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one PromoCode.
     * @param {PromoCodeUpsertArgs} args - Arguments to update or create a PromoCode.
     * @example
     * // Update or create a PromoCode
     * const promoCode = await prisma.promoCode.upsert({
     *   create: {
     *     // ... data to create a PromoCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromoCode we want to update
     *   }
     * })
     */
    upsert<T extends PromoCodeUpsertArgs>(
      args: SelectSubset<T, PromoCodeUpsertArgs<ExtArgs>>
    ): Prisma__PromoCodeClient<
      $Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of PromoCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeCountArgs} args - Arguments to filter PromoCodes to count.
     * @example
     * // Count the number of PromoCodes
     * const count = await prisma.promoCode.count({
     *   where: {
     *     // ... the filter for the PromoCodes we want to count
     *   }
     * })
     **/
    count<T extends PromoCodeCountArgs>(
      args?: Subset<T, PromoCodeCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromoCodeCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a PromoCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PromoCodeAggregateArgs>(
      args: Subset<T, PromoCodeAggregateArgs>
    ): Prisma.PrismaPromise<GetPromoCodeAggregateType<T>>;

    /**
     * Group by PromoCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends PromoCodeGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromoCodeGroupByArgs['orderBy'] }
        : { orderBy?: PromoCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, PromoCodeGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetPromoCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the PromoCode model
     */
    readonly fields: PromoCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromoCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromoCodeClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    orders<T extends PromoCode$ordersArgs<ExtArgs> = {}>(
      args?: Subset<T, PromoCode$ordersArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, 'findMany'> | Null>;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the PromoCode model
   */
  interface PromoCodeFieldRefs {
    readonly id: FieldRef<'PromoCode', 'String'>;
    readonly code: FieldRef<'PromoCode', 'String'>;
    readonly type: FieldRef<'PromoCode', 'String'>;
    readonly value: FieldRef<'PromoCode', 'Int'>;
    readonly minOrderAmount: FieldRef<'PromoCode', 'Int'>;
    readonly maxDiscount: FieldRef<'PromoCode', 'Int'>;
    readonly startDate: FieldRef<'PromoCode', 'DateTime'>;
    readonly endDate: FieldRef<'PromoCode', 'DateTime'>;
    readonly usageLimit: FieldRef<'PromoCode', 'Int'>;
    readonly currentUsage: FieldRef<'PromoCode', 'Int'>;
    readonly isActive: FieldRef<'PromoCode', 'Boolean'>;
    readonly createdAt: FieldRef<'PromoCode', 'DateTime'>;
    readonly updatedAt: FieldRef<'PromoCode', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * PromoCode findUnique
   */
  export type PromoCodeFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null;
    /**
     * Filter, which PromoCode to fetch.
     */
    where: PromoCodeWhereUniqueInput;
  };

  /**
   * PromoCode findUniqueOrThrow
   */
  export type PromoCodeFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null;
    /**
     * Filter, which PromoCode to fetch.
     */
    where: PromoCodeWhereUniqueInput;
  };

  /**
   * PromoCode findFirst
   */
  export type PromoCodeFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null;
    /**
     * Filter, which PromoCode to fetch.
     */
    where?: PromoCodeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PromoCodes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PromoCodes.
     */
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[];
  };

  /**
   * PromoCode findFirstOrThrow
   */
  export type PromoCodeFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null;
    /**
     * Filter, which PromoCode to fetch.
     */
    where?: PromoCodeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PromoCodes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PromoCodes.
     */
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[];
  };

  /**
   * PromoCode findMany
   */
  export type PromoCodeFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null;
    /**
     * Filter, which PromoCodes to fetch.
     */
    where?: PromoCodeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PromoCodes.
     */
    skip?: number;
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[];
  };

  /**
   * PromoCode create
   */
  export type PromoCodeCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null;
    /**
     * The data needed to create a PromoCode.
     */
    data: XOR<PromoCodeCreateInput, PromoCodeUncheckedCreateInput>;
  };

  /**
   * PromoCode createMany
   */
  export type PromoCodeCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many PromoCodes.
     */
    data: PromoCodeCreateManyInput | PromoCodeCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * PromoCode createManyAndReturn
   */
  export type PromoCodeCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many PromoCodes.
     */
    data: PromoCodeCreateManyInput | PromoCodeCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * PromoCode update
   */
  export type PromoCodeUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null;
    /**
     * The data needed to update a PromoCode.
     */
    data: XOR<PromoCodeUpdateInput, PromoCodeUncheckedUpdateInput>;
    /**
     * Choose, which PromoCode to update.
     */
    where: PromoCodeWhereUniqueInput;
  };

  /**
   * PromoCode updateMany
   */
  export type PromoCodeUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update PromoCodes.
     */
    data: XOR<PromoCodeUpdateManyMutationInput, PromoCodeUncheckedUpdateManyInput>;
    /**
     * Filter which PromoCodes to update
     */
    where?: PromoCodeWhereInput;
  };

  /**
   * PromoCode upsert
   */
  export type PromoCodeUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null;
    /**
     * The filter to search for the PromoCode to update in case it exists.
     */
    where: PromoCodeWhereUniqueInput;
    /**
     * In case the PromoCode found by the `where` argument doesn't exist, create a new PromoCode with this data.
     */
    create: XOR<PromoCodeCreateInput, PromoCodeUncheckedCreateInput>;
    /**
     * In case the PromoCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromoCodeUpdateInput, PromoCodeUncheckedUpdateInput>;
  };

  /**
   * PromoCode delete
   */
  export type PromoCodeDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null;
    /**
     * Filter which PromoCode to delete.
     */
    where: PromoCodeWhereUniqueInput;
  };

  /**
   * PromoCode deleteMany
   */
  export type PromoCodeDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which PromoCodes to delete
     */
    where?: PromoCodeWhereInput;
  };

  /**
   * PromoCode.orders
   */
  export type PromoCode$ordersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null;
    where?: OrderWhereInput;
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[];
    cursor?: OrderWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[];
  };

  /**
   * PromoCode without action
   */
  export type PromoCodeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null;
  };

  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted';
    ReadCommitted: 'ReadCommitted';
    RepeatableRead: 'RepeatableRead';
    Serializable: 'Serializable';
  };

  export type TransactionIsolationLevel =
    (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

  export const AccountScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    type: 'type';
    provider: 'provider';
    providerAccountId: 'providerAccountId';
    refresh_token: 'refresh_token';
    access_token: 'access_token';
    expires_at: 'expires_at';
    token_type: 'token_type';
    scope: 'scope';
    id_token: 'id_token';
    session_state: 'session_state';
  };

  export type AccountScalarFieldEnum =
    (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum];

  export const SessionScalarFieldEnum: {
    id: 'id';
    sessionToken: 'sessionToken';
    userId: 'userId';
    expires: 'expires';
  };

  export type SessionScalarFieldEnum =
    (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum];

  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier';
    token: 'token';
    expires: 'expires';
  };

  export type VerificationTokenScalarFieldEnum =
    (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum];

  export const UserScalarFieldEnum: {
    id: 'id';
    name: 'name';
    email: 'email';
    emailVerified: 'emailVerified';
    image: 'image';
    passwordHash: 'passwordHash';
    phone: 'phone';
    additionalPhone: 'additionalPhone';
    role: 'role';
    createdByAdminId: 'createdByAdminId';
    resetToken: 'resetToken';
    resetTokenExpiry: 'resetTokenExpiry';
    verificationToken: 'verificationToken';
    verificationTokenExpiry: 'verificationTokenExpiry';
    verificationCode: 'verificationCode';
    verificationCodeExpiry: 'verificationCodeExpiry';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    address: 'address';
    governorate: 'governorate';
    city: 'city';
    district: 'district';
    street: 'street';
    buildingNumber: 'buildingNumber';
    apartmentNumber: 'apartmentNumber';
    landmark: 'landmark';
    birthDate: 'birthDate';
    fatherName: 'fatherName';
    idNumber: 'idNumber';
    motherName: 'motherName';
    nationality: 'nationality';
    wifeName: 'wifeName';
    wifeMotherName: 'wifeMotherName';
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum];

  export const CategoryScalarFieldEnum: {
    id: 'id';
    name: 'name';
    slug: 'slug';
    orderIndex: 'orderIndex';
    active: 'active';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    icon: 'icon';
  };

  export type CategoryScalarFieldEnum =
    (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum];

  export const ServiceScalarFieldEnum: {
    id: 'id';
    name: 'name';
    slug: 'slug';
    description: 'description';
    icon: 'icon';
    active: 'active';
    categoryId: 'categoryId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type ServiceScalarFieldEnum =
    (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum];

  export const ServiceFieldScalarFieldEnum: {
    id: 'id';
    serviceId: 'serviceId';
    name: 'name';
    label: 'label';
    type: 'type';
    placeholder: 'placeholder';
    required: 'required';
    orderIndex: 'orderIndex';
    active: 'active';
    showIf: 'showIf';
    validation: 'validation';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type ServiceFieldScalarFieldEnum =
    (typeof ServiceFieldScalarFieldEnum)[keyof typeof ServiceFieldScalarFieldEnum];

  export const ServiceFieldOptionScalarFieldEnum: {
    id: 'id';
    fieldId: 'fieldId';
    value: 'value';
    label: 'label';
    orderIndex: 'orderIndex';
    requiredDocs: 'requiredDocs';
    showFields: 'showFields';
    createdAt: 'createdAt';
  };

  export type ServiceFieldOptionScalarFieldEnum =
    (typeof ServiceFieldOptionScalarFieldEnum)[keyof typeof ServiceFieldOptionScalarFieldEnum];

  export const ServiceVariantScalarFieldEnum: {
    id: 'id';
    name: 'name';
    priceCents: 'priceCents';
    etaDays: 'etaDays';
    serviceId: 'serviceId';
    active: 'active';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type ServiceVariantScalarFieldEnum =
    (typeof ServiceVariantScalarFieldEnum)[keyof typeof ServiceVariantScalarFieldEnum];

  export const OrderScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    serviceId: 'serviceId';
    variantId: 'variantId';
    status: 'status';
    totalPrice: 'totalPrice';
    totalCents: 'totalCents';
    customerName: 'customerName';
    customerPhone: 'customerPhone';
    additionalPhone: 'additionalPhone';
    customerEmail: 'customerEmail';
    address: 'address';
    governorate: 'governorate';
    city: 'city';
    district: 'district';
    street: 'street';
    buildingNumber: 'buildingNumber';
    apartmentNumber: 'apartmentNumber';
    landmark: 'landmark';
    notes: 'notes';
    adminNotes: 'adminNotes';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    completedAt: 'completedAt';
    estimatedCompletionDate: 'estimatedCompletionDate';
    deliveryFee: 'deliveryFee';
    deliveryType: 'deliveryType';
    createdByAdminId: 'createdByAdminId';
    birthDate: 'birthDate';
    fatherName: 'fatherName';
    idNumber: 'idNumber';
    motherName: 'motherName';
    nationality: 'nationality';
    wifeName: 'wifeName';
    photographyLocation: 'photographyLocation';
    photographyDate: 'photographyDate';
    marriageDate: 'marriageDate';
    divorceDate: 'divorceDate';
    wifeMotherName: 'wifeMotherName';
    quantity: 'quantity';
    serviceDetails: 'serviceDetails';
    otherFees: 'otherFees';
    discount: 'discount';
    gender: 'gender';
    policeStation: 'policeStation';
    pickupLocation: 'pickupLocation';
    originalDocuments: 'originalDocuments';
    attachedDocuments: 'attachedDocuments';
    hasAttachments: 'hasAttachments';
    selectedFines: 'selectedFines';
    finesDetails: 'finesDetails';
    servicesDetails: 'servicesDetails';
    customerFollowUp: 'customerFollowUp';
    promoCodeId: 'promoCodeId';
    discountAmount: 'discountAmount';
  };

  export type OrderScalarFieldEnum =
    (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum];

  export const PaymentScalarFieldEnum: {
    id: 'id';
    orderId: 'orderId';
    amount: 'amount';
    currency: 'currency';
    method: 'method';
    status: 'status';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    paymentScreenshot: 'paymentScreenshot';
    senderPhone: 'senderPhone';
    notes: 'notes';
  };

  export type PaymentScalarFieldEnum =
    (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum];

  export const AuditLogScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    action: 'action';
    entityType: 'entityType';
    entityId: 'entityId';
    oldValues: 'oldValues';
    newValues: 'newValues';
    ipAddress: 'ipAddress';
    userAgent: 'userAgent';
    createdAt: 'createdAt';
  };

  export type AuditLogScalarFieldEnum =
    (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum];

  export const FAQScalarFieldEnum: {
    id: 'id';
    question: 'question';
    answer: 'answer';
    orderIndex: 'orderIndex';
    active: 'active';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type FAQScalarFieldEnum = (typeof FAQScalarFieldEnum)[keyof typeof FAQScalarFieldEnum];

  export const DocumentScalarFieldEnum: {
    id: 'id';
    orderId: 'orderId';
    fileName: 'fileName';
    filePath: 'filePath';
    fileType: 'fileType';
    fileSize: 'fileSize';
    uploadedAt: 'uploadedAt';
  };

  export type DocumentScalarFieldEnum =
    (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum];

  export const OrderDocumentScalarFieldEnum: {
    id: 'id';
    orderId: 'orderId';
    fileName: 'fileName';
    filePath: 'filePath';
    fileSize: 'fileSize';
    fileType: 'fileType';
    documentType: 'documentType';
    uploadedAt: 'uploadedAt';
  };

  export type OrderDocumentScalarFieldEnum =
    (typeof OrderDocumentScalarFieldEnum)[keyof typeof OrderDocumentScalarFieldEnum];

  export const ServiceDocumentScalarFieldEnum: {
    id: 'id';
    serviceId: 'serviceId';
    title: 'title';
    description: 'description';
    required: 'required';
    showIf: 'showIf';
    orderIndex: 'orderIndex';
    active: 'active';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type ServiceDocumentScalarFieldEnum =
    (typeof ServiceDocumentScalarFieldEnum)[keyof typeof ServiceDocumentScalarFieldEnum];

  export const SystemSettingsScalarFieldEnum: {
    id: 'id';
    siteName: 'siteName';
    siteDescription: 'siteDescription';
    contactEmail: 'contactEmail';
    contactPhone: 'contactPhone';
    address: 'address';
    workingHours: 'workingHours';
    socialLinks: 'socialLinks';
    seoSettings: 'seoSettings';
    updatedAt: 'updatedAt';
  };

  export type SystemSettingsScalarFieldEnum =
    (typeof SystemSettingsScalarFieldEnum)[keyof typeof SystemSettingsScalarFieldEnum];

  export const FormTypeScalarFieldEnum: {
    id: 'id';
    name: 'name';
    description: 'description';
    active: 'active';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type FormTypeScalarFieldEnum =
    (typeof FormTypeScalarFieldEnum)[keyof typeof FormTypeScalarFieldEnum];

  export const FormTypeVariantScalarFieldEnum: {
    id: 'id';
    formTypeId: 'formTypeId';
    serviceVariantId: 'serviceVariantId';
    createdAt: 'createdAt';
  };

  export type FormTypeVariantScalarFieldEnum =
    (typeof FormTypeVariantScalarFieldEnum)[keyof typeof FormTypeVariantScalarFieldEnum];

  export const FormSerialScalarFieldEnum: {
    id: 'id';
    formTypeId: 'formTypeId';
    serialNumber: 'serialNumber';
    orderId: 'orderId';
    consumed: 'consumed';
    consumedAt: 'consumedAt';
    addedByAdminId: 'addedByAdminId';
    consumedByAdminId: 'consumedByAdminId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type FormSerialScalarFieldEnum =
    (typeof FormSerialScalarFieldEnum)[keyof typeof FormSerialScalarFieldEnum];

  export const DependentScalarFieldEnum: {
    id: 'id';
    name: 'name';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    createdByAdminId: 'createdByAdminId';
  };

  export type DependentScalarFieldEnum =
    (typeof DependentScalarFieldEnum)[keyof typeof DependentScalarFieldEnum];

  export const PromoCodeScalarFieldEnum: {
    id: 'id';
    code: 'code';
    type: 'type';
    value: 'value';
    minOrderAmount: 'minOrderAmount';
    maxDiscount: 'maxDiscount';
    startDate: 'startDate';
    endDate: 'endDate';
    usageLimit: 'usageLimit';
    currentUsage: 'currentUsage';
    isActive: 'isActive';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type PromoCodeScalarFieldEnum =
    (typeof PromoCodeScalarFieldEnum)[keyof typeof PromoCodeScalarFieldEnum];

  export const SortOrder: {
    asc: 'asc';
    desc: 'desc';
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

  export const QueryMode: {
    default: 'default';
    insensitive: 'insensitive';
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

  export const NullsOrder: {
    first: 'first';
    last: 'last';
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>;

  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>;

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>;

  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>;

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>;

  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DateTime[]'
  >;

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>;

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>;

  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>;

  /**
   * Deep Input Types
   */

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[];
    OR?: AccountWhereInput[];
    NOT?: AccountWhereInput | AccountWhereInput[];
    id?: StringFilter<'Account'> | string;
    userId?: StringFilter<'Account'> | string;
    type?: StringFilter<'Account'> | string;
    provider?: StringFilter<'Account'> | string;
    providerAccountId?: StringFilter<'Account'> | string;
    refresh_token?: StringNullableFilter<'Account'> | string | null;
    access_token?: StringNullableFilter<'Account'> | string | null;
    expires_at?: IntNullableFilter<'Account'> | number | null;
    token_type?: StringNullableFilter<'Account'> | string | null;
    scope?: StringNullableFilter<'Account'> | string | null;
    id_token?: StringNullableFilter<'Account'> | string | null;
    session_state?: StringNullableFilter<'Account'> | string | null;
    user?: XOR<UserRelationFilter, UserWhereInput>;
  };

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrderInput | SortOrder;
    access_token?: SortOrderInput | SortOrder;
    expires_at?: SortOrderInput | SortOrder;
    token_type?: SortOrderInput | SortOrder;
    scope?: SortOrderInput | SortOrder;
    id_token?: SortOrderInput | SortOrder;
    session_state?: SortOrderInput | SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type AccountWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput;
      AND?: AccountWhereInput | AccountWhereInput[];
      OR?: AccountWhereInput[];
      NOT?: AccountWhereInput | AccountWhereInput[];
      userId?: StringFilter<'Account'> | string;
      type?: StringFilter<'Account'> | string;
      provider?: StringFilter<'Account'> | string;
      providerAccountId?: StringFilter<'Account'> | string;
      refresh_token?: StringNullableFilter<'Account'> | string | null;
      access_token?: StringNullableFilter<'Account'> | string | null;
      expires_at?: IntNullableFilter<'Account'> | number | null;
      token_type?: StringNullableFilter<'Account'> | string | null;
      scope?: StringNullableFilter<'Account'> | string | null;
      id_token?: StringNullableFilter<'Account'> | string | null;
      session_state?: StringNullableFilter<'Account'> | string | null;
      user?: XOR<UserRelationFilter, UserWhereInput>;
    },
    'id' | 'provider_providerAccountId'
  >;

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrderInput | SortOrder;
    access_token?: SortOrderInput | SortOrder;
    expires_at?: SortOrderInput | SortOrder;
    token_type?: SortOrderInput | SortOrder;
    scope?: SortOrderInput | SortOrder;
    id_token?: SortOrderInput | SortOrder;
    session_state?: SortOrderInput | SortOrder;
    _count?: AccountCountOrderByAggregateInput;
    _avg?: AccountAvgOrderByAggregateInput;
    _max?: AccountMaxOrderByAggregateInput;
    _min?: AccountMinOrderByAggregateInput;
    _sum?: AccountSumOrderByAggregateInput;
  };

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[];
    OR?: AccountScalarWhereWithAggregatesInput[];
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Account'> | string;
    userId?: StringWithAggregatesFilter<'Account'> | string;
    type?: StringWithAggregatesFilter<'Account'> | string;
    provider?: StringWithAggregatesFilter<'Account'> | string;
    providerAccountId?: StringWithAggregatesFilter<'Account'> | string;
    refresh_token?: StringNullableWithAggregatesFilter<'Account'> | string | null;
    access_token?: StringNullableWithAggregatesFilter<'Account'> | string | null;
    expires_at?: IntNullableWithAggregatesFilter<'Account'> | number | null;
    token_type?: StringNullableWithAggregatesFilter<'Account'> | string | null;
    scope?: StringNullableWithAggregatesFilter<'Account'> | string | null;
    id_token?: StringNullableWithAggregatesFilter<'Account'> | string | null;
    session_state?: StringNullableWithAggregatesFilter<'Account'> | string | null;
  };

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[];
    OR?: SessionWhereInput[];
    NOT?: SessionWhereInput | SessionWhereInput[];
    id?: StringFilter<'Session'> | string;
    sessionToken?: StringFilter<'Session'> | string;
    userId?: StringFilter<'Session'> | string;
    expires?: DateTimeFilter<'Session'> | Date | string;
    user?: XOR<UserRelationFilter, UserWhereInput>;
  };

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder;
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type SessionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      sessionToken?: string;
      AND?: SessionWhereInput | SessionWhereInput[];
      OR?: SessionWhereInput[];
      NOT?: SessionWhereInput | SessionWhereInput[];
      userId?: StringFilter<'Session'> | string;
      expires?: DateTimeFilter<'Session'> | Date | string;
      user?: XOR<UserRelationFilter, UserWhereInput>;
    },
    'id' | 'sessionToken'
  >;

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder;
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
    _count?: SessionCountOrderByAggregateInput;
    _max?: SessionMaxOrderByAggregateInput;
    _min?: SessionMinOrderByAggregateInput;
  };

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[];
    OR?: SessionScalarWhereWithAggregatesInput[];
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Session'> | string;
    sessionToken?: StringWithAggregatesFilter<'Session'> | string;
    userId?: StringWithAggregatesFilter<'Session'> | string;
    expires?: DateTimeWithAggregatesFilter<'Session'> | Date | string;
  };

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[];
    OR?: VerificationTokenWhereInput[];
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[];
    identifier?: StringFilter<'VerificationToken'> | string;
    token?: StringFilter<'VerificationToken'> | string;
    expires?: DateTimeFilter<'VerificationToken'> | Date | string;
  };

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
  };

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<
    {
      token?: string;
      identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput;
      AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[];
      OR?: VerificationTokenWhereInput[];
      NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[];
      identifier?: StringFilter<'VerificationToken'> | string;
      expires?: DateTimeFilter<'VerificationToken'> | Date | string;
    },
    'token' | 'identifier_token'
  >;

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
    _count?: VerificationTokenCountOrderByAggregateInput;
    _max?: VerificationTokenMaxOrderByAggregateInput;
    _min?: VerificationTokenMinOrderByAggregateInput;
  };

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?:
      | VerificationTokenScalarWhereWithAggregatesInput
      | VerificationTokenScalarWhereWithAggregatesInput[];
    OR?: VerificationTokenScalarWhereWithAggregatesInput[];
    NOT?:
      | VerificationTokenScalarWhereWithAggregatesInput
      | VerificationTokenScalarWhereWithAggregatesInput[];
    identifier?: StringWithAggregatesFilter<'VerificationToken'> | string;
    token?: StringWithAggregatesFilter<'VerificationToken'> | string;
    expires?: DateTimeWithAggregatesFilter<'VerificationToken'> | Date | string;
  };

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[];
    OR?: UserWhereInput[];
    NOT?: UserWhereInput | UserWhereInput[];
    id?: StringFilter<'User'> | string;
    name?: StringNullableFilter<'User'> | string | null;
    email?: StringNullableFilter<'User'> | string | null;
    emailVerified?: DateTimeNullableFilter<'User'> | Date | string | null;
    image?: StringNullableFilter<'User'> | string | null;
    passwordHash?: StringNullableFilter<'User'> | string | null;
    phone?: StringNullableFilter<'User'> | string | null;
    additionalPhone?: StringNullableFilter<'User'> | string | null;
    role?: StringFilter<'User'> | string;
    createdByAdminId?: StringNullableFilter<'User'> | string | null;
    resetToken?: StringNullableFilter<'User'> | string | null;
    resetTokenExpiry?: DateTimeNullableFilter<'User'> | Date | string | null;
    verificationToken?: StringNullableFilter<'User'> | string | null;
    verificationTokenExpiry?: DateTimeNullableFilter<'User'> | Date | string | null;
    verificationCode?: StringNullableFilter<'User'> | string | null;
    verificationCodeExpiry?: DateTimeNullableFilter<'User'> | Date | string | null;
    createdAt?: DateTimeFilter<'User'> | Date | string;
    updatedAt?: DateTimeFilter<'User'> | Date | string;
    address?: StringNullableFilter<'User'> | string | null;
    governorate?: StringNullableFilter<'User'> | string | null;
    city?: StringNullableFilter<'User'> | string | null;
    district?: StringNullableFilter<'User'> | string | null;
    street?: StringNullableFilter<'User'> | string | null;
    buildingNumber?: StringNullableFilter<'User'> | string | null;
    apartmentNumber?: StringNullableFilter<'User'> | string | null;
    landmark?: StringNullableFilter<'User'> | string | null;
    birthDate?: DateTimeNullableFilter<'User'> | Date | string | null;
    fatherName?: StringNullableFilter<'User'> | string | null;
    idNumber?: StringNullableFilter<'User'> | string | null;
    motherName?: StringNullableFilter<'User'> | string | null;
    nationality?: StringNullableFilter<'User'> | string | null;
    wifeName?: StringNullableFilter<'User'> | string | null;
    wifeMotherName?: StringNullableFilter<'User'> | string | null;
    createdByAdmin?: XOR<UserNullableRelationFilter, UserWhereInput> | null;
    createdUsers?: UserListRelationFilter;
    createdOrders?: OrderListRelationFilter;
    orders?: OrderListRelationFilter;
    accounts?: AccountListRelationFilter;
    auditLogs?: AuditLogListRelationFilter;
    sessions?: SessionListRelationFilter;
    addedFormSerials?: FormSerialListRelationFilter;
    consumedFormSerials?: FormSerialListRelationFilter;
    createdDependents?: DependentListRelationFilter;
  };

  export type UserOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrderInput | SortOrder;
    email?: SortOrderInput | SortOrder;
    emailVerified?: SortOrderInput | SortOrder;
    image?: SortOrderInput | SortOrder;
    passwordHash?: SortOrderInput | SortOrder;
    phone?: SortOrderInput | SortOrder;
    additionalPhone?: SortOrderInput | SortOrder;
    role?: SortOrder;
    createdByAdminId?: SortOrderInput | SortOrder;
    resetToken?: SortOrderInput | SortOrder;
    resetTokenExpiry?: SortOrderInput | SortOrder;
    verificationToken?: SortOrderInput | SortOrder;
    verificationTokenExpiry?: SortOrderInput | SortOrder;
    verificationCode?: SortOrderInput | SortOrder;
    verificationCodeExpiry?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    address?: SortOrderInput | SortOrder;
    governorate?: SortOrderInput | SortOrder;
    city?: SortOrderInput | SortOrder;
    district?: SortOrderInput | SortOrder;
    street?: SortOrderInput | SortOrder;
    buildingNumber?: SortOrderInput | SortOrder;
    apartmentNumber?: SortOrderInput | SortOrder;
    landmark?: SortOrderInput | SortOrder;
    birthDate?: SortOrderInput | SortOrder;
    fatherName?: SortOrderInput | SortOrder;
    idNumber?: SortOrderInput | SortOrder;
    motherName?: SortOrderInput | SortOrder;
    nationality?: SortOrderInput | SortOrder;
    wifeName?: SortOrderInput | SortOrder;
    wifeMotherName?: SortOrderInput | SortOrder;
    createdByAdmin?: UserOrderByWithRelationInput;
    createdUsers?: UserOrderByRelationAggregateInput;
    createdOrders?: OrderOrderByRelationAggregateInput;
    orders?: OrderOrderByRelationAggregateInput;
    accounts?: AccountOrderByRelationAggregateInput;
    auditLogs?: AuditLogOrderByRelationAggregateInput;
    sessions?: SessionOrderByRelationAggregateInput;
    addedFormSerials?: FormSerialOrderByRelationAggregateInput;
    consumedFormSerials?: FormSerialOrderByRelationAggregateInput;
    createdDependents?: DependentOrderByRelationAggregateInput;
  };

  export type UserWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      email?: string;
      AND?: UserWhereInput | UserWhereInput[];
      OR?: UserWhereInput[];
      NOT?: UserWhereInput | UserWhereInput[];
      name?: StringNullableFilter<'User'> | string | null;
      emailVerified?: DateTimeNullableFilter<'User'> | Date | string | null;
      image?: StringNullableFilter<'User'> | string | null;
      passwordHash?: StringNullableFilter<'User'> | string | null;
      phone?: StringNullableFilter<'User'> | string | null;
      additionalPhone?: StringNullableFilter<'User'> | string | null;
      role?: StringFilter<'User'> | string;
      createdByAdminId?: StringNullableFilter<'User'> | string | null;
      resetToken?: StringNullableFilter<'User'> | string | null;
      resetTokenExpiry?: DateTimeNullableFilter<'User'> | Date | string | null;
      verificationToken?: StringNullableFilter<'User'> | string | null;
      verificationTokenExpiry?: DateTimeNullableFilter<'User'> | Date | string | null;
      verificationCode?: StringNullableFilter<'User'> | string | null;
      verificationCodeExpiry?: DateTimeNullableFilter<'User'> | Date | string | null;
      createdAt?: DateTimeFilter<'User'> | Date | string;
      updatedAt?: DateTimeFilter<'User'> | Date | string;
      address?: StringNullableFilter<'User'> | string | null;
      governorate?: StringNullableFilter<'User'> | string | null;
      city?: StringNullableFilter<'User'> | string | null;
      district?: StringNullableFilter<'User'> | string | null;
      street?: StringNullableFilter<'User'> | string | null;
      buildingNumber?: StringNullableFilter<'User'> | string | null;
      apartmentNumber?: StringNullableFilter<'User'> | string | null;
      landmark?: StringNullableFilter<'User'> | string | null;
      birthDate?: DateTimeNullableFilter<'User'> | Date | string | null;
      fatherName?: StringNullableFilter<'User'> | string | null;
      idNumber?: StringNullableFilter<'User'> | string | null;
      motherName?: StringNullableFilter<'User'> | string | null;
      nationality?: StringNullableFilter<'User'> | string | null;
      wifeName?: StringNullableFilter<'User'> | string | null;
      wifeMotherName?: StringNullableFilter<'User'> | string | null;
      createdByAdmin?: XOR<UserNullableRelationFilter, UserWhereInput> | null;
      createdUsers?: UserListRelationFilter;
      createdOrders?: OrderListRelationFilter;
      orders?: OrderListRelationFilter;
      accounts?: AccountListRelationFilter;
      auditLogs?: AuditLogListRelationFilter;
      sessions?: SessionListRelationFilter;
      addedFormSerials?: FormSerialListRelationFilter;
      consumedFormSerials?: FormSerialListRelationFilter;
      createdDependents?: DependentListRelationFilter;
    },
    'id' | 'email'
  >;

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrderInput | SortOrder;
    email?: SortOrderInput | SortOrder;
    emailVerified?: SortOrderInput | SortOrder;
    image?: SortOrderInput | SortOrder;
    passwordHash?: SortOrderInput | SortOrder;
    phone?: SortOrderInput | SortOrder;
    additionalPhone?: SortOrderInput | SortOrder;
    role?: SortOrder;
    createdByAdminId?: SortOrderInput | SortOrder;
    resetToken?: SortOrderInput | SortOrder;
    resetTokenExpiry?: SortOrderInput | SortOrder;
    verificationToken?: SortOrderInput | SortOrder;
    verificationTokenExpiry?: SortOrderInput | SortOrder;
    verificationCode?: SortOrderInput | SortOrder;
    verificationCodeExpiry?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    address?: SortOrderInput | SortOrder;
    governorate?: SortOrderInput | SortOrder;
    city?: SortOrderInput | SortOrder;
    district?: SortOrderInput | SortOrder;
    street?: SortOrderInput | SortOrder;
    buildingNumber?: SortOrderInput | SortOrder;
    apartmentNumber?: SortOrderInput | SortOrder;
    landmark?: SortOrderInput | SortOrder;
    birthDate?: SortOrderInput | SortOrder;
    fatherName?: SortOrderInput | SortOrder;
    idNumber?: SortOrderInput | SortOrder;
    motherName?: SortOrderInput | SortOrder;
    nationality?: SortOrderInput | SortOrder;
    wifeName?: SortOrderInput | SortOrder;
    wifeMotherName?: SortOrderInput | SortOrder;
    _count?: UserCountOrderByAggregateInput;
    _max?: UserMaxOrderByAggregateInput;
    _min?: UserMinOrderByAggregateInput;
  };

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[];
    OR?: UserScalarWhereWithAggregatesInput[];
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'User'> | string;
    name?: StringNullableWithAggregatesFilter<'User'> | string | null;
    email?: StringNullableWithAggregatesFilter<'User'> | string | null;
    emailVerified?: DateTimeNullableWithAggregatesFilter<'User'> | Date | string | null;
    image?: StringNullableWithAggregatesFilter<'User'> | string | null;
    passwordHash?: StringNullableWithAggregatesFilter<'User'> | string | null;
    phone?: StringNullableWithAggregatesFilter<'User'> | string | null;
    additionalPhone?: StringNullableWithAggregatesFilter<'User'> | string | null;
    role?: StringWithAggregatesFilter<'User'> | string;
    createdByAdminId?: StringNullableWithAggregatesFilter<'User'> | string | null;
    resetToken?: StringNullableWithAggregatesFilter<'User'> | string | null;
    resetTokenExpiry?: DateTimeNullableWithAggregatesFilter<'User'> | Date | string | null;
    verificationToken?: StringNullableWithAggregatesFilter<'User'> | string | null;
    verificationTokenExpiry?: DateTimeNullableWithAggregatesFilter<'User'> | Date | string | null;
    verificationCode?: StringNullableWithAggregatesFilter<'User'> | string | null;
    verificationCodeExpiry?: DateTimeNullableWithAggregatesFilter<'User'> | Date | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'User'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'User'> | Date | string;
    address?: StringNullableWithAggregatesFilter<'User'> | string | null;
    governorate?: StringNullableWithAggregatesFilter<'User'> | string | null;
    city?: StringNullableWithAggregatesFilter<'User'> | string | null;
    district?: StringNullableWithAggregatesFilter<'User'> | string | null;
    street?: StringNullableWithAggregatesFilter<'User'> | string | null;
    buildingNumber?: StringNullableWithAggregatesFilter<'User'> | string | null;
    apartmentNumber?: StringNullableWithAggregatesFilter<'User'> | string | null;
    landmark?: StringNullableWithAggregatesFilter<'User'> | string | null;
    birthDate?: DateTimeNullableWithAggregatesFilter<'User'> | Date | string | null;
    fatherName?: StringNullableWithAggregatesFilter<'User'> | string | null;
    idNumber?: StringNullableWithAggregatesFilter<'User'> | string | null;
    motherName?: StringNullableWithAggregatesFilter<'User'> | string | null;
    nationality?: StringNullableWithAggregatesFilter<'User'> | string | null;
    wifeName?: StringNullableWithAggregatesFilter<'User'> | string | null;
    wifeMotherName?: StringNullableWithAggregatesFilter<'User'> | string | null;
  };

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[];
    OR?: CategoryWhereInput[];
    NOT?: CategoryWhereInput | CategoryWhereInput[];
    id?: StringFilter<'Category'> | string;
    name?: StringFilter<'Category'> | string;
    slug?: StringFilter<'Category'> | string;
    orderIndex?: IntFilter<'Category'> | number;
    active?: BoolFilter<'Category'> | boolean;
    createdAt?: DateTimeFilter<'Category'> | Date | string;
    updatedAt?: DateTimeFilter<'Category'> | Date | string;
    icon?: StringNullableFilter<'Category'> | string | null;
    services?: ServiceListRelationFilter;
  };

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    orderIndex?: SortOrder;
    active?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    icon?: SortOrderInput | SortOrder;
    services?: ServiceOrderByRelationAggregateInput;
  };

  export type CategoryWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      slug?: string;
      AND?: CategoryWhereInput | CategoryWhereInput[];
      OR?: CategoryWhereInput[];
      NOT?: CategoryWhereInput | CategoryWhereInput[];
      name?: StringFilter<'Category'> | string;
      orderIndex?: IntFilter<'Category'> | number;
      active?: BoolFilter<'Category'> | boolean;
      createdAt?: DateTimeFilter<'Category'> | Date | string;
      updatedAt?: DateTimeFilter<'Category'> | Date | string;
      icon?: StringNullableFilter<'Category'> | string | null;
      services?: ServiceListRelationFilter;
    },
    'id' | 'slug'
  >;

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    orderIndex?: SortOrder;
    active?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    icon?: SortOrderInput | SortOrder;
    _count?: CategoryCountOrderByAggregateInput;
    _avg?: CategoryAvgOrderByAggregateInput;
    _max?: CategoryMaxOrderByAggregateInput;
    _min?: CategoryMinOrderByAggregateInput;
    _sum?: CategorySumOrderByAggregateInput;
  };

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[];
    OR?: CategoryScalarWhereWithAggregatesInput[];
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Category'> | string;
    name?: StringWithAggregatesFilter<'Category'> | string;
    slug?: StringWithAggregatesFilter<'Category'> | string;
    orderIndex?: IntWithAggregatesFilter<'Category'> | number;
    active?: BoolWithAggregatesFilter<'Category'> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<'Category'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Category'> | Date | string;
    icon?: StringNullableWithAggregatesFilter<'Category'> | string | null;
  };

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[];
    OR?: ServiceWhereInput[];
    NOT?: ServiceWhereInput | ServiceWhereInput[];
    id?: StringFilter<'Service'> | string;
    name?: StringFilter<'Service'> | string;
    slug?: StringFilter<'Service'> | string;
    description?: StringNullableFilter<'Service'> | string | null;
    icon?: StringNullableFilter<'Service'> | string | null;
    active?: BoolFilter<'Service'> | boolean;
    categoryId?: StringFilter<'Service'> | string;
    createdAt?: DateTimeFilter<'Service'> | Date | string;
    updatedAt?: DateTimeFilter<'Service'> | Date | string;
    orders?: OrderListRelationFilter;
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>;
    documents?: ServiceDocumentListRelationFilter;
    variants?: ServiceVariantListRelationFilter;
    fields?: ServiceFieldListRelationFilter;
  };

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    description?: SortOrderInput | SortOrder;
    icon?: SortOrderInput | SortOrder;
    active?: SortOrder;
    categoryId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    orders?: OrderOrderByRelationAggregateInput;
    category?: CategoryOrderByWithRelationInput;
    documents?: ServiceDocumentOrderByRelationAggregateInput;
    variants?: ServiceVariantOrderByRelationAggregateInput;
    fields?: ServiceFieldOrderByRelationAggregateInput;
  };

  export type ServiceWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      slug?: string;
      AND?: ServiceWhereInput | ServiceWhereInput[];
      OR?: ServiceWhereInput[];
      NOT?: ServiceWhereInput | ServiceWhereInput[];
      name?: StringFilter<'Service'> | string;
      description?: StringNullableFilter<'Service'> | string | null;
      icon?: StringNullableFilter<'Service'> | string | null;
      active?: BoolFilter<'Service'> | boolean;
      categoryId?: StringFilter<'Service'> | string;
      createdAt?: DateTimeFilter<'Service'> | Date | string;
      updatedAt?: DateTimeFilter<'Service'> | Date | string;
      orders?: OrderListRelationFilter;
      category?: XOR<CategoryRelationFilter, CategoryWhereInput>;
      documents?: ServiceDocumentListRelationFilter;
      variants?: ServiceVariantListRelationFilter;
      fields?: ServiceFieldListRelationFilter;
    },
    'id' | 'slug'
  >;

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    description?: SortOrderInput | SortOrder;
    icon?: SortOrderInput | SortOrder;
    active?: SortOrder;
    categoryId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: ServiceCountOrderByAggregateInput;
    _max?: ServiceMaxOrderByAggregateInput;
    _min?: ServiceMinOrderByAggregateInput;
  };

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[];
    OR?: ServiceScalarWhereWithAggregatesInput[];
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Service'> | string;
    name?: StringWithAggregatesFilter<'Service'> | string;
    slug?: StringWithAggregatesFilter<'Service'> | string;
    description?: StringNullableWithAggregatesFilter<'Service'> | string | null;
    icon?: StringNullableWithAggregatesFilter<'Service'> | string | null;
    active?: BoolWithAggregatesFilter<'Service'> | boolean;
    categoryId?: StringWithAggregatesFilter<'Service'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'Service'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Service'> | Date | string;
  };

  export type ServiceFieldWhereInput = {
    AND?: ServiceFieldWhereInput | ServiceFieldWhereInput[];
    OR?: ServiceFieldWhereInput[];
    NOT?: ServiceFieldWhereInput | ServiceFieldWhereInput[];
    id?: StringFilter<'ServiceField'> | string;
    serviceId?: StringFilter<'ServiceField'> | string;
    name?: StringFilter<'ServiceField'> | string;
    label?: StringFilter<'ServiceField'> | string;
    type?: StringFilter<'ServiceField'> | string;
    placeholder?: StringNullableFilter<'ServiceField'> | string | null;
    required?: BoolFilter<'ServiceField'> | boolean;
    orderIndex?: IntFilter<'ServiceField'> | number;
    active?: BoolFilter<'ServiceField'> | boolean;
    showIf?: StringNullableFilter<'ServiceField'> | string | null;
    validation?: StringNullableFilter<'ServiceField'> | string | null;
    createdAt?: DateTimeFilter<'ServiceField'> | Date | string;
    updatedAt?: DateTimeFilter<'ServiceField'> | Date | string;
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>;
    options?: ServiceFieldOptionListRelationFilter;
  };

  export type ServiceFieldOrderByWithRelationInput = {
    id?: SortOrder;
    serviceId?: SortOrder;
    name?: SortOrder;
    label?: SortOrder;
    type?: SortOrder;
    placeholder?: SortOrderInput | SortOrder;
    required?: SortOrder;
    orderIndex?: SortOrder;
    active?: SortOrder;
    showIf?: SortOrderInput | SortOrder;
    validation?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    service?: ServiceOrderByWithRelationInput;
    options?: ServiceFieldOptionOrderByRelationAggregateInput;
  };

  export type ServiceFieldWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ServiceFieldWhereInput | ServiceFieldWhereInput[];
      OR?: ServiceFieldWhereInput[];
      NOT?: ServiceFieldWhereInput | ServiceFieldWhereInput[];
      serviceId?: StringFilter<'ServiceField'> | string;
      name?: StringFilter<'ServiceField'> | string;
      label?: StringFilter<'ServiceField'> | string;
      type?: StringFilter<'ServiceField'> | string;
      placeholder?: StringNullableFilter<'ServiceField'> | string | null;
      required?: BoolFilter<'ServiceField'> | boolean;
      orderIndex?: IntFilter<'ServiceField'> | number;
      active?: BoolFilter<'ServiceField'> | boolean;
      showIf?: StringNullableFilter<'ServiceField'> | string | null;
      validation?: StringNullableFilter<'ServiceField'> | string | null;
      createdAt?: DateTimeFilter<'ServiceField'> | Date | string;
      updatedAt?: DateTimeFilter<'ServiceField'> | Date | string;
      service?: XOR<ServiceRelationFilter, ServiceWhereInput>;
      options?: ServiceFieldOptionListRelationFilter;
    },
    'id'
  >;

  export type ServiceFieldOrderByWithAggregationInput = {
    id?: SortOrder;
    serviceId?: SortOrder;
    name?: SortOrder;
    label?: SortOrder;
    type?: SortOrder;
    placeholder?: SortOrderInput | SortOrder;
    required?: SortOrder;
    orderIndex?: SortOrder;
    active?: SortOrder;
    showIf?: SortOrderInput | SortOrder;
    validation?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: ServiceFieldCountOrderByAggregateInput;
    _avg?: ServiceFieldAvgOrderByAggregateInput;
    _max?: ServiceFieldMaxOrderByAggregateInput;
    _min?: ServiceFieldMinOrderByAggregateInput;
    _sum?: ServiceFieldSumOrderByAggregateInput;
  };

  export type ServiceFieldScalarWhereWithAggregatesInput = {
    AND?: ServiceFieldScalarWhereWithAggregatesInput | ServiceFieldScalarWhereWithAggregatesInput[];
    OR?: ServiceFieldScalarWhereWithAggregatesInput[];
    NOT?: ServiceFieldScalarWhereWithAggregatesInput | ServiceFieldScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'ServiceField'> | string;
    serviceId?: StringWithAggregatesFilter<'ServiceField'> | string;
    name?: StringWithAggregatesFilter<'ServiceField'> | string;
    label?: StringWithAggregatesFilter<'ServiceField'> | string;
    type?: StringWithAggregatesFilter<'ServiceField'> | string;
    placeholder?: StringNullableWithAggregatesFilter<'ServiceField'> | string | null;
    required?: BoolWithAggregatesFilter<'ServiceField'> | boolean;
    orderIndex?: IntWithAggregatesFilter<'ServiceField'> | number;
    active?: BoolWithAggregatesFilter<'ServiceField'> | boolean;
    showIf?: StringNullableWithAggregatesFilter<'ServiceField'> | string | null;
    validation?: StringNullableWithAggregatesFilter<'ServiceField'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'ServiceField'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'ServiceField'> | Date | string;
  };

  export type ServiceFieldOptionWhereInput = {
    AND?: ServiceFieldOptionWhereInput | ServiceFieldOptionWhereInput[];
    OR?: ServiceFieldOptionWhereInput[];
    NOT?: ServiceFieldOptionWhereInput | ServiceFieldOptionWhereInput[];
    id?: StringFilter<'ServiceFieldOption'> | string;
    fieldId?: StringFilter<'ServiceFieldOption'> | string;
    value?: StringFilter<'ServiceFieldOption'> | string;
    label?: StringFilter<'ServiceFieldOption'> | string;
    orderIndex?: IntFilter<'ServiceFieldOption'> | number;
    requiredDocs?: StringNullableFilter<'ServiceFieldOption'> | string | null;
    showFields?: StringNullableFilter<'ServiceFieldOption'> | string | null;
    createdAt?: DateTimeFilter<'ServiceFieldOption'> | Date | string;
    field?: XOR<ServiceFieldRelationFilter, ServiceFieldWhereInput>;
  };

  export type ServiceFieldOptionOrderByWithRelationInput = {
    id?: SortOrder;
    fieldId?: SortOrder;
    value?: SortOrder;
    label?: SortOrder;
    orderIndex?: SortOrder;
    requiredDocs?: SortOrderInput | SortOrder;
    showFields?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    field?: ServiceFieldOrderByWithRelationInput;
  };

  export type ServiceFieldOptionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ServiceFieldOptionWhereInput | ServiceFieldOptionWhereInput[];
      OR?: ServiceFieldOptionWhereInput[];
      NOT?: ServiceFieldOptionWhereInput | ServiceFieldOptionWhereInput[];
      fieldId?: StringFilter<'ServiceFieldOption'> | string;
      value?: StringFilter<'ServiceFieldOption'> | string;
      label?: StringFilter<'ServiceFieldOption'> | string;
      orderIndex?: IntFilter<'ServiceFieldOption'> | number;
      requiredDocs?: StringNullableFilter<'ServiceFieldOption'> | string | null;
      showFields?: StringNullableFilter<'ServiceFieldOption'> | string | null;
      createdAt?: DateTimeFilter<'ServiceFieldOption'> | Date | string;
      field?: XOR<ServiceFieldRelationFilter, ServiceFieldWhereInput>;
    },
    'id'
  >;

  export type ServiceFieldOptionOrderByWithAggregationInput = {
    id?: SortOrder;
    fieldId?: SortOrder;
    value?: SortOrder;
    label?: SortOrder;
    orderIndex?: SortOrder;
    requiredDocs?: SortOrderInput | SortOrder;
    showFields?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    _count?: ServiceFieldOptionCountOrderByAggregateInput;
    _avg?: ServiceFieldOptionAvgOrderByAggregateInput;
    _max?: ServiceFieldOptionMaxOrderByAggregateInput;
    _min?: ServiceFieldOptionMinOrderByAggregateInput;
    _sum?: ServiceFieldOptionSumOrderByAggregateInput;
  };

  export type ServiceFieldOptionScalarWhereWithAggregatesInput = {
    AND?:
      | ServiceFieldOptionScalarWhereWithAggregatesInput
      | ServiceFieldOptionScalarWhereWithAggregatesInput[];
    OR?: ServiceFieldOptionScalarWhereWithAggregatesInput[];
    NOT?:
      | ServiceFieldOptionScalarWhereWithAggregatesInput
      | ServiceFieldOptionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'ServiceFieldOption'> | string;
    fieldId?: StringWithAggregatesFilter<'ServiceFieldOption'> | string;
    value?: StringWithAggregatesFilter<'ServiceFieldOption'> | string;
    label?: StringWithAggregatesFilter<'ServiceFieldOption'> | string;
    orderIndex?: IntWithAggregatesFilter<'ServiceFieldOption'> | number;
    requiredDocs?: StringNullableWithAggregatesFilter<'ServiceFieldOption'> | string | null;
    showFields?: StringNullableWithAggregatesFilter<'ServiceFieldOption'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'ServiceFieldOption'> | Date | string;
  };

  export type ServiceVariantWhereInput = {
    AND?: ServiceVariantWhereInput | ServiceVariantWhereInput[];
    OR?: ServiceVariantWhereInput[];
    NOT?: ServiceVariantWhereInput | ServiceVariantWhereInput[];
    id?: StringFilter<'ServiceVariant'> | string;
    name?: StringFilter<'ServiceVariant'> | string;
    priceCents?: IntFilter<'ServiceVariant'> | number;
    etaDays?: IntFilter<'ServiceVariant'> | number;
    serviceId?: StringFilter<'ServiceVariant'> | string;
    active?: BoolFilter<'ServiceVariant'> | boolean;
    createdAt?: DateTimeFilter<'ServiceVariant'> | Date | string;
    updatedAt?: DateTimeFilter<'ServiceVariant'> | Date | string;
    orders?: OrderListRelationFilter;
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>;
    formTypeLinks?: FormTypeVariantListRelationFilter;
  };

  export type ServiceVariantOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    priceCents?: SortOrder;
    etaDays?: SortOrder;
    serviceId?: SortOrder;
    active?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    orders?: OrderOrderByRelationAggregateInput;
    service?: ServiceOrderByWithRelationInput;
    formTypeLinks?: FormTypeVariantOrderByRelationAggregateInput;
  };

  export type ServiceVariantWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ServiceVariantWhereInput | ServiceVariantWhereInput[];
      OR?: ServiceVariantWhereInput[];
      NOT?: ServiceVariantWhereInput | ServiceVariantWhereInput[];
      name?: StringFilter<'ServiceVariant'> | string;
      priceCents?: IntFilter<'ServiceVariant'> | number;
      etaDays?: IntFilter<'ServiceVariant'> | number;
      serviceId?: StringFilter<'ServiceVariant'> | string;
      active?: BoolFilter<'ServiceVariant'> | boolean;
      createdAt?: DateTimeFilter<'ServiceVariant'> | Date | string;
      updatedAt?: DateTimeFilter<'ServiceVariant'> | Date | string;
      orders?: OrderListRelationFilter;
      service?: XOR<ServiceRelationFilter, ServiceWhereInput>;
      formTypeLinks?: FormTypeVariantListRelationFilter;
    },
    'id'
  >;

  export type ServiceVariantOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    priceCents?: SortOrder;
    etaDays?: SortOrder;
    serviceId?: SortOrder;
    active?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: ServiceVariantCountOrderByAggregateInput;
    _avg?: ServiceVariantAvgOrderByAggregateInput;
    _max?: ServiceVariantMaxOrderByAggregateInput;
    _min?: ServiceVariantMinOrderByAggregateInput;
    _sum?: ServiceVariantSumOrderByAggregateInput;
  };

  export type ServiceVariantScalarWhereWithAggregatesInput = {
    AND?:
      | ServiceVariantScalarWhereWithAggregatesInput
      | ServiceVariantScalarWhereWithAggregatesInput[];
    OR?: ServiceVariantScalarWhereWithAggregatesInput[];
    NOT?:
      | ServiceVariantScalarWhereWithAggregatesInput
      | ServiceVariantScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'ServiceVariant'> | string;
    name?: StringWithAggregatesFilter<'ServiceVariant'> | string;
    priceCents?: IntWithAggregatesFilter<'ServiceVariant'> | number;
    etaDays?: IntWithAggregatesFilter<'ServiceVariant'> | number;
    serviceId?: StringWithAggregatesFilter<'ServiceVariant'> | string;
    active?: BoolWithAggregatesFilter<'ServiceVariant'> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<'ServiceVariant'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'ServiceVariant'> | Date | string;
  };

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[];
    OR?: OrderWhereInput[];
    NOT?: OrderWhereInput | OrderWhereInput[];
    id?: StringFilter<'Order'> | string;
    userId?: StringFilter<'Order'> | string;
    serviceId?: StringFilter<'Order'> | string;
    variantId?: StringFilter<'Order'> | string;
    status?: StringFilter<'Order'> | string;
    totalPrice?: IntFilter<'Order'> | number;
    totalCents?: IntFilter<'Order'> | number;
    customerName?: StringFilter<'Order'> | string;
    customerPhone?: StringFilter<'Order'> | string;
    additionalPhone?: StringNullableFilter<'Order'> | string | null;
    customerEmail?: StringFilter<'Order'> | string;
    address?: StringNullableFilter<'Order'> | string | null;
    governorate?: StringNullableFilter<'Order'> | string | null;
    city?: StringNullableFilter<'Order'> | string | null;
    district?: StringNullableFilter<'Order'> | string | null;
    street?: StringNullableFilter<'Order'> | string | null;
    buildingNumber?: StringNullableFilter<'Order'> | string | null;
    apartmentNumber?: StringNullableFilter<'Order'> | string | null;
    landmark?: StringNullableFilter<'Order'> | string | null;
    notes?: StringNullableFilter<'Order'> | string | null;
    adminNotes?: StringNullableFilter<'Order'> | string | null;
    createdAt?: DateTimeFilter<'Order'> | Date | string;
    updatedAt?: DateTimeFilter<'Order'> | Date | string;
    completedAt?: DateTimeNullableFilter<'Order'> | Date | string | null;
    estimatedCompletionDate?: DateTimeNullableFilter<'Order'> | Date | string | null;
    deliveryFee?: IntFilter<'Order'> | number;
    deliveryType?: StringFilter<'Order'> | string;
    createdByAdminId?: StringNullableFilter<'Order'> | string | null;
    birthDate?: DateTimeNullableFilter<'Order'> | Date | string | null;
    fatherName?: StringNullableFilter<'Order'> | string | null;
    idNumber?: StringNullableFilter<'Order'> | string | null;
    motherName?: StringNullableFilter<'Order'> | string | null;
    nationality?: StringNullableFilter<'Order'> | string | null;
    wifeName?: StringNullableFilter<'Order'> | string | null;
    photographyLocation?: StringNullableFilter<'Order'> | string | null;
    photographyDate?: DateTimeNullableFilter<'Order'> | Date | string | null;
    marriageDate?: DateTimeNullableFilter<'Order'> | Date | string | null;
    divorceDate?: DateTimeNullableFilter<'Order'> | Date | string | null;
    wifeMotherName?: StringNullableFilter<'Order'> | string | null;
    quantity?: IntFilter<'Order'> | number;
    serviceDetails?: StringNullableFilter<'Order'> | string | null;
    otherFees?: IntFilter<'Order'> | number;
    discount?: IntFilter<'Order'> | number;
    gender?: StringNullableFilter<'Order'> | string | null;
    policeStation?: StringNullableFilter<'Order'> | string | null;
    pickupLocation?: StringNullableFilter<'Order'> | string | null;
    originalDocuments?: StringNullableFilter<'Order'> | string | null;
    attachedDocuments?: StringNullableFilter<'Order'> | string | null;
    hasAttachments?: BoolFilter<'Order'> | boolean;
    selectedFines?: StringNullableFilter<'Order'> | string | null;
    finesDetails?: StringNullableFilter<'Order'> | string | null;
    servicesDetails?: StringNullableFilter<'Order'> | string | null;
    customerFollowUp?: StringNullableFilter<'Order'> | string | null;
    promoCodeId?: StringNullableFilter<'Order'> | string | null;
    discountAmount?: IntFilter<'Order'> | number;
    createdByAdmin?: XOR<UserNullableRelationFilter, UserWhereInput> | null;
    documents?: DocumentListRelationFilter;
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>;
    user?: XOR<UserRelationFilter, UserWhereInput>;
    variant?: XOR<ServiceVariantRelationFilter, ServiceVariantWhereInput>;
    orderDocuments?: OrderDocumentListRelationFilter;
    payment?: XOR<PaymentNullableRelationFilter, PaymentWhereInput> | null;
    formSerials?: FormSerialListRelationFilter;
    promoCode?: XOR<PromoCodeNullableRelationFilter, PromoCodeWhereInput> | null;
  };

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    serviceId?: SortOrder;
    variantId?: SortOrder;
    status?: SortOrder;
    totalPrice?: SortOrder;
    totalCents?: SortOrder;
    customerName?: SortOrder;
    customerPhone?: SortOrder;
    additionalPhone?: SortOrderInput | SortOrder;
    customerEmail?: SortOrder;
    address?: SortOrderInput | SortOrder;
    governorate?: SortOrderInput | SortOrder;
    city?: SortOrderInput | SortOrder;
    district?: SortOrderInput | SortOrder;
    street?: SortOrderInput | SortOrder;
    buildingNumber?: SortOrderInput | SortOrder;
    apartmentNumber?: SortOrderInput | SortOrder;
    landmark?: SortOrderInput | SortOrder;
    notes?: SortOrderInput | SortOrder;
    adminNotes?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    completedAt?: SortOrderInput | SortOrder;
    estimatedCompletionDate?: SortOrderInput | SortOrder;
    deliveryFee?: SortOrder;
    deliveryType?: SortOrder;
    createdByAdminId?: SortOrderInput | SortOrder;
    birthDate?: SortOrderInput | SortOrder;
    fatherName?: SortOrderInput | SortOrder;
    idNumber?: SortOrderInput | SortOrder;
    motherName?: SortOrderInput | SortOrder;
    nationality?: SortOrderInput | SortOrder;
    wifeName?: SortOrderInput | SortOrder;
    photographyLocation?: SortOrderInput | SortOrder;
    photographyDate?: SortOrderInput | SortOrder;
    marriageDate?: SortOrderInput | SortOrder;
    divorceDate?: SortOrderInput | SortOrder;
    wifeMotherName?: SortOrderInput | SortOrder;
    quantity?: SortOrder;
    serviceDetails?: SortOrderInput | SortOrder;
    otherFees?: SortOrder;
    discount?: SortOrder;
    gender?: SortOrderInput | SortOrder;
    policeStation?: SortOrderInput | SortOrder;
    pickupLocation?: SortOrderInput | SortOrder;
    originalDocuments?: SortOrderInput | SortOrder;
    attachedDocuments?: SortOrderInput | SortOrder;
    hasAttachments?: SortOrder;
    selectedFines?: SortOrderInput | SortOrder;
    finesDetails?: SortOrderInput | SortOrder;
    servicesDetails?: SortOrderInput | SortOrder;
    customerFollowUp?: SortOrderInput | SortOrder;
    promoCodeId?: SortOrderInput | SortOrder;
    discountAmount?: SortOrder;
    createdByAdmin?: UserOrderByWithRelationInput;
    documents?: DocumentOrderByRelationAggregateInput;
    service?: ServiceOrderByWithRelationInput;
    user?: UserOrderByWithRelationInput;
    variant?: ServiceVariantOrderByWithRelationInput;
    orderDocuments?: OrderDocumentOrderByRelationAggregateInput;
    payment?: PaymentOrderByWithRelationInput;
    formSerials?: FormSerialOrderByRelationAggregateInput;
    promoCode?: PromoCodeOrderByWithRelationInput;
  };

  export type OrderWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: OrderWhereInput | OrderWhereInput[];
      OR?: OrderWhereInput[];
      NOT?: OrderWhereInput | OrderWhereInput[];
      userId?: StringFilter<'Order'> | string;
      serviceId?: StringFilter<'Order'> | string;
      variantId?: StringFilter<'Order'> | string;
      status?: StringFilter<'Order'> | string;
      totalPrice?: IntFilter<'Order'> | number;
      totalCents?: IntFilter<'Order'> | number;
      customerName?: StringFilter<'Order'> | string;
      customerPhone?: StringFilter<'Order'> | string;
      additionalPhone?: StringNullableFilter<'Order'> | string | null;
      customerEmail?: StringFilter<'Order'> | string;
      address?: StringNullableFilter<'Order'> | string | null;
      governorate?: StringNullableFilter<'Order'> | string | null;
      city?: StringNullableFilter<'Order'> | string | null;
      district?: StringNullableFilter<'Order'> | string | null;
      street?: StringNullableFilter<'Order'> | string | null;
      buildingNumber?: StringNullableFilter<'Order'> | string | null;
      apartmentNumber?: StringNullableFilter<'Order'> | string | null;
      landmark?: StringNullableFilter<'Order'> | string | null;
      notes?: StringNullableFilter<'Order'> | string | null;
      adminNotes?: StringNullableFilter<'Order'> | string | null;
      createdAt?: DateTimeFilter<'Order'> | Date | string;
      updatedAt?: DateTimeFilter<'Order'> | Date | string;
      completedAt?: DateTimeNullableFilter<'Order'> | Date | string | null;
      estimatedCompletionDate?: DateTimeNullableFilter<'Order'> | Date | string | null;
      deliveryFee?: IntFilter<'Order'> | number;
      deliveryType?: StringFilter<'Order'> | string;
      createdByAdminId?: StringNullableFilter<'Order'> | string | null;
      birthDate?: DateTimeNullableFilter<'Order'> | Date | string | null;
      fatherName?: StringNullableFilter<'Order'> | string | null;
      idNumber?: StringNullableFilter<'Order'> | string | null;
      motherName?: StringNullableFilter<'Order'> | string | null;
      nationality?: StringNullableFilter<'Order'> | string | null;
      wifeName?: StringNullableFilter<'Order'> | string | null;
      photographyLocation?: StringNullableFilter<'Order'> | string | null;
      photographyDate?: DateTimeNullableFilter<'Order'> | Date | string | null;
      marriageDate?: DateTimeNullableFilter<'Order'> | Date | string | null;
      divorceDate?: DateTimeNullableFilter<'Order'> | Date | string | null;
      wifeMotherName?: StringNullableFilter<'Order'> | string | null;
      quantity?: IntFilter<'Order'> | number;
      serviceDetails?: StringNullableFilter<'Order'> | string | null;
      otherFees?: IntFilter<'Order'> | number;
      discount?: IntFilter<'Order'> | number;
      gender?: StringNullableFilter<'Order'> | string | null;
      policeStation?: StringNullableFilter<'Order'> | string | null;
      pickupLocation?: StringNullableFilter<'Order'> | string | null;
      originalDocuments?: StringNullableFilter<'Order'> | string | null;
      attachedDocuments?: StringNullableFilter<'Order'> | string | null;
      hasAttachments?: BoolFilter<'Order'> | boolean;
      selectedFines?: StringNullableFilter<'Order'> | string | null;
      finesDetails?: StringNullableFilter<'Order'> | string | null;
      servicesDetails?: StringNullableFilter<'Order'> | string | null;
      customerFollowUp?: StringNullableFilter<'Order'> | string | null;
      promoCodeId?: StringNullableFilter<'Order'> | string | null;
      discountAmount?: IntFilter<'Order'> | number;
      createdByAdmin?: XOR<UserNullableRelationFilter, UserWhereInput> | null;
      documents?: DocumentListRelationFilter;
      service?: XOR<ServiceRelationFilter, ServiceWhereInput>;
      user?: XOR<UserRelationFilter, UserWhereInput>;
      variant?: XOR<ServiceVariantRelationFilter, ServiceVariantWhereInput>;
      orderDocuments?: OrderDocumentListRelationFilter;
      payment?: XOR<PaymentNullableRelationFilter, PaymentWhereInput> | null;
      formSerials?: FormSerialListRelationFilter;
      promoCode?: XOR<PromoCodeNullableRelationFilter, PromoCodeWhereInput> | null;
    },
    'id'
  >;

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    serviceId?: SortOrder;
    variantId?: SortOrder;
    status?: SortOrder;
    totalPrice?: SortOrder;
    totalCents?: SortOrder;
    customerName?: SortOrder;
    customerPhone?: SortOrder;
    additionalPhone?: SortOrderInput | SortOrder;
    customerEmail?: SortOrder;
    address?: SortOrderInput | SortOrder;
    governorate?: SortOrderInput | SortOrder;
    city?: SortOrderInput | SortOrder;
    district?: SortOrderInput | SortOrder;
    street?: SortOrderInput | SortOrder;
    buildingNumber?: SortOrderInput | SortOrder;
    apartmentNumber?: SortOrderInput | SortOrder;
    landmark?: SortOrderInput | SortOrder;
    notes?: SortOrderInput | SortOrder;
    adminNotes?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    completedAt?: SortOrderInput | SortOrder;
    estimatedCompletionDate?: SortOrderInput | SortOrder;
    deliveryFee?: SortOrder;
    deliveryType?: SortOrder;
    createdByAdminId?: SortOrderInput | SortOrder;
    birthDate?: SortOrderInput | SortOrder;
    fatherName?: SortOrderInput | SortOrder;
    idNumber?: SortOrderInput | SortOrder;
    motherName?: SortOrderInput | SortOrder;
    nationality?: SortOrderInput | SortOrder;
    wifeName?: SortOrderInput | SortOrder;
    photographyLocation?: SortOrderInput | SortOrder;
    photographyDate?: SortOrderInput | SortOrder;
    marriageDate?: SortOrderInput | SortOrder;
    divorceDate?: SortOrderInput | SortOrder;
    wifeMotherName?: SortOrderInput | SortOrder;
    quantity?: SortOrder;
    serviceDetails?: SortOrderInput | SortOrder;
    otherFees?: SortOrder;
    discount?: SortOrder;
    gender?: SortOrderInput | SortOrder;
    policeStation?: SortOrderInput | SortOrder;
    pickupLocation?: SortOrderInput | SortOrder;
    originalDocuments?: SortOrderInput | SortOrder;
    attachedDocuments?: SortOrderInput | SortOrder;
    hasAttachments?: SortOrder;
    selectedFines?: SortOrderInput | SortOrder;
    finesDetails?: SortOrderInput | SortOrder;
    servicesDetails?: SortOrderInput | SortOrder;
    customerFollowUp?: SortOrderInput | SortOrder;
    promoCodeId?: SortOrderInput | SortOrder;
    discountAmount?: SortOrder;
    _count?: OrderCountOrderByAggregateInput;
    _avg?: OrderAvgOrderByAggregateInput;
    _max?: OrderMaxOrderByAggregateInput;
    _min?: OrderMinOrderByAggregateInput;
    _sum?: OrderSumOrderByAggregateInput;
  };

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[];
    OR?: OrderScalarWhereWithAggregatesInput[];
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Order'> | string;
    userId?: StringWithAggregatesFilter<'Order'> | string;
    serviceId?: StringWithAggregatesFilter<'Order'> | string;
    variantId?: StringWithAggregatesFilter<'Order'> | string;
    status?: StringWithAggregatesFilter<'Order'> | string;
    totalPrice?: IntWithAggregatesFilter<'Order'> | number;
    totalCents?: IntWithAggregatesFilter<'Order'> | number;
    customerName?: StringWithAggregatesFilter<'Order'> | string;
    customerPhone?: StringWithAggregatesFilter<'Order'> | string;
    additionalPhone?: StringNullableWithAggregatesFilter<'Order'> | string | null;
    customerEmail?: StringWithAggregatesFilter<'Order'> | string;
    address?: StringNullableWithAggregatesFilter<'Order'> | string | null;
    governorate?: StringNullableWithAggregatesFilter<'Order'> | string | null;
    city?: StringNullableWithAggregatesFilter<'Order'> | string | null;
    district?: StringNullableWithAggregatesFilter<'Order'> | string | null;
    street?: StringNullableWithAggregatesFilter<'Order'> | string | null;
    buildingNumber?: StringNullableWithAggregatesFilter<'Order'> | string | null;
    apartmentNumber?: StringNullableWithAggregatesFilter<'Order'> | string | null;
    landmark?: StringNullableWithAggregatesFilter<'Order'> | string | null;
    notes?: StringNullableWithAggregatesFilter<'Order'> | string | null;
    adminNotes?: StringNullableWithAggregatesFilter<'Order'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'Order'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Order'> | Date | string;
    completedAt?: DateTimeNullableWithAggregatesFilter<'Order'> | Date | string | null;
    estimatedCompletionDate?: DateTimeNullableWithAggregatesFilter<'Order'> | Date | string | null;
    deliveryFee?: IntWithAggregatesFilter<'Order'> | number;
    deliveryType?: StringWithAggregatesFilter<'Order'> | string;
    createdByAdminId?: StringNullableWithAggregatesFilter<'Order'> | string | null;
    birthDate?: DateTimeNullableWithAggregatesFilter<'Order'> | Date | string | null;
    fatherName?: StringNullableWithAggregatesFilter<'Order'> | string | null;
    idNumber?: StringNullableWithAggregatesFilter<'Order'> | string | null;
    motherName?: StringNullableWithAggregatesFilter<'Order'> | string | null;
    nationality?: StringNullableWithAggregatesFilter<'Order'> | string | null;
    wifeName?: StringNullableWithAggregatesFilter<'Order'> | string | null;
    photographyLocation?: StringNullableWithAggregatesFilter<'Order'> | string | null;
    photographyDate?: DateTimeNullableWithAggregatesFilter<'Order'> | Date | string | null;
    marriageDate?: DateTimeNullableWithAggregatesFilter<'Order'> | Date | string | null;
    divorceDate?: DateTimeNullableWithAggregatesFilter<'Order'> | Date | string | null;
    wifeMotherName?: StringNullableWithAggregatesFilter<'Order'> | string | null;
    quantity?: IntWithAggregatesFilter<'Order'> | number;
    serviceDetails?: StringNullableWithAggregatesFilter<'Order'> | string | null;
    otherFees?: IntWithAggregatesFilter<'Order'> | number;
    discount?: IntWithAggregatesFilter<'Order'> | number;
    gender?: StringNullableWithAggregatesFilter<'Order'> | string | null;
    policeStation?: StringNullableWithAggregatesFilter<'Order'> | string | null;
    pickupLocation?: StringNullableWithAggregatesFilter<'Order'> | string | null;
    originalDocuments?: StringNullableWithAggregatesFilter<'Order'> | string | null;
    attachedDocuments?: StringNullableWithAggregatesFilter<'Order'> | string | null;
    hasAttachments?: BoolWithAggregatesFilter<'Order'> | boolean;
    selectedFines?: StringNullableWithAggregatesFilter<'Order'> | string | null;
    finesDetails?: StringNullableWithAggregatesFilter<'Order'> | string | null;
    servicesDetails?: StringNullableWithAggregatesFilter<'Order'> | string | null;
    customerFollowUp?: StringNullableWithAggregatesFilter<'Order'> | string | null;
    promoCodeId?: StringNullableWithAggregatesFilter<'Order'> | string | null;
    discountAmount?: IntWithAggregatesFilter<'Order'> | number;
  };

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[];
    OR?: PaymentWhereInput[];
    NOT?: PaymentWhereInput | PaymentWhereInput[];
    id?: StringFilter<'Payment'> | string;
    orderId?: StringFilter<'Payment'> | string;
    amount?: IntFilter<'Payment'> | number;
    currency?: StringFilter<'Payment'> | string;
    method?: StringFilter<'Payment'> | string;
    status?: StringFilter<'Payment'> | string;
    createdAt?: DateTimeFilter<'Payment'> | Date | string;
    updatedAt?: DateTimeFilter<'Payment'> | Date | string;
    paymentScreenshot?: StringNullableFilter<'Payment'> | string | null;
    senderPhone?: StringNullableFilter<'Payment'> | string | null;
    notes?: StringNullableFilter<'Payment'> | string | null;
    order?: XOR<OrderRelationFilter, OrderWhereInput>;
  };

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    amount?: SortOrder;
    currency?: SortOrder;
    method?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    paymentScreenshot?: SortOrderInput | SortOrder;
    senderPhone?: SortOrderInput | SortOrder;
    notes?: SortOrderInput | SortOrder;
    order?: OrderOrderByWithRelationInput;
  };

  export type PaymentWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      orderId?: string;
      AND?: PaymentWhereInput | PaymentWhereInput[];
      OR?: PaymentWhereInput[];
      NOT?: PaymentWhereInput | PaymentWhereInput[];
      amount?: IntFilter<'Payment'> | number;
      currency?: StringFilter<'Payment'> | string;
      method?: StringFilter<'Payment'> | string;
      status?: StringFilter<'Payment'> | string;
      createdAt?: DateTimeFilter<'Payment'> | Date | string;
      updatedAt?: DateTimeFilter<'Payment'> | Date | string;
      paymentScreenshot?: StringNullableFilter<'Payment'> | string | null;
      senderPhone?: StringNullableFilter<'Payment'> | string | null;
      notes?: StringNullableFilter<'Payment'> | string | null;
      order?: XOR<OrderRelationFilter, OrderWhereInput>;
    },
    'id' | 'orderId'
  >;

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    amount?: SortOrder;
    currency?: SortOrder;
    method?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    paymentScreenshot?: SortOrderInput | SortOrder;
    senderPhone?: SortOrderInput | SortOrder;
    notes?: SortOrderInput | SortOrder;
    _count?: PaymentCountOrderByAggregateInput;
    _avg?: PaymentAvgOrderByAggregateInput;
    _max?: PaymentMaxOrderByAggregateInput;
    _min?: PaymentMinOrderByAggregateInput;
    _sum?: PaymentSumOrderByAggregateInput;
  };

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[];
    OR?: PaymentScalarWhereWithAggregatesInput[];
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Payment'> | string;
    orderId?: StringWithAggregatesFilter<'Payment'> | string;
    amount?: IntWithAggregatesFilter<'Payment'> | number;
    currency?: StringWithAggregatesFilter<'Payment'> | string;
    method?: StringWithAggregatesFilter<'Payment'> | string;
    status?: StringWithAggregatesFilter<'Payment'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'Payment'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Payment'> | Date | string;
    paymentScreenshot?: StringNullableWithAggregatesFilter<'Payment'> | string | null;
    senderPhone?: StringNullableWithAggregatesFilter<'Payment'> | string | null;
    notes?: StringNullableWithAggregatesFilter<'Payment'> | string | null;
  };

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[];
    OR?: AuditLogWhereInput[];
    NOT?: AuditLogWhereInput | AuditLogWhereInput[];
    id?: StringFilter<'AuditLog'> | string;
    userId?: StringNullableFilter<'AuditLog'> | string | null;
    action?: StringFilter<'AuditLog'> | string;
    entityType?: StringFilter<'AuditLog'> | string;
    entityId?: StringNullableFilter<'AuditLog'> | string | null;
    oldValues?: StringNullableFilter<'AuditLog'> | string | null;
    newValues?: StringNullableFilter<'AuditLog'> | string | null;
    ipAddress?: StringNullableFilter<'AuditLog'> | string | null;
    userAgent?: StringNullableFilter<'AuditLog'> | string | null;
    createdAt?: DateTimeFilter<'AuditLog'> | Date | string;
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null;
  };

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    action?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrderInput | SortOrder;
    oldValues?: SortOrderInput | SortOrder;
    newValues?: SortOrderInput | SortOrder;
    ipAddress?: SortOrderInput | SortOrder;
    userAgent?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: AuditLogWhereInput | AuditLogWhereInput[];
      OR?: AuditLogWhereInput[];
      NOT?: AuditLogWhereInput | AuditLogWhereInput[];
      userId?: StringNullableFilter<'AuditLog'> | string | null;
      action?: StringFilter<'AuditLog'> | string;
      entityType?: StringFilter<'AuditLog'> | string;
      entityId?: StringNullableFilter<'AuditLog'> | string | null;
      oldValues?: StringNullableFilter<'AuditLog'> | string | null;
      newValues?: StringNullableFilter<'AuditLog'> | string | null;
      ipAddress?: StringNullableFilter<'AuditLog'> | string | null;
      userAgent?: StringNullableFilter<'AuditLog'> | string | null;
      createdAt?: DateTimeFilter<'AuditLog'> | Date | string;
      user?: XOR<UserNullableRelationFilter, UserWhereInput> | null;
    },
    'id'
  >;

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    action?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrderInput | SortOrder;
    oldValues?: SortOrderInput | SortOrder;
    newValues?: SortOrderInput | SortOrder;
    ipAddress?: SortOrderInput | SortOrder;
    userAgent?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    _count?: AuditLogCountOrderByAggregateInput;
    _max?: AuditLogMaxOrderByAggregateInput;
    _min?: AuditLogMinOrderByAggregateInput;
  };

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[];
    OR?: AuditLogScalarWhereWithAggregatesInput[];
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'AuditLog'> | string;
    userId?: StringNullableWithAggregatesFilter<'AuditLog'> | string | null;
    action?: StringWithAggregatesFilter<'AuditLog'> | string;
    entityType?: StringWithAggregatesFilter<'AuditLog'> | string;
    entityId?: StringNullableWithAggregatesFilter<'AuditLog'> | string | null;
    oldValues?: StringNullableWithAggregatesFilter<'AuditLog'> | string | null;
    newValues?: StringNullableWithAggregatesFilter<'AuditLog'> | string | null;
    ipAddress?: StringNullableWithAggregatesFilter<'AuditLog'> | string | null;
    userAgent?: StringNullableWithAggregatesFilter<'AuditLog'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'AuditLog'> | Date | string;
  };

  export type FAQWhereInput = {
    AND?: FAQWhereInput | FAQWhereInput[];
    OR?: FAQWhereInput[];
    NOT?: FAQWhereInput | FAQWhereInput[];
    id?: StringFilter<'FAQ'> | string;
    question?: StringFilter<'FAQ'> | string;
    answer?: StringFilter<'FAQ'> | string;
    orderIndex?: IntFilter<'FAQ'> | number;
    active?: BoolFilter<'FAQ'> | boolean;
    createdAt?: DateTimeFilter<'FAQ'> | Date | string;
    updatedAt?: DateTimeFilter<'FAQ'> | Date | string;
  };

  export type FAQOrderByWithRelationInput = {
    id?: SortOrder;
    question?: SortOrder;
    answer?: SortOrder;
    orderIndex?: SortOrder;
    active?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type FAQWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      question?: string;
      AND?: FAQWhereInput | FAQWhereInput[];
      OR?: FAQWhereInput[];
      NOT?: FAQWhereInput | FAQWhereInput[];
      answer?: StringFilter<'FAQ'> | string;
      orderIndex?: IntFilter<'FAQ'> | number;
      active?: BoolFilter<'FAQ'> | boolean;
      createdAt?: DateTimeFilter<'FAQ'> | Date | string;
      updatedAt?: DateTimeFilter<'FAQ'> | Date | string;
    },
    'id' | 'question'
  >;

  export type FAQOrderByWithAggregationInput = {
    id?: SortOrder;
    question?: SortOrder;
    answer?: SortOrder;
    orderIndex?: SortOrder;
    active?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: FAQCountOrderByAggregateInput;
    _avg?: FAQAvgOrderByAggregateInput;
    _max?: FAQMaxOrderByAggregateInput;
    _min?: FAQMinOrderByAggregateInput;
    _sum?: FAQSumOrderByAggregateInput;
  };

  export type FAQScalarWhereWithAggregatesInput = {
    AND?: FAQScalarWhereWithAggregatesInput | FAQScalarWhereWithAggregatesInput[];
    OR?: FAQScalarWhereWithAggregatesInput[];
    NOT?: FAQScalarWhereWithAggregatesInput | FAQScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'FAQ'> | string;
    question?: StringWithAggregatesFilter<'FAQ'> | string;
    answer?: StringWithAggregatesFilter<'FAQ'> | string;
    orderIndex?: IntWithAggregatesFilter<'FAQ'> | number;
    active?: BoolWithAggregatesFilter<'FAQ'> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<'FAQ'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'FAQ'> | Date | string;
  };

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[];
    OR?: DocumentWhereInput[];
    NOT?: DocumentWhereInput | DocumentWhereInput[];
    id?: StringFilter<'Document'> | string;
    orderId?: StringFilter<'Document'> | string;
    fileName?: StringFilter<'Document'> | string;
    filePath?: StringFilter<'Document'> | string;
    fileType?: StringFilter<'Document'> | string;
    fileSize?: IntFilter<'Document'> | number;
    uploadedAt?: DateTimeFilter<'Document'> | Date | string;
    order?: XOR<OrderRelationFilter, OrderWhereInput>;
  };

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    fileName?: SortOrder;
    filePath?: SortOrder;
    fileType?: SortOrder;
    fileSize?: SortOrder;
    uploadedAt?: SortOrder;
    order?: OrderOrderByWithRelationInput;
  };

  export type DocumentWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: DocumentWhereInput | DocumentWhereInput[];
      OR?: DocumentWhereInput[];
      NOT?: DocumentWhereInput | DocumentWhereInput[];
      orderId?: StringFilter<'Document'> | string;
      fileName?: StringFilter<'Document'> | string;
      filePath?: StringFilter<'Document'> | string;
      fileType?: StringFilter<'Document'> | string;
      fileSize?: IntFilter<'Document'> | number;
      uploadedAt?: DateTimeFilter<'Document'> | Date | string;
      order?: XOR<OrderRelationFilter, OrderWhereInput>;
    },
    'id'
  >;

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    fileName?: SortOrder;
    filePath?: SortOrder;
    fileType?: SortOrder;
    fileSize?: SortOrder;
    uploadedAt?: SortOrder;
    _count?: DocumentCountOrderByAggregateInput;
    _avg?: DocumentAvgOrderByAggregateInput;
    _max?: DocumentMaxOrderByAggregateInput;
    _min?: DocumentMinOrderByAggregateInput;
    _sum?: DocumentSumOrderByAggregateInput;
  };

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[];
    OR?: DocumentScalarWhereWithAggregatesInput[];
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Document'> | string;
    orderId?: StringWithAggregatesFilter<'Document'> | string;
    fileName?: StringWithAggregatesFilter<'Document'> | string;
    filePath?: StringWithAggregatesFilter<'Document'> | string;
    fileType?: StringWithAggregatesFilter<'Document'> | string;
    fileSize?: IntWithAggregatesFilter<'Document'> | number;
    uploadedAt?: DateTimeWithAggregatesFilter<'Document'> | Date | string;
  };

  export type OrderDocumentWhereInput = {
    AND?: OrderDocumentWhereInput | OrderDocumentWhereInput[];
    OR?: OrderDocumentWhereInput[];
    NOT?: OrderDocumentWhereInput | OrderDocumentWhereInput[];
    id?: StringFilter<'OrderDocument'> | string;
    orderId?: StringFilter<'OrderDocument'> | string;
    fileName?: StringFilter<'OrderDocument'> | string;
    filePath?: StringFilter<'OrderDocument'> | string;
    fileSize?: IntFilter<'OrderDocument'> | number;
    fileType?: StringFilter<'OrderDocument'> | string;
    documentType?: StringFilter<'OrderDocument'> | string;
    uploadedAt?: DateTimeFilter<'OrderDocument'> | Date | string;
    order?: XOR<OrderRelationFilter, OrderWhereInput>;
  };

  export type OrderDocumentOrderByWithRelationInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    fileName?: SortOrder;
    filePath?: SortOrder;
    fileSize?: SortOrder;
    fileType?: SortOrder;
    documentType?: SortOrder;
    uploadedAt?: SortOrder;
    order?: OrderOrderByWithRelationInput;
  };

  export type OrderDocumentWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: OrderDocumentWhereInput | OrderDocumentWhereInput[];
      OR?: OrderDocumentWhereInput[];
      NOT?: OrderDocumentWhereInput | OrderDocumentWhereInput[];
      orderId?: StringFilter<'OrderDocument'> | string;
      fileName?: StringFilter<'OrderDocument'> | string;
      filePath?: StringFilter<'OrderDocument'> | string;
      fileSize?: IntFilter<'OrderDocument'> | number;
      fileType?: StringFilter<'OrderDocument'> | string;
      documentType?: StringFilter<'OrderDocument'> | string;
      uploadedAt?: DateTimeFilter<'OrderDocument'> | Date | string;
      order?: XOR<OrderRelationFilter, OrderWhereInput>;
    },
    'id'
  >;

  export type OrderDocumentOrderByWithAggregationInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    fileName?: SortOrder;
    filePath?: SortOrder;
    fileSize?: SortOrder;
    fileType?: SortOrder;
    documentType?: SortOrder;
    uploadedAt?: SortOrder;
    _count?: OrderDocumentCountOrderByAggregateInput;
    _avg?: OrderDocumentAvgOrderByAggregateInput;
    _max?: OrderDocumentMaxOrderByAggregateInput;
    _min?: OrderDocumentMinOrderByAggregateInput;
    _sum?: OrderDocumentSumOrderByAggregateInput;
  };

  export type OrderDocumentScalarWhereWithAggregatesInput = {
    AND?:
      | OrderDocumentScalarWhereWithAggregatesInput
      | OrderDocumentScalarWhereWithAggregatesInput[];
    OR?: OrderDocumentScalarWhereWithAggregatesInput[];
    NOT?:
      | OrderDocumentScalarWhereWithAggregatesInput
      | OrderDocumentScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'OrderDocument'> | string;
    orderId?: StringWithAggregatesFilter<'OrderDocument'> | string;
    fileName?: StringWithAggregatesFilter<'OrderDocument'> | string;
    filePath?: StringWithAggregatesFilter<'OrderDocument'> | string;
    fileSize?: IntWithAggregatesFilter<'OrderDocument'> | number;
    fileType?: StringWithAggregatesFilter<'OrderDocument'> | string;
    documentType?: StringWithAggregatesFilter<'OrderDocument'> | string;
    uploadedAt?: DateTimeWithAggregatesFilter<'OrderDocument'> | Date | string;
  };

  export type ServiceDocumentWhereInput = {
    AND?: ServiceDocumentWhereInput | ServiceDocumentWhereInput[];
    OR?: ServiceDocumentWhereInput[];
    NOT?: ServiceDocumentWhereInput | ServiceDocumentWhereInput[];
    id?: StringFilter<'ServiceDocument'> | string;
    serviceId?: StringFilter<'ServiceDocument'> | string;
    title?: StringFilter<'ServiceDocument'> | string;
    description?: StringNullableFilter<'ServiceDocument'> | string | null;
    required?: BoolFilter<'ServiceDocument'> | boolean;
    showIf?: StringNullableFilter<'ServiceDocument'> | string | null;
    orderIndex?: IntFilter<'ServiceDocument'> | number;
    active?: BoolFilter<'ServiceDocument'> | boolean;
    createdAt?: DateTimeFilter<'ServiceDocument'> | Date | string;
    updatedAt?: DateTimeFilter<'ServiceDocument'> | Date | string;
    service?: XOR<ServiceRelationFilter, ServiceWhereInput>;
  };

  export type ServiceDocumentOrderByWithRelationInput = {
    id?: SortOrder;
    serviceId?: SortOrder;
    title?: SortOrder;
    description?: SortOrderInput | SortOrder;
    required?: SortOrder;
    showIf?: SortOrderInput | SortOrder;
    orderIndex?: SortOrder;
    active?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    service?: ServiceOrderByWithRelationInput;
  };

  export type ServiceDocumentWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ServiceDocumentWhereInput | ServiceDocumentWhereInput[];
      OR?: ServiceDocumentWhereInput[];
      NOT?: ServiceDocumentWhereInput | ServiceDocumentWhereInput[];
      serviceId?: StringFilter<'ServiceDocument'> | string;
      title?: StringFilter<'ServiceDocument'> | string;
      description?: StringNullableFilter<'ServiceDocument'> | string | null;
      required?: BoolFilter<'ServiceDocument'> | boolean;
      showIf?: StringNullableFilter<'ServiceDocument'> | string | null;
      orderIndex?: IntFilter<'ServiceDocument'> | number;
      active?: BoolFilter<'ServiceDocument'> | boolean;
      createdAt?: DateTimeFilter<'ServiceDocument'> | Date | string;
      updatedAt?: DateTimeFilter<'ServiceDocument'> | Date | string;
      service?: XOR<ServiceRelationFilter, ServiceWhereInput>;
    },
    'id'
  >;

  export type ServiceDocumentOrderByWithAggregationInput = {
    id?: SortOrder;
    serviceId?: SortOrder;
    title?: SortOrder;
    description?: SortOrderInput | SortOrder;
    required?: SortOrder;
    showIf?: SortOrderInput | SortOrder;
    orderIndex?: SortOrder;
    active?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: ServiceDocumentCountOrderByAggregateInput;
    _avg?: ServiceDocumentAvgOrderByAggregateInput;
    _max?: ServiceDocumentMaxOrderByAggregateInput;
    _min?: ServiceDocumentMinOrderByAggregateInput;
    _sum?: ServiceDocumentSumOrderByAggregateInput;
  };

  export type ServiceDocumentScalarWhereWithAggregatesInput = {
    AND?:
      | ServiceDocumentScalarWhereWithAggregatesInput
      | ServiceDocumentScalarWhereWithAggregatesInput[];
    OR?: ServiceDocumentScalarWhereWithAggregatesInput[];
    NOT?:
      | ServiceDocumentScalarWhereWithAggregatesInput
      | ServiceDocumentScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'ServiceDocument'> | string;
    serviceId?: StringWithAggregatesFilter<'ServiceDocument'> | string;
    title?: StringWithAggregatesFilter<'ServiceDocument'> | string;
    description?: StringNullableWithAggregatesFilter<'ServiceDocument'> | string | null;
    required?: BoolWithAggregatesFilter<'ServiceDocument'> | boolean;
    showIf?: StringNullableWithAggregatesFilter<'ServiceDocument'> | string | null;
    orderIndex?: IntWithAggregatesFilter<'ServiceDocument'> | number;
    active?: BoolWithAggregatesFilter<'ServiceDocument'> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<'ServiceDocument'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'ServiceDocument'> | Date | string;
  };

  export type SystemSettingsWhereInput = {
    AND?: SystemSettingsWhereInput | SystemSettingsWhereInput[];
    OR?: SystemSettingsWhereInput[];
    NOT?: SystemSettingsWhereInput | SystemSettingsWhereInput[];
    id?: StringFilter<'SystemSettings'> | string;
    siteName?: StringFilter<'SystemSettings'> | string;
    siteDescription?: StringNullableFilter<'SystemSettings'> | string | null;
    contactEmail?: StringNullableFilter<'SystemSettings'> | string | null;
    contactPhone?: StringNullableFilter<'SystemSettings'> | string | null;
    address?: StringNullableFilter<'SystemSettings'> | string | null;
    workingHours?: StringNullableFilter<'SystemSettings'> | string | null;
    socialLinks?: StringNullableFilter<'SystemSettings'> | string | null;
    seoSettings?: StringNullableFilter<'SystemSettings'> | string | null;
    updatedAt?: DateTimeFilter<'SystemSettings'> | Date | string;
  };

  export type SystemSettingsOrderByWithRelationInput = {
    id?: SortOrder;
    siteName?: SortOrder;
    siteDescription?: SortOrderInput | SortOrder;
    contactEmail?: SortOrderInput | SortOrder;
    contactPhone?: SortOrderInput | SortOrder;
    address?: SortOrderInput | SortOrder;
    workingHours?: SortOrderInput | SortOrder;
    socialLinks?: SortOrderInput | SortOrder;
    seoSettings?: SortOrderInput | SortOrder;
    updatedAt?: SortOrder;
  };

  export type SystemSettingsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: SystemSettingsWhereInput | SystemSettingsWhereInput[];
      OR?: SystemSettingsWhereInput[];
      NOT?: SystemSettingsWhereInput | SystemSettingsWhereInput[];
      siteName?: StringFilter<'SystemSettings'> | string;
      siteDescription?: StringNullableFilter<'SystemSettings'> | string | null;
      contactEmail?: StringNullableFilter<'SystemSettings'> | string | null;
      contactPhone?: StringNullableFilter<'SystemSettings'> | string | null;
      address?: StringNullableFilter<'SystemSettings'> | string | null;
      workingHours?: StringNullableFilter<'SystemSettings'> | string | null;
      socialLinks?: StringNullableFilter<'SystemSettings'> | string | null;
      seoSettings?: StringNullableFilter<'SystemSettings'> | string | null;
      updatedAt?: DateTimeFilter<'SystemSettings'> | Date | string;
    },
    'id'
  >;

  export type SystemSettingsOrderByWithAggregationInput = {
    id?: SortOrder;
    siteName?: SortOrder;
    siteDescription?: SortOrderInput | SortOrder;
    contactEmail?: SortOrderInput | SortOrder;
    contactPhone?: SortOrderInput | SortOrder;
    address?: SortOrderInput | SortOrder;
    workingHours?: SortOrderInput | SortOrder;
    socialLinks?: SortOrderInput | SortOrder;
    seoSettings?: SortOrderInput | SortOrder;
    updatedAt?: SortOrder;
    _count?: SystemSettingsCountOrderByAggregateInput;
    _max?: SystemSettingsMaxOrderByAggregateInput;
    _min?: SystemSettingsMinOrderByAggregateInput;
  };

  export type SystemSettingsScalarWhereWithAggregatesInput = {
    AND?:
      | SystemSettingsScalarWhereWithAggregatesInput
      | SystemSettingsScalarWhereWithAggregatesInput[];
    OR?: SystemSettingsScalarWhereWithAggregatesInput[];
    NOT?:
      | SystemSettingsScalarWhereWithAggregatesInput
      | SystemSettingsScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'SystemSettings'> | string;
    siteName?: StringWithAggregatesFilter<'SystemSettings'> | string;
    siteDescription?: StringNullableWithAggregatesFilter<'SystemSettings'> | string | null;
    contactEmail?: StringNullableWithAggregatesFilter<'SystemSettings'> | string | null;
    contactPhone?: StringNullableWithAggregatesFilter<'SystemSettings'> | string | null;
    address?: StringNullableWithAggregatesFilter<'SystemSettings'> | string | null;
    workingHours?: StringNullableWithAggregatesFilter<'SystemSettings'> | string | null;
    socialLinks?: StringNullableWithAggregatesFilter<'SystemSettings'> | string | null;
    seoSettings?: StringNullableWithAggregatesFilter<'SystemSettings'> | string | null;
    updatedAt?: DateTimeWithAggregatesFilter<'SystemSettings'> | Date | string;
  };

  export type FormTypeWhereInput = {
    AND?: FormTypeWhereInput | FormTypeWhereInput[];
    OR?: FormTypeWhereInput[];
    NOT?: FormTypeWhereInput | FormTypeWhereInput[];
    id?: StringFilter<'FormType'> | string;
    name?: StringFilter<'FormType'> | string;
    description?: StringNullableFilter<'FormType'> | string | null;
    active?: BoolFilter<'FormType'> | boolean;
    createdAt?: DateTimeFilter<'FormType'> | Date | string;
    updatedAt?: DateTimeFilter<'FormType'> | Date | string;
    variantLinks?: FormTypeVariantListRelationFilter;
    serials?: FormSerialListRelationFilter;
  };

  export type FormTypeOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    active?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    variantLinks?: FormTypeVariantOrderByRelationAggregateInput;
    serials?: FormSerialOrderByRelationAggregateInput;
  };

  export type FormTypeWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      name?: string;
      AND?: FormTypeWhereInput | FormTypeWhereInput[];
      OR?: FormTypeWhereInput[];
      NOT?: FormTypeWhereInput | FormTypeWhereInput[];
      description?: StringNullableFilter<'FormType'> | string | null;
      active?: BoolFilter<'FormType'> | boolean;
      createdAt?: DateTimeFilter<'FormType'> | Date | string;
      updatedAt?: DateTimeFilter<'FormType'> | Date | string;
      variantLinks?: FormTypeVariantListRelationFilter;
      serials?: FormSerialListRelationFilter;
    },
    'id' | 'name'
  >;

  export type FormTypeOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    active?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: FormTypeCountOrderByAggregateInput;
    _max?: FormTypeMaxOrderByAggregateInput;
    _min?: FormTypeMinOrderByAggregateInput;
  };

  export type FormTypeScalarWhereWithAggregatesInput = {
    AND?: FormTypeScalarWhereWithAggregatesInput | FormTypeScalarWhereWithAggregatesInput[];
    OR?: FormTypeScalarWhereWithAggregatesInput[];
    NOT?: FormTypeScalarWhereWithAggregatesInput | FormTypeScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'FormType'> | string;
    name?: StringWithAggregatesFilter<'FormType'> | string;
    description?: StringNullableWithAggregatesFilter<'FormType'> | string | null;
    active?: BoolWithAggregatesFilter<'FormType'> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<'FormType'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'FormType'> | Date | string;
  };

  export type FormTypeVariantWhereInput = {
    AND?: FormTypeVariantWhereInput | FormTypeVariantWhereInput[];
    OR?: FormTypeVariantWhereInput[];
    NOT?: FormTypeVariantWhereInput | FormTypeVariantWhereInput[];
    id?: StringFilter<'FormTypeVariant'> | string;
    formTypeId?: StringFilter<'FormTypeVariant'> | string;
    serviceVariantId?: StringFilter<'FormTypeVariant'> | string;
    createdAt?: DateTimeFilter<'FormTypeVariant'> | Date | string;
    formType?: XOR<FormTypeRelationFilter, FormTypeWhereInput>;
    serviceVariant?: XOR<ServiceVariantRelationFilter, ServiceVariantWhereInput>;
  };

  export type FormTypeVariantOrderByWithRelationInput = {
    id?: SortOrder;
    formTypeId?: SortOrder;
    serviceVariantId?: SortOrder;
    createdAt?: SortOrder;
    formType?: FormTypeOrderByWithRelationInput;
    serviceVariant?: ServiceVariantOrderByWithRelationInput;
  };

  export type FormTypeVariantWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      formTypeId_serviceVariantId?: FormTypeVariantFormTypeIdServiceVariantIdCompoundUniqueInput;
      AND?: FormTypeVariantWhereInput | FormTypeVariantWhereInput[];
      OR?: FormTypeVariantWhereInput[];
      NOT?: FormTypeVariantWhereInput | FormTypeVariantWhereInput[];
      formTypeId?: StringFilter<'FormTypeVariant'> | string;
      serviceVariantId?: StringFilter<'FormTypeVariant'> | string;
      createdAt?: DateTimeFilter<'FormTypeVariant'> | Date | string;
      formType?: XOR<FormTypeRelationFilter, FormTypeWhereInput>;
      serviceVariant?: XOR<ServiceVariantRelationFilter, ServiceVariantWhereInput>;
    },
    'id' | 'formTypeId_serviceVariantId'
  >;

  export type FormTypeVariantOrderByWithAggregationInput = {
    id?: SortOrder;
    formTypeId?: SortOrder;
    serviceVariantId?: SortOrder;
    createdAt?: SortOrder;
    _count?: FormTypeVariantCountOrderByAggregateInput;
    _max?: FormTypeVariantMaxOrderByAggregateInput;
    _min?: FormTypeVariantMinOrderByAggregateInput;
  };

  export type FormTypeVariantScalarWhereWithAggregatesInput = {
    AND?:
      | FormTypeVariantScalarWhereWithAggregatesInput
      | FormTypeVariantScalarWhereWithAggregatesInput[];
    OR?: FormTypeVariantScalarWhereWithAggregatesInput[];
    NOT?:
      | FormTypeVariantScalarWhereWithAggregatesInput
      | FormTypeVariantScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'FormTypeVariant'> | string;
    formTypeId?: StringWithAggregatesFilter<'FormTypeVariant'> | string;
    serviceVariantId?: StringWithAggregatesFilter<'FormTypeVariant'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'FormTypeVariant'> | Date | string;
  };

  export type FormSerialWhereInput = {
    AND?: FormSerialWhereInput | FormSerialWhereInput[];
    OR?: FormSerialWhereInput[];
    NOT?: FormSerialWhereInput | FormSerialWhereInput[];
    id?: StringFilter<'FormSerial'> | string;
    formTypeId?: StringFilter<'FormSerial'> | string;
    serialNumber?: StringFilter<'FormSerial'> | string;
    orderId?: StringNullableFilter<'FormSerial'> | string | null;
    consumed?: BoolFilter<'FormSerial'> | boolean;
    consumedAt?: DateTimeNullableFilter<'FormSerial'> | Date | string | null;
    addedByAdminId?: StringNullableFilter<'FormSerial'> | string | null;
    consumedByAdminId?: StringNullableFilter<'FormSerial'> | string | null;
    createdAt?: DateTimeFilter<'FormSerial'> | Date | string;
    updatedAt?: DateTimeFilter<'FormSerial'> | Date | string;
    formType?: XOR<FormTypeRelationFilter, FormTypeWhereInput>;
    order?: XOR<OrderNullableRelationFilter, OrderWhereInput> | null;
    addedByAdmin?: XOR<UserNullableRelationFilter, UserWhereInput> | null;
    consumedByAdmin?: XOR<UserNullableRelationFilter, UserWhereInput> | null;
  };

  export type FormSerialOrderByWithRelationInput = {
    id?: SortOrder;
    formTypeId?: SortOrder;
    serialNumber?: SortOrder;
    orderId?: SortOrderInput | SortOrder;
    consumed?: SortOrder;
    consumedAt?: SortOrderInput | SortOrder;
    addedByAdminId?: SortOrderInput | SortOrder;
    consumedByAdminId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    formType?: FormTypeOrderByWithRelationInput;
    order?: OrderOrderByWithRelationInput;
    addedByAdmin?: UserOrderByWithRelationInput;
    consumedByAdmin?: UserOrderByWithRelationInput;
  };

  export type FormSerialWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      formTypeId_serialNumber?: FormSerialFormTypeIdSerialNumberCompoundUniqueInput;
      AND?: FormSerialWhereInput | FormSerialWhereInput[];
      OR?: FormSerialWhereInput[];
      NOT?: FormSerialWhereInput | FormSerialWhereInput[];
      formTypeId?: StringFilter<'FormSerial'> | string;
      serialNumber?: StringFilter<'FormSerial'> | string;
      orderId?: StringNullableFilter<'FormSerial'> | string | null;
      consumed?: BoolFilter<'FormSerial'> | boolean;
      consumedAt?: DateTimeNullableFilter<'FormSerial'> | Date | string | null;
      addedByAdminId?: StringNullableFilter<'FormSerial'> | string | null;
      consumedByAdminId?: StringNullableFilter<'FormSerial'> | string | null;
      createdAt?: DateTimeFilter<'FormSerial'> | Date | string;
      updatedAt?: DateTimeFilter<'FormSerial'> | Date | string;
      formType?: XOR<FormTypeRelationFilter, FormTypeWhereInput>;
      order?: XOR<OrderNullableRelationFilter, OrderWhereInput> | null;
      addedByAdmin?: XOR<UserNullableRelationFilter, UserWhereInput> | null;
      consumedByAdmin?: XOR<UserNullableRelationFilter, UserWhereInput> | null;
    },
    'id' | 'formTypeId_serialNumber'
  >;

  export type FormSerialOrderByWithAggregationInput = {
    id?: SortOrder;
    formTypeId?: SortOrder;
    serialNumber?: SortOrder;
    orderId?: SortOrderInput | SortOrder;
    consumed?: SortOrder;
    consumedAt?: SortOrderInput | SortOrder;
    addedByAdminId?: SortOrderInput | SortOrder;
    consumedByAdminId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: FormSerialCountOrderByAggregateInput;
    _max?: FormSerialMaxOrderByAggregateInput;
    _min?: FormSerialMinOrderByAggregateInput;
  };

  export type FormSerialScalarWhereWithAggregatesInput = {
    AND?: FormSerialScalarWhereWithAggregatesInput | FormSerialScalarWhereWithAggregatesInput[];
    OR?: FormSerialScalarWhereWithAggregatesInput[];
    NOT?: FormSerialScalarWhereWithAggregatesInput | FormSerialScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'FormSerial'> | string;
    formTypeId?: StringWithAggregatesFilter<'FormSerial'> | string;
    serialNumber?: StringWithAggregatesFilter<'FormSerial'> | string;
    orderId?: StringNullableWithAggregatesFilter<'FormSerial'> | string | null;
    consumed?: BoolWithAggregatesFilter<'FormSerial'> | boolean;
    consumedAt?: DateTimeNullableWithAggregatesFilter<'FormSerial'> | Date | string | null;
    addedByAdminId?: StringNullableWithAggregatesFilter<'FormSerial'> | string | null;
    consumedByAdminId?: StringNullableWithAggregatesFilter<'FormSerial'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'FormSerial'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'FormSerial'> | Date | string;
  };

  export type DependentWhereInput = {
    AND?: DependentWhereInput | DependentWhereInput[];
    OR?: DependentWhereInput[];
    NOT?: DependentWhereInput | DependentWhereInput[];
    id?: StringFilter<'Dependent'> | string;
    name?: StringFilter<'Dependent'> | string;
    createdAt?: DateTimeFilter<'Dependent'> | Date | string;
    updatedAt?: DateTimeFilter<'Dependent'> | Date | string;
    createdByAdminId?: StringNullableFilter<'Dependent'> | string | null;
    createdByAdmin?: XOR<UserNullableRelationFilter, UserWhereInput> | null;
  };

  export type DependentOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdByAdminId?: SortOrderInput | SortOrder;
    createdByAdmin?: UserOrderByWithRelationInput;
  };

  export type DependentWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: DependentWhereInput | DependentWhereInput[];
      OR?: DependentWhereInput[];
      NOT?: DependentWhereInput | DependentWhereInput[];
      name?: StringFilter<'Dependent'> | string;
      createdAt?: DateTimeFilter<'Dependent'> | Date | string;
      updatedAt?: DateTimeFilter<'Dependent'> | Date | string;
      createdByAdminId?: StringNullableFilter<'Dependent'> | string | null;
      createdByAdmin?: XOR<UserNullableRelationFilter, UserWhereInput> | null;
    },
    'id'
  >;

  export type DependentOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdByAdminId?: SortOrderInput | SortOrder;
    _count?: DependentCountOrderByAggregateInput;
    _max?: DependentMaxOrderByAggregateInput;
    _min?: DependentMinOrderByAggregateInput;
  };

  export type DependentScalarWhereWithAggregatesInput = {
    AND?: DependentScalarWhereWithAggregatesInput | DependentScalarWhereWithAggregatesInput[];
    OR?: DependentScalarWhereWithAggregatesInput[];
    NOT?: DependentScalarWhereWithAggregatesInput | DependentScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Dependent'> | string;
    name?: StringWithAggregatesFilter<'Dependent'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'Dependent'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Dependent'> | Date | string;
    createdByAdminId?: StringNullableWithAggregatesFilter<'Dependent'> | string | null;
  };

  export type PromoCodeWhereInput = {
    AND?: PromoCodeWhereInput | PromoCodeWhereInput[];
    OR?: PromoCodeWhereInput[];
    NOT?: PromoCodeWhereInput | PromoCodeWhereInput[];
    id?: StringFilter<'PromoCode'> | string;
    code?: StringFilter<'PromoCode'> | string;
    type?: StringFilter<'PromoCode'> | string;
    value?: IntFilter<'PromoCode'> | number;
    minOrderAmount?: IntNullableFilter<'PromoCode'> | number | null;
    maxDiscount?: IntNullableFilter<'PromoCode'> | number | null;
    startDate?: DateTimeNullableFilter<'PromoCode'> | Date | string | null;
    endDate?: DateTimeNullableFilter<'PromoCode'> | Date | string | null;
    usageLimit?: IntNullableFilter<'PromoCode'> | number | null;
    currentUsage?: IntFilter<'PromoCode'> | number;
    isActive?: BoolFilter<'PromoCode'> | boolean;
    createdAt?: DateTimeFilter<'PromoCode'> | Date | string;
    updatedAt?: DateTimeFilter<'PromoCode'> | Date | string;
    orders?: OrderListRelationFilter;
  };

  export type PromoCodeOrderByWithRelationInput = {
    id?: SortOrder;
    code?: SortOrder;
    type?: SortOrder;
    value?: SortOrder;
    minOrderAmount?: SortOrderInput | SortOrder;
    maxDiscount?: SortOrderInput | SortOrder;
    startDate?: SortOrderInput | SortOrder;
    endDate?: SortOrderInput | SortOrder;
    usageLimit?: SortOrderInput | SortOrder;
    currentUsage?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    orders?: OrderOrderByRelationAggregateInput;
  };

  export type PromoCodeWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      code?: string;
      AND?: PromoCodeWhereInput | PromoCodeWhereInput[];
      OR?: PromoCodeWhereInput[];
      NOT?: PromoCodeWhereInput | PromoCodeWhereInput[];
      type?: StringFilter<'PromoCode'> | string;
      value?: IntFilter<'PromoCode'> | number;
      minOrderAmount?: IntNullableFilter<'PromoCode'> | number | null;
      maxDiscount?: IntNullableFilter<'PromoCode'> | number | null;
      startDate?: DateTimeNullableFilter<'PromoCode'> | Date | string | null;
      endDate?: DateTimeNullableFilter<'PromoCode'> | Date | string | null;
      usageLimit?: IntNullableFilter<'PromoCode'> | number | null;
      currentUsage?: IntFilter<'PromoCode'> | number;
      isActive?: BoolFilter<'PromoCode'> | boolean;
      createdAt?: DateTimeFilter<'PromoCode'> | Date | string;
      updatedAt?: DateTimeFilter<'PromoCode'> | Date | string;
      orders?: OrderListRelationFilter;
    },
    'id' | 'code'
  >;

  export type PromoCodeOrderByWithAggregationInput = {
    id?: SortOrder;
    code?: SortOrder;
    type?: SortOrder;
    value?: SortOrder;
    minOrderAmount?: SortOrderInput | SortOrder;
    maxDiscount?: SortOrderInput | SortOrder;
    startDate?: SortOrderInput | SortOrder;
    endDate?: SortOrderInput | SortOrder;
    usageLimit?: SortOrderInput | SortOrder;
    currentUsage?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: PromoCodeCountOrderByAggregateInput;
    _avg?: PromoCodeAvgOrderByAggregateInput;
    _max?: PromoCodeMaxOrderByAggregateInput;
    _min?: PromoCodeMinOrderByAggregateInput;
    _sum?: PromoCodeSumOrderByAggregateInput;
  };

  export type PromoCodeScalarWhereWithAggregatesInput = {
    AND?: PromoCodeScalarWhereWithAggregatesInput | PromoCodeScalarWhereWithAggregatesInput[];
    OR?: PromoCodeScalarWhereWithAggregatesInput[];
    NOT?: PromoCodeScalarWhereWithAggregatesInput | PromoCodeScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'PromoCode'> | string;
    code?: StringWithAggregatesFilter<'PromoCode'> | string;
    type?: StringWithAggregatesFilter<'PromoCode'> | string;
    value?: IntWithAggregatesFilter<'PromoCode'> | number;
    minOrderAmount?: IntNullableWithAggregatesFilter<'PromoCode'> | number | null;
    maxDiscount?: IntNullableWithAggregatesFilter<'PromoCode'> | number | null;
    startDate?: DateTimeNullableWithAggregatesFilter<'PromoCode'> | Date | string | null;
    endDate?: DateTimeNullableWithAggregatesFilter<'PromoCode'> | Date | string | null;
    usageLimit?: IntNullableWithAggregatesFilter<'PromoCode'> | number | null;
    currentUsage?: IntWithAggregatesFilter<'PromoCode'> | number;
    isActive?: BoolWithAggregatesFilter<'PromoCode'> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<'PromoCode'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'PromoCode'> | Date | string;
  };

  export type AccountCreateInput = {
    id?: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
    user: UserCreateNestedOneWithoutAccountsInput;
  };

  export type AccountUncheckedCreateInput = {
    id?: string;
    userId: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
  };

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput;
  };

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AccountCreateManyInput = {
    id?: string;
    userId: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
  };

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SessionCreateInput = {
    id?: string;
    sessionToken: string;
    expires: Date | string;
    user: UserCreateNestedOneWithoutSessionsInput;
  };

  export type SessionUncheckedCreateInput = {
    id?: string;
    sessionToken: string;
    userId: string;
    expires: Date | string;
  };

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput;
  };

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SessionCreateManyInput = {
    id?: string;
    sessionToken: string;
    userId: string;
    expires: Date | string;
  };

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VerificationTokenCreateInput = {
    identifier: string;
    token: string;
    expires: Date | string;
  };

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string;
    token: string;
    expires: Date | string;
  };

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VerificationTokenCreateManyInput = {
    identifier: string;
    token: string;
    expires: Date | string;
  };

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserCreateInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    passwordHash?: string | null;
    phone?: string | null;
    additionalPhone?: string | null;
    role?: string;
    resetToken?: string | null;
    resetTokenExpiry?: Date | string | null;
    verificationToken?: string | null;
    verificationTokenExpiry?: Date | string | null;
    verificationCode?: string | null;
    verificationCodeExpiry?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    wifeMotherName?: string | null;
    createdByAdmin?: UserCreateNestedOneWithoutCreatedUsersInput;
    createdUsers?: UserCreateNestedManyWithoutCreatedByAdminInput;
    createdOrders?: OrderCreateNestedManyWithoutCreatedByAdminInput;
    orders?: OrderCreateNestedManyWithoutUserInput;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    addedFormSerials?: FormSerialCreateNestedManyWithoutAddedByAdminInput;
    consumedFormSerials?: FormSerialCreateNestedManyWithoutConsumedByAdminInput;
    createdDependents?: DependentCreateNestedManyWithoutCreatedByAdminInput;
  };

  export type UserUncheckedCreateInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    passwordHash?: string | null;
    phone?: string | null;
    additionalPhone?: string | null;
    role?: string;
    createdByAdminId?: string | null;
    resetToken?: string | null;
    resetTokenExpiry?: Date | string | null;
    verificationToken?: string | null;
    verificationTokenExpiry?: Date | string | null;
    verificationCode?: string | null;
    verificationCodeExpiry?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    wifeMotherName?: string | null;
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByAdminInput;
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByAdminInput;
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    addedFormSerials?: FormSerialUncheckedCreateNestedManyWithoutAddedByAdminInput;
    consumedFormSerials?: FormSerialUncheckedCreateNestedManyWithoutConsumedByAdminInput;
    createdDependents?: DependentUncheckedCreateNestedManyWithoutCreatedByAdminInput;
  };

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationCodeExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdByAdmin?: UserUpdateOneWithoutCreatedUsersNestedInput;
    createdUsers?: UserUpdateManyWithoutCreatedByAdminNestedInput;
    createdOrders?: OrderUpdateManyWithoutCreatedByAdminNestedInput;
    orders?: OrderUpdateManyWithoutUserNestedInput;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    addedFormSerials?: FormSerialUpdateManyWithoutAddedByAdminNestedInput;
    consumedFormSerials?: FormSerialUpdateManyWithoutConsumedByAdminNestedInput;
    createdDependents?: DependentUpdateManyWithoutCreatedByAdminNestedInput;
  };

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationCodeExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByAdminNestedInput;
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByAdminNestedInput;
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    addedFormSerials?: FormSerialUncheckedUpdateManyWithoutAddedByAdminNestedInput;
    consumedFormSerials?: FormSerialUncheckedUpdateManyWithoutConsumedByAdminNestedInput;
    createdDependents?: DependentUncheckedUpdateManyWithoutCreatedByAdminNestedInput;
  };

  export type UserCreateManyInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    passwordHash?: string | null;
    phone?: string | null;
    additionalPhone?: string | null;
    role?: string;
    createdByAdminId?: string | null;
    resetToken?: string | null;
    resetTokenExpiry?: Date | string | null;
    verificationToken?: string | null;
    verificationTokenExpiry?: Date | string | null;
    verificationCode?: string | null;
    verificationCodeExpiry?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    wifeMotherName?: string | null;
  };

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationCodeExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationCodeExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type CategoryCreateInput = {
    id?: string;
    name: string;
    slug: string;
    orderIndex?: number;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    icon?: string | null;
    services?: ServiceCreateNestedManyWithoutCategoryInput;
  };

  export type CategoryUncheckedCreateInput = {
    id?: string;
    name: string;
    slug: string;
    orderIndex?: number;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    icon?: string | null;
    services?: ServiceUncheckedCreateNestedManyWithoutCategoryInput;
  };

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    orderIndex?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    icon?: NullableStringFieldUpdateOperationsInput | string | null;
    services?: ServiceUpdateManyWithoutCategoryNestedInput;
  };

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    orderIndex?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    icon?: NullableStringFieldUpdateOperationsInput | string | null;
    services?: ServiceUncheckedUpdateManyWithoutCategoryNestedInput;
  };

  export type CategoryCreateManyInput = {
    id?: string;
    name: string;
    slug: string;
    orderIndex?: number;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    icon?: string | null;
  };

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    orderIndex?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    icon?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    orderIndex?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    icon?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ServiceCreateInput = {
    id?: string;
    name: string;
    slug: string;
    description?: string | null;
    icon?: string | null;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    orders?: OrderCreateNestedManyWithoutServiceInput;
    category: CategoryCreateNestedOneWithoutServicesInput;
    documents?: ServiceDocumentCreateNestedManyWithoutServiceInput;
    variants?: ServiceVariantCreateNestedManyWithoutServiceInput;
    fields?: ServiceFieldCreateNestedManyWithoutServiceInput;
  };

  export type ServiceUncheckedCreateInput = {
    id?: string;
    name: string;
    slug: string;
    description?: string | null;
    icon?: string | null;
    active?: boolean;
    categoryId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    orders?: OrderUncheckedCreateNestedManyWithoutServiceInput;
    documents?: ServiceDocumentUncheckedCreateNestedManyWithoutServiceInput;
    variants?: ServiceVariantUncheckedCreateNestedManyWithoutServiceInput;
    fields?: ServiceFieldUncheckedCreateNestedManyWithoutServiceInput;
  };

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    icon?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    orders?: OrderUpdateManyWithoutServiceNestedInput;
    category?: CategoryUpdateOneRequiredWithoutServicesNestedInput;
    documents?: ServiceDocumentUpdateManyWithoutServiceNestedInput;
    variants?: ServiceVariantUpdateManyWithoutServiceNestedInput;
    fields?: ServiceFieldUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    icon?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    categoryId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    orders?: OrderUncheckedUpdateManyWithoutServiceNestedInput;
    documents?: ServiceDocumentUncheckedUpdateManyWithoutServiceNestedInput;
    variants?: ServiceVariantUncheckedUpdateManyWithoutServiceNestedInput;
    fields?: ServiceFieldUncheckedUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceCreateManyInput = {
    id?: string;
    name: string;
    slug: string;
    description?: string | null;
    icon?: string | null;
    active?: boolean;
    categoryId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    icon?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    icon?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    categoryId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ServiceFieldCreateInput = {
    id?: string;
    name: string;
    label: string;
    type: string;
    placeholder?: string | null;
    required?: boolean;
    orderIndex?: number;
    active?: boolean;
    showIf?: string | null;
    validation?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    service: ServiceCreateNestedOneWithoutFieldsInput;
    options?: ServiceFieldOptionCreateNestedManyWithoutFieldInput;
  };

  export type ServiceFieldUncheckedCreateInput = {
    id?: string;
    serviceId: string;
    name: string;
    label: string;
    type: string;
    placeholder?: string | null;
    required?: boolean;
    orderIndex?: number;
    active?: boolean;
    showIf?: string | null;
    validation?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    options?: ServiceFieldOptionUncheckedCreateNestedManyWithoutFieldInput;
  };

  export type ServiceFieldUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null;
    required?: BoolFieldUpdateOperationsInput | boolean;
    orderIndex?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    showIf?: NullableStringFieldUpdateOperationsInput | string | null;
    validation?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    service?: ServiceUpdateOneRequiredWithoutFieldsNestedInput;
    options?: ServiceFieldOptionUpdateManyWithoutFieldNestedInput;
  };

  export type ServiceFieldUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null;
    required?: BoolFieldUpdateOperationsInput | boolean;
    orderIndex?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    showIf?: NullableStringFieldUpdateOperationsInput | string | null;
    validation?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    options?: ServiceFieldOptionUncheckedUpdateManyWithoutFieldNestedInput;
  };

  export type ServiceFieldCreateManyInput = {
    id?: string;
    serviceId: string;
    name: string;
    label: string;
    type: string;
    placeholder?: string | null;
    required?: boolean;
    orderIndex?: number;
    active?: boolean;
    showIf?: string | null;
    validation?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ServiceFieldUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null;
    required?: BoolFieldUpdateOperationsInput | boolean;
    orderIndex?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    showIf?: NullableStringFieldUpdateOperationsInput | string | null;
    validation?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ServiceFieldUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null;
    required?: BoolFieldUpdateOperationsInput | boolean;
    orderIndex?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    showIf?: NullableStringFieldUpdateOperationsInput | string | null;
    validation?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ServiceFieldOptionCreateInput = {
    id?: string;
    value: string;
    label: string;
    orderIndex?: number;
    requiredDocs?: string | null;
    showFields?: string | null;
    createdAt?: Date | string;
    field: ServiceFieldCreateNestedOneWithoutOptionsInput;
  };

  export type ServiceFieldOptionUncheckedCreateInput = {
    id?: string;
    fieldId: string;
    value: string;
    label: string;
    orderIndex?: number;
    requiredDocs?: string | null;
    showFields?: string | null;
    createdAt?: Date | string;
  };

  export type ServiceFieldOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    value?: StringFieldUpdateOperationsInput | string;
    label?: StringFieldUpdateOperationsInput | string;
    orderIndex?: IntFieldUpdateOperationsInput | number;
    requiredDocs?: NullableStringFieldUpdateOperationsInput | string | null;
    showFields?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    field?: ServiceFieldUpdateOneRequiredWithoutOptionsNestedInput;
  };

  export type ServiceFieldOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fieldId?: StringFieldUpdateOperationsInput | string;
    value?: StringFieldUpdateOperationsInput | string;
    label?: StringFieldUpdateOperationsInput | string;
    orderIndex?: IntFieldUpdateOperationsInput | number;
    requiredDocs?: NullableStringFieldUpdateOperationsInput | string | null;
    showFields?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ServiceFieldOptionCreateManyInput = {
    id?: string;
    fieldId: string;
    value: string;
    label: string;
    orderIndex?: number;
    requiredDocs?: string | null;
    showFields?: string | null;
    createdAt?: Date | string;
  };

  export type ServiceFieldOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    value?: StringFieldUpdateOperationsInput | string;
    label?: StringFieldUpdateOperationsInput | string;
    orderIndex?: IntFieldUpdateOperationsInput | number;
    requiredDocs?: NullableStringFieldUpdateOperationsInput | string | null;
    showFields?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ServiceFieldOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fieldId?: StringFieldUpdateOperationsInput | string;
    value?: StringFieldUpdateOperationsInput | string;
    label?: StringFieldUpdateOperationsInput | string;
    orderIndex?: IntFieldUpdateOperationsInput | number;
    requiredDocs?: NullableStringFieldUpdateOperationsInput | string | null;
    showFields?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ServiceVariantCreateInput = {
    id?: string;
    name: string;
    priceCents: number;
    etaDays: number;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    orders?: OrderCreateNestedManyWithoutVariantInput;
    service: ServiceCreateNestedOneWithoutVariantsInput;
    formTypeLinks?: FormTypeVariantCreateNestedManyWithoutServiceVariantInput;
  };

  export type ServiceVariantUncheckedCreateInput = {
    id?: string;
    name: string;
    priceCents: number;
    etaDays: number;
    serviceId: string;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    orders?: OrderUncheckedCreateNestedManyWithoutVariantInput;
    formTypeLinks?: FormTypeVariantUncheckedCreateNestedManyWithoutServiceVariantInput;
  };

  export type ServiceVariantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    priceCents?: IntFieldUpdateOperationsInput | number;
    etaDays?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    orders?: OrderUpdateManyWithoutVariantNestedInput;
    service?: ServiceUpdateOneRequiredWithoutVariantsNestedInput;
    formTypeLinks?: FormTypeVariantUpdateManyWithoutServiceVariantNestedInput;
  };

  export type ServiceVariantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    priceCents?: IntFieldUpdateOperationsInput | number;
    etaDays?: IntFieldUpdateOperationsInput | number;
    serviceId?: StringFieldUpdateOperationsInput | string;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    orders?: OrderUncheckedUpdateManyWithoutVariantNestedInput;
    formTypeLinks?: FormTypeVariantUncheckedUpdateManyWithoutServiceVariantNestedInput;
  };

  export type ServiceVariantCreateManyInput = {
    id?: string;
    name: string;
    priceCents: number;
    etaDays: number;
    serviceId: string;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ServiceVariantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    priceCents?: IntFieldUpdateOperationsInput | number;
    etaDays?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ServiceVariantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    priceCents?: IntFieldUpdateOperationsInput | number;
    etaDays?: IntFieldUpdateOperationsInput | number;
    serviceId?: StringFieldUpdateOperationsInput | string;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrderCreateInput = {
    id?: string;
    status?: string;
    totalPrice: number;
    totalCents: number;
    customerName: string;
    customerPhone: string;
    additionalPhone?: string | null;
    customerEmail: string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    notes?: string | null;
    adminNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    completedAt?: Date | string | null;
    estimatedCompletionDate?: Date | string | null;
    deliveryFee?: number;
    deliveryType?: string;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    photographyLocation?: string | null;
    photographyDate?: Date | string | null;
    marriageDate?: Date | string | null;
    divorceDate?: Date | string | null;
    wifeMotherName?: string | null;
    quantity?: number;
    serviceDetails?: string | null;
    otherFees?: number;
    discount?: number;
    gender?: string | null;
    policeStation?: string | null;
    pickupLocation?: string | null;
    originalDocuments?: string | null;
    attachedDocuments?: string | null;
    hasAttachments?: boolean;
    selectedFines?: string | null;
    finesDetails?: string | null;
    servicesDetails?: string | null;
    customerFollowUp?: string | null;
    discountAmount?: number;
    createdByAdmin?: UserCreateNestedOneWithoutCreatedOrdersInput;
    documents?: DocumentCreateNestedManyWithoutOrderInput;
    service: ServiceCreateNestedOneWithoutOrdersInput;
    user: UserCreateNestedOneWithoutOrdersInput;
    variant: ServiceVariantCreateNestedOneWithoutOrdersInput;
    orderDocuments?: OrderDocumentCreateNestedManyWithoutOrderInput;
    payment?: PaymentCreateNestedOneWithoutOrderInput;
    formSerials?: FormSerialCreateNestedManyWithoutOrderInput;
    promoCode?: PromoCodeCreateNestedOneWithoutOrdersInput;
  };

  export type OrderUncheckedCreateInput = {
    id?: string;
    userId: string;
    serviceId: string;
    variantId: string;
    status?: string;
    totalPrice: number;
    totalCents: number;
    customerName: string;
    customerPhone: string;
    additionalPhone?: string | null;
    customerEmail: string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    notes?: string | null;
    adminNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    completedAt?: Date | string | null;
    estimatedCompletionDate?: Date | string | null;
    deliveryFee?: number;
    deliveryType?: string;
    createdByAdminId?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    photographyLocation?: string | null;
    photographyDate?: Date | string | null;
    marriageDate?: Date | string | null;
    divorceDate?: Date | string | null;
    wifeMotherName?: string | null;
    quantity?: number;
    serviceDetails?: string | null;
    otherFees?: number;
    discount?: number;
    gender?: string | null;
    policeStation?: string | null;
    pickupLocation?: string | null;
    originalDocuments?: string | null;
    attachedDocuments?: string | null;
    hasAttachments?: boolean;
    selectedFines?: string | null;
    finesDetails?: string | null;
    servicesDetails?: string | null;
    customerFollowUp?: string | null;
    promoCodeId?: string | null;
    discountAmount?: number;
    documents?: DocumentUncheckedCreateNestedManyWithoutOrderInput;
    orderDocuments?: OrderDocumentUncheckedCreateNestedManyWithoutOrderInput;
    payment?: PaymentUncheckedCreateNestedOneWithoutOrderInput;
    formSerials?: FormSerialUncheckedCreateNestedManyWithoutOrderInput;
  };

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    totalPrice?: IntFieldUpdateOperationsInput | number;
    totalCents?: IntFieldUpdateOperationsInput | number;
    customerName?: StringFieldUpdateOperationsInput | string;
    customerPhone?: StringFieldUpdateOperationsInput | string;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    customerEmail?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveryFee?: IntFieldUpdateOperationsInput | number;
    deliveryType?: StringFieldUpdateOperationsInput | string;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    marriageDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    serviceDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    otherFees?: IntFieldUpdateOperationsInput | number;
    discount?: IntFieldUpdateOperationsInput | number;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    policeStation?: NullableStringFieldUpdateOperationsInput | string | null;
    pickupLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    attachedDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean;
    selectedFines?: NullableStringFieldUpdateOperationsInput | string | null;
    finesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    servicesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    customerFollowUp?: NullableStringFieldUpdateOperationsInput | string | null;
    discountAmount?: IntFieldUpdateOperationsInput | number;
    createdByAdmin?: UserUpdateOneWithoutCreatedOrdersNestedInput;
    documents?: DocumentUpdateManyWithoutOrderNestedInput;
    service?: ServiceUpdateOneRequiredWithoutOrdersNestedInput;
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput;
    variant?: ServiceVariantUpdateOneRequiredWithoutOrdersNestedInput;
    orderDocuments?: OrderDocumentUpdateManyWithoutOrderNestedInput;
    payment?: PaymentUpdateOneWithoutOrderNestedInput;
    formSerials?: FormSerialUpdateManyWithoutOrderNestedInput;
    promoCode?: PromoCodeUpdateOneWithoutOrdersNestedInput;
  };

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    variantId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    totalPrice?: IntFieldUpdateOperationsInput | number;
    totalCents?: IntFieldUpdateOperationsInput | number;
    customerName?: StringFieldUpdateOperationsInput | string;
    customerPhone?: StringFieldUpdateOperationsInput | string;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    customerEmail?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveryFee?: IntFieldUpdateOperationsInput | number;
    deliveryType?: StringFieldUpdateOperationsInput | string;
    createdByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    marriageDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    serviceDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    otherFees?: IntFieldUpdateOperationsInput | number;
    discount?: IntFieldUpdateOperationsInput | number;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    policeStation?: NullableStringFieldUpdateOperationsInput | string | null;
    pickupLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    attachedDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean;
    selectedFines?: NullableStringFieldUpdateOperationsInput | string | null;
    finesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    servicesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    customerFollowUp?: NullableStringFieldUpdateOperationsInput | string | null;
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null;
    discountAmount?: IntFieldUpdateOperationsInput | number;
    documents?: DocumentUncheckedUpdateManyWithoutOrderNestedInput;
    orderDocuments?: OrderDocumentUncheckedUpdateManyWithoutOrderNestedInput;
    payment?: PaymentUncheckedUpdateOneWithoutOrderNestedInput;
    formSerials?: FormSerialUncheckedUpdateManyWithoutOrderNestedInput;
  };

  export type OrderCreateManyInput = {
    id?: string;
    userId: string;
    serviceId: string;
    variantId: string;
    status?: string;
    totalPrice: number;
    totalCents: number;
    customerName: string;
    customerPhone: string;
    additionalPhone?: string | null;
    customerEmail: string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    notes?: string | null;
    adminNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    completedAt?: Date | string | null;
    estimatedCompletionDate?: Date | string | null;
    deliveryFee?: number;
    deliveryType?: string;
    createdByAdminId?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    photographyLocation?: string | null;
    photographyDate?: Date | string | null;
    marriageDate?: Date | string | null;
    divorceDate?: Date | string | null;
    wifeMotherName?: string | null;
    quantity?: number;
    serviceDetails?: string | null;
    otherFees?: number;
    discount?: number;
    gender?: string | null;
    policeStation?: string | null;
    pickupLocation?: string | null;
    originalDocuments?: string | null;
    attachedDocuments?: string | null;
    hasAttachments?: boolean;
    selectedFines?: string | null;
    finesDetails?: string | null;
    servicesDetails?: string | null;
    customerFollowUp?: string | null;
    promoCodeId?: string | null;
    discountAmount?: number;
  };

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    totalPrice?: IntFieldUpdateOperationsInput | number;
    totalCents?: IntFieldUpdateOperationsInput | number;
    customerName?: StringFieldUpdateOperationsInput | string;
    customerPhone?: StringFieldUpdateOperationsInput | string;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    customerEmail?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveryFee?: IntFieldUpdateOperationsInput | number;
    deliveryType?: StringFieldUpdateOperationsInput | string;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    marriageDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    serviceDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    otherFees?: IntFieldUpdateOperationsInput | number;
    discount?: IntFieldUpdateOperationsInput | number;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    policeStation?: NullableStringFieldUpdateOperationsInput | string | null;
    pickupLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    attachedDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean;
    selectedFines?: NullableStringFieldUpdateOperationsInput | string | null;
    finesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    servicesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    customerFollowUp?: NullableStringFieldUpdateOperationsInput | string | null;
    discountAmount?: IntFieldUpdateOperationsInput | number;
  };

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    variantId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    totalPrice?: IntFieldUpdateOperationsInput | number;
    totalCents?: IntFieldUpdateOperationsInput | number;
    customerName?: StringFieldUpdateOperationsInput | string;
    customerPhone?: StringFieldUpdateOperationsInput | string;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    customerEmail?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveryFee?: IntFieldUpdateOperationsInput | number;
    deliveryType?: StringFieldUpdateOperationsInput | string;
    createdByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    marriageDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    serviceDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    otherFees?: IntFieldUpdateOperationsInput | number;
    discount?: IntFieldUpdateOperationsInput | number;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    policeStation?: NullableStringFieldUpdateOperationsInput | string | null;
    pickupLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    attachedDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean;
    selectedFines?: NullableStringFieldUpdateOperationsInput | string | null;
    finesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    servicesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    customerFollowUp?: NullableStringFieldUpdateOperationsInput | string | null;
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null;
    discountAmount?: IntFieldUpdateOperationsInput | number;
  };

  export type PaymentCreateInput = {
    id?: string;
    amount: number;
    currency?: string;
    method: string;
    status?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    paymentScreenshot?: string | null;
    senderPhone?: string | null;
    notes?: string | null;
    order: OrderCreateNestedOneWithoutPaymentInput;
  };

  export type PaymentUncheckedCreateInput = {
    id?: string;
    orderId: string;
    amount: number;
    currency?: string;
    method: string;
    status?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    paymentScreenshot?: string | null;
    senderPhone?: string | null;
    notes?: string | null;
  };

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    amount?: IntFieldUpdateOperationsInput | number;
    currency?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    paymentScreenshot?: NullableStringFieldUpdateOperationsInput | string | null;
    senderPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    order?: OrderUpdateOneRequiredWithoutPaymentNestedInput;
  };

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orderId?: StringFieldUpdateOperationsInput | string;
    amount?: IntFieldUpdateOperationsInput | number;
    currency?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    paymentScreenshot?: NullableStringFieldUpdateOperationsInput | string | null;
    senderPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type PaymentCreateManyInput = {
    id?: string;
    orderId: string;
    amount: number;
    currency?: string;
    method: string;
    status?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    paymentScreenshot?: string | null;
    senderPhone?: string | null;
    notes?: string | null;
  };

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    amount?: IntFieldUpdateOperationsInput | number;
    currency?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    paymentScreenshot?: NullableStringFieldUpdateOperationsInput | string | null;
    senderPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orderId?: StringFieldUpdateOperationsInput | string;
    amount?: IntFieldUpdateOperationsInput | number;
    currency?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    paymentScreenshot?: NullableStringFieldUpdateOperationsInput | string | null;
    senderPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AuditLogCreateInput = {
    id?: string;
    action: string;
    entityType: string;
    entityId?: string | null;
    oldValues?: string | null;
    newValues?: string | null;
    ipAddress?: string | null;
    userAgent?: string | null;
    createdAt?: Date | string;
    user?: UserCreateNestedOneWithoutAuditLogsInput;
  };

  export type AuditLogUncheckedCreateInput = {
    id?: string;
    userId?: string | null;
    action: string;
    entityType: string;
    entityId?: string | null;
    oldValues?: string | null;
    newValues?: string | null;
    ipAddress?: string | null;
    userAgent?: string | null;
    createdAt?: Date | string;
  };

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    oldValues?: NullableStringFieldUpdateOperationsInput | string | null;
    newValues?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneWithoutAuditLogsNestedInput;
  };

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    oldValues?: NullableStringFieldUpdateOperationsInput | string | null;
    newValues?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogCreateManyInput = {
    id?: string;
    userId?: string | null;
    action: string;
    entityType: string;
    entityId?: string | null;
    oldValues?: string | null;
    newValues?: string | null;
    ipAddress?: string | null;
    userAgent?: string | null;
    createdAt?: Date | string;
  };

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    oldValues?: NullableStringFieldUpdateOperationsInput | string | null;
    newValues?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    oldValues?: NullableStringFieldUpdateOperationsInput | string | null;
    newValues?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FAQCreateInput = {
    id?: string;
    question: string;
    answer: string;
    orderIndex?: number;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FAQUncheckedCreateInput = {
    id?: string;
    question: string;
    answer: string;
    orderIndex?: number;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FAQUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    question?: StringFieldUpdateOperationsInput | string;
    answer?: StringFieldUpdateOperationsInput | string;
    orderIndex?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FAQUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    question?: StringFieldUpdateOperationsInput | string;
    answer?: StringFieldUpdateOperationsInput | string;
    orderIndex?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FAQCreateManyInput = {
    id?: string;
    question: string;
    answer: string;
    orderIndex?: number;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FAQUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    question?: StringFieldUpdateOperationsInput | string;
    answer?: StringFieldUpdateOperationsInput | string;
    orderIndex?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FAQUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    question?: StringFieldUpdateOperationsInput | string;
    answer?: StringFieldUpdateOperationsInput | string;
    orderIndex?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DocumentCreateInput = {
    id?: string;
    fileName: string;
    filePath: string;
    fileType: string;
    fileSize: number;
    uploadedAt?: Date | string;
    order: OrderCreateNestedOneWithoutDocumentsInput;
  };

  export type DocumentUncheckedCreateInput = {
    id?: string;
    orderId: string;
    fileName: string;
    filePath: string;
    fileType: string;
    fileSize: number;
    uploadedAt?: Date | string;
  };

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fileName?: StringFieldUpdateOperationsInput | string;
    filePath?: StringFieldUpdateOperationsInput | string;
    fileType?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    order?: OrderUpdateOneRequiredWithoutDocumentsNestedInput;
  };

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orderId?: StringFieldUpdateOperationsInput | string;
    fileName?: StringFieldUpdateOperationsInput | string;
    filePath?: StringFieldUpdateOperationsInput | string;
    fileType?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DocumentCreateManyInput = {
    id?: string;
    orderId: string;
    fileName: string;
    filePath: string;
    fileType: string;
    fileSize: number;
    uploadedAt?: Date | string;
  };

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fileName?: StringFieldUpdateOperationsInput | string;
    filePath?: StringFieldUpdateOperationsInput | string;
    fileType?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orderId?: StringFieldUpdateOperationsInput | string;
    fileName?: StringFieldUpdateOperationsInput | string;
    filePath?: StringFieldUpdateOperationsInput | string;
    fileType?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrderDocumentCreateInput = {
    id?: string;
    fileName: string;
    filePath: string;
    fileSize: number;
    fileType: string;
    documentType: string;
    uploadedAt?: Date | string;
    order: OrderCreateNestedOneWithoutOrderDocumentsInput;
  };

  export type OrderDocumentUncheckedCreateInput = {
    id?: string;
    orderId: string;
    fileName: string;
    filePath: string;
    fileSize: number;
    fileType: string;
    documentType: string;
    uploadedAt?: Date | string;
  };

  export type OrderDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fileName?: StringFieldUpdateOperationsInput | string;
    filePath?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    fileType?: StringFieldUpdateOperationsInput | string;
    documentType?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    order?: OrderUpdateOneRequiredWithoutOrderDocumentsNestedInput;
  };

  export type OrderDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orderId?: StringFieldUpdateOperationsInput | string;
    fileName?: StringFieldUpdateOperationsInput | string;
    filePath?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    fileType?: StringFieldUpdateOperationsInput | string;
    documentType?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrderDocumentCreateManyInput = {
    id?: string;
    orderId: string;
    fileName: string;
    filePath: string;
    fileSize: number;
    fileType: string;
    documentType: string;
    uploadedAt?: Date | string;
  };

  export type OrderDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fileName?: StringFieldUpdateOperationsInput | string;
    filePath?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    fileType?: StringFieldUpdateOperationsInput | string;
    documentType?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrderDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    orderId?: StringFieldUpdateOperationsInput | string;
    fileName?: StringFieldUpdateOperationsInput | string;
    filePath?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    fileType?: StringFieldUpdateOperationsInput | string;
    documentType?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ServiceDocumentCreateInput = {
    id?: string;
    title: string;
    description?: string | null;
    required?: boolean;
    showIf?: string | null;
    orderIndex?: number;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    service: ServiceCreateNestedOneWithoutDocumentsInput;
  };

  export type ServiceDocumentUncheckedCreateInput = {
    id?: string;
    serviceId: string;
    title: string;
    description?: string | null;
    required?: boolean;
    showIf?: string | null;
    orderIndex?: number;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ServiceDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    required?: BoolFieldUpdateOperationsInput | boolean;
    showIf?: NullableStringFieldUpdateOperationsInput | string | null;
    orderIndex?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    service?: ServiceUpdateOneRequiredWithoutDocumentsNestedInput;
  };

  export type ServiceDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    required?: BoolFieldUpdateOperationsInput | boolean;
    showIf?: NullableStringFieldUpdateOperationsInput | string | null;
    orderIndex?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ServiceDocumentCreateManyInput = {
    id?: string;
    serviceId: string;
    title: string;
    description?: string | null;
    required?: boolean;
    showIf?: string | null;
    orderIndex?: number;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ServiceDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    required?: BoolFieldUpdateOperationsInput | boolean;
    showIf?: NullableStringFieldUpdateOperationsInput | string | null;
    orderIndex?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ServiceDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    required?: BoolFieldUpdateOperationsInput | boolean;
    showIf?: NullableStringFieldUpdateOperationsInput | string | null;
    orderIndex?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SystemSettingsCreateInput = {
    id?: string;
    siteName?: string;
    siteDescription?: string | null;
    contactEmail?: string | null;
    contactPhone?: string | null;
    address?: string | null;
    workingHours?: string | null;
    socialLinks?: string | null;
    seoSettings?: string | null;
    updatedAt?: Date | string;
  };

  export type SystemSettingsUncheckedCreateInput = {
    id?: string;
    siteName?: string;
    siteDescription?: string | null;
    contactEmail?: string | null;
    contactPhone?: string | null;
    address?: string | null;
    workingHours?: string | null;
    socialLinks?: string | null;
    seoSettings?: string | null;
    updatedAt?: Date | string;
  };

  export type SystemSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    siteName?: StringFieldUpdateOperationsInput | string;
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    workingHours?: NullableStringFieldUpdateOperationsInput | string | null;
    socialLinks?: NullableStringFieldUpdateOperationsInput | string | null;
    seoSettings?: NullableStringFieldUpdateOperationsInput | string | null;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SystemSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    siteName?: StringFieldUpdateOperationsInput | string;
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    workingHours?: NullableStringFieldUpdateOperationsInput | string | null;
    socialLinks?: NullableStringFieldUpdateOperationsInput | string | null;
    seoSettings?: NullableStringFieldUpdateOperationsInput | string | null;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SystemSettingsCreateManyInput = {
    id?: string;
    siteName?: string;
    siteDescription?: string | null;
    contactEmail?: string | null;
    contactPhone?: string | null;
    address?: string | null;
    workingHours?: string | null;
    socialLinks?: string | null;
    seoSettings?: string | null;
    updatedAt?: Date | string;
  };

  export type SystemSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    siteName?: StringFieldUpdateOperationsInput | string;
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    workingHours?: NullableStringFieldUpdateOperationsInput | string | null;
    socialLinks?: NullableStringFieldUpdateOperationsInput | string | null;
    seoSettings?: NullableStringFieldUpdateOperationsInput | string | null;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SystemSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    siteName?: StringFieldUpdateOperationsInput | string;
    siteDescription?: NullableStringFieldUpdateOperationsInput | string | null;
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null;
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    workingHours?: NullableStringFieldUpdateOperationsInput | string | null;
    socialLinks?: NullableStringFieldUpdateOperationsInput | string | null;
    seoSettings?: NullableStringFieldUpdateOperationsInput | string | null;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FormTypeCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    variantLinks?: FormTypeVariantCreateNestedManyWithoutFormTypeInput;
    serials?: FormSerialCreateNestedManyWithoutFormTypeInput;
  };

  export type FormTypeUncheckedCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    variantLinks?: FormTypeVariantUncheckedCreateNestedManyWithoutFormTypeInput;
    serials?: FormSerialUncheckedCreateNestedManyWithoutFormTypeInput;
  };

  export type FormTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    variantLinks?: FormTypeVariantUpdateManyWithoutFormTypeNestedInput;
    serials?: FormSerialUpdateManyWithoutFormTypeNestedInput;
  };

  export type FormTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    variantLinks?: FormTypeVariantUncheckedUpdateManyWithoutFormTypeNestedInput;
    serials?: FormSerialUncheckedUpdateManyWithoutFormTypeNestedInput;
  };

  export type FormTypeCreateManyInput = {
    id?: string;
    name: string;
    description?: string | null;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FormTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FormTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FormTypeVariantCreateInput = {
    id?: string;
    createdAt?: Date | string;
    formType: FormTypeCreateNestedOneWithoutVariantLinksInput;
    serviceVariant: ServiceVariantCreateNestedOneWithoutFormTypeLinksInput;
  };

  export type FormTypeVariantUncheckedCreateInput = {
    id?: string;
    formTypeId: string;
    serviceVariantId: string;
    createdAt?: Date | string;
  };

  export type FormTypeVariantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    formType?: FormTypeUpdateOneRequiredWithoutVariantLinksNestedInput;
    serviceVariant?: ServiceVariantUpdateOneRequiredWithoutFormTypeLinksNestedInput;
  };

  export type FormTypeVariantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    formTypeId?: StringFieldUpdateOperationsInput | string;
    serviceVariantId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FormTypeVariantCreateManyInput = {
    id?: string;
    formTypeId: string;
    serviceVariantId: string;
    createdAt?: Date | string;
  };

  export type FormTypeVariantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FormTypeVariantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    formTypeId?: StringFieldUpdateOperationsInput | string;
    serviceVariantId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FormSerialCreateInput = {
    id?: string;
    serialNumber: string;
    consumed?: boolean;
    consumedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    formType: FormTypeCreateNestedOneWithoutSerialsInput;
    order?: OrderCreateNestedOneWithoutFormSerialsInput;
    addedByAdmin?: UserCreateNestedOneWithoutAddedFormSerialsInput;
    consumedByAdmin?: UserCreateNestedOneWithoutConsumedFormSerialsInput;
  };

  export type FormSerialUncheckedCreateInput = {
    id?: string;
    formTypeId: string;
    serialNumber: string;
    orderId?: string | null;
    consumed?: boolean;
    consumedAt?: Date | string | null;
    addedByAdminId?: string | null;
    consumedByAdminId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FormSerialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serialNumber?: StringFieldUpdateOperationsInput | string;
    consumed?: BoolFieldUpdateOperationsInput | boolean;
    consumedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    formType?: FormTypeUpdateOneRequiredWithoutSerialsNestedInput;
    order?: OrderUpdateOneWithoutFormSerialsNestedInput;
    addedByAdmin?: UserUpdateOneWithoutAddedFormSerialsNestedInput;
    consumedByAdmin?: UserUpdateOneWithoutConsumedFormSerialsNestedInput;
  };

  export type FormSerialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    formTypeId?: StringFieldUpdateOperationsInput | string;
    serialNumber?: StringFieldUpdateOperationsInput | string;
    orderId?: NullableStringFieldUpdateOperationsInput | string | null;
    consumed?: BoolFieldUpdateOperationsInput | boolean;
    consumedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    addedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    consumedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FormSerialCreateManyInput = {
    id?: string;
    formTypeId: string;
    serialNumber: string;
    orderId?: string | null;
    consumed?: boolean;
    consumedAt?: Date | string | null;
    addedByAdminId?: string | null;
    consumedByAdminId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FormSerialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serialNumber?: StringFieldUpdateOperationsInput | string;
    consumed?: BoolFieldUpdateOperationsInput | boolean;
    consumedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FormSerialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    formTypeId?: StringFieldUpdateOperationsInput | string;
    serialNumber?: StringFieldUpdateOperationsInput | string;
    orderId?: NullableStringFieldUpdateOperationsInput | string | null;
    consumed?: BoolFieldUpdateOperationsInput | boolean;
    consumedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    addedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    consumedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DependentCreateInput = {
    id?: string;
    name: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdByAdmin?: UserCreateNestedOneWithoutCreatedDependentsInput;
  };

  export type DependentUncheckedCreateInput = {
    id?: string;
    name: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdByAdminId?: string | null;
  };

  export type DependentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdByAdmin?: UserUpdateOneWithoutCreatedDependentsNestedInput;
  };

  export type DependentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type DependentCreateManyInput = {
    id?: string;
    name: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdByAdminId?: string | null;
  };

  export type DependentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DependentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type PromoCodeCreateInput = {
    id?: string;
    code: string;
    type?: string;
    value: number;
    minOrderAmount?: number | null;
    maxDiscount?: number | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    usageLimit?: number | null;
    currentUsage?: number;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    orders?: OrderCreateNestedManyWithoutPromoCodeInput;
  };

  export type PromoCodeUncheckedCreateInput = {
    id?: string;
    code: string;
    type?: string;
    value: number;
    minOrderAmount?: number | null;
    maxDiscount?: number | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    usageLimit?: number | null;
    currentUsage?: number;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    orders?: OrderUncheckedCreateNestedManyWithoutPromoCodeInput;
  };

  export type PromoCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    value?: IntFieldUpdateOperationsInput | number;
    minOrderAmount?: NullableIntFieldUpdateOperationsInput | number | null;
    maxDiscount?: NullableIntFieldUpdateOperationsInput | number | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null;
    currentUsage?: IntFieldUpdateOperationsInput | number;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    orders?: OrderUpdateManyWithoutPromoCodeNestedInput;
  };

  export type PromoCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    value?: IntFieldUpdateOperationsInput | number;
    minOrderAmount?: NullableIntFieldUpdateOperationsInput | number | null;
    maxDiscount?: NullableIntFieldUpdateOperationsInput | number | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null;
    currentUsage?: IntFieldUpdateOperationsInput | number;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    orders?: OrderUncheckedUpdateManyWithoutPromoCodeNestedInput;
  };

  export type PromoCodeCreateManyInput = {
    id?: string;
    code: string;
    type?: string;
    value: number;
    minOrderAmount?: number | null;
    maxDiscount?: number | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    usageLimit?: number | null;
    currentUsage?: number;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PromoCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    value?: IntFieldUpdateOperationsInput | number;
    minOrderAmount?: NullableIntFieldUpdateOperationsInput | number | null;
    maxDiscount?: NullableIntFieldUpdateOperationsInput | number | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null;
    currentUsage?: IntFieldUpdateOperationsInput | number;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PromoCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    value?: IntFieldUpdateOperationsInput | number;
    minOrderAmount?: NullableIntFieldUpdateOperationsInput | number | null;
    maxDiscount?: NullableIntFieldUpdateOperationsInput | number | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null;
    currentUsage?: IntFieldUpdateOperationsInput | number;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type UserRelationFilter = {
    is?: UserWhereInput;
    isNot?: UserWhereInput;
  };

  export type SortOrderInput = {
    sort: SortOrder;
    nulls?: NullsOrder;
  };

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string;
    providerAccountId: string;
  };

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrder;
    access_token?: SortOrder;
    expires_at?: SortOrder;
    token_type?: SortOrder;
    scope?: SortOrder;
    id_token?: SortOrder;
    session_state?: SortOrder;
  };

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder;
  };

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrder;
    access_token?: SortOrder;
    expires_at?: SortOrder;
    token_type?: SortOrder;
    scope?: SortOrder;
    id_token?: SortOrder;
    session_state?: SortOrder;
  };

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrder;
    access_token?: SortOrder;
    expires_at?: SortOrder;
    token_type?: SortOrder;
    scope?: SortOrder;
    id_token?: SortOrder;
    session_state?: SortOrder;
  };

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder;
  };

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder;
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
  };

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder;
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
  };

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder;
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
  };

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string;
    token: string;
  };

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
  };

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
  };

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
  };

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null;
    isNot?: UserWhereInput | null;
  };

  export type UserListRelationFilter = {
    every?: UserWhereInput;
    some?: UserWhereInput;
    none?: UserWhereInput;
  };

  export type OrderListRelationFilter = {
    every?: OrderWhereInput;
    some?: OrderWhereInput;
    none?: OrderWhereInput;
  };

  export type AccountListRelationFilter = {
    every?: AccountWhereInput;
    some?: AccountWhereInput;
    none?: AccountWhereInput;
  };

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput;
    some?: AuditLogWhereInput;
    none?: AuditLogWhereInput;
  };

  export type SessionListRelationFilter = {
    every?: SessionWhereInput;
    some?: SessionWhereInput;
    none?: SessionWhereInput;
  };

  export type FormSerialListRelationFilter = {
    every?: FormSerialWhereInput;
    some?: FormSerialWhereInput;
    none?: FormSerialWhereInput;
  };

  export type DependentListRelationFilter = {
    every?: DependentWhereInput;
    some?: DependentWhereInput;
    none?: DependentWhereInput;
  };

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type FormSerialOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type DependentOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrder;
    image?: SortOrder;
    passwordHash?: SortOrder;
    phone?: SortOrder;
    additionalPhone?: SortOrder;
    role?: SortOrder;
    createdByAdminId?: SortOrder;
    resetToken?: SortOrder;
    resetTokenExpiry?: SortOrder;
    verificationToken?: SortOrder;
    verificationTokenExpiry?: SortOrder;
    verificationCode?: SortOrder;
    verificationCodeExpiry?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    address?: SortOrder;
    governorate?: SortOrder;
    city?: SortOrder;
    district?: SortOrder;
    street?: SortOrder;
    buildingNumber?: SortOrder;
    apartmentNumber?: SortOrder;
    landmark?: SortOrder;
    birthDate?: SortOrder;
    fatherName?: SortOrder;
    idNumber?: SortOrder;
    motherName?: SortOrder;
    nationality?: SortOrder;
    wifeName?: SortOrder;
    wifeMotherName?: SortOrder;
  };

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrder;
    image?: SortOrder;
    passwordHash?: SortOrder;
    phone?: SortOrder;
    additionalPhone?: SortOrder;
    role?: SortOrder;
    createdByAdminId?: SortOrder;
    resetToken?: SortOrder;
    resetTokenExpiry?: SortOrder;
    verificationToken?: SortOrder;
    verificationTokenExpiry?: SortOrder;
    verificationCode?: SortOrder;
    verificationCodeExpiry?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    address?: SortOrder;
    governorate?: SortOrder;
    city?: SortOrder;
    district?: SortOrder;
    street?: SortOrder;
    buildingNumber?: SortOrder;
    apartmentNumber?: SortOrder;
    landmark?: SortOrder;
    birthDate?: SortOrder;
    fatherName?: SortOrder;
    idNumber?: SortOrder;
    motherName?: SortOrder;
    nationality?: SortOrder;
    wifeName?: SortOrder;
    wifeMotherName?: SortOrder;
  };

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrder;
    image?: SortOrder;
    passwordHash?: SortOrder;
    phone?: SortOrder;
    additionalPhone?: SortOrder;
    role?: SortOrder;
    createdByAdminId?: SortOrder;
    resetToken?: SortOrder;
    resetTokenExpiry?: SortOrder;
    verificationToken?: SortOrder;
    verificationTokenExpiry?: SortOrder;
    verificationCode?: SortOrder;
    verificationCodeExpiry?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    address?: SortOrder;
    governorate?: SortOrder;
    city?: SortOrder;
    district?: SortOrder;
    street?: SortOrder;
    buildingNumber?: SortOrder;
    apartmentNumber?: SortOrder;
    landmark?: SortOrder;
    birthDate?: SortOrder;
    fatherName?: SortOrder;
    idNumber?: SortOrder;
    motherName?: SortOrder;
    nationality?: SortOrder;
    wifeName?: SortOrder;
    wifeMotherName?: SortOrder;
  };

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput;
    some?: ServiceWhereInput;
    none?: ServiceWhereInput;
  };

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    orderIndex?: SortOrder;
    active?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    icon?: SortOrder;
  };

  export type CategoryAvgOrderByAggregateInput = {
    orderIndex?: SortOrder;
  };

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    orderIndex?: SortOrder;
    active?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    icon?: SortOrder;
  };

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    orderIndex?: SortOrder;
    active?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    icon?: SortOrder;
  };

  export type CategorySumOrderByAggregateInput = {
    orderIndex?: SortOrder;
  };

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type CategoryRelationFilter = {
    is?: CategoryWhereInput;
    isNot?: CategoryWhereInput;
  };

  export type ServiceDocumentListRelationFilter = {
    every?: ServiceDocumentWhereInput;
    some?: ServiceDocumentWhereInput;
    none?: ServiceDocumentWhereInput;
  };

  export type ServiceVariantListRelationFilter = {
    every?: ServiceVariantWhereInput;
    some?: ServiceVariantWhereInput;
    none?: ServiceVariantWhereInput;
  };

  export type ServiceFieldListRelationFilter = {
    every?: ServiceFieldWhereInput;
    some?: ServiceFieldWhereInput;
    none?: ServiceFieldWhereInput;
  };

  export type ServiceDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ServiceVariantOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ServiceFieldOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    description?: SortOrder;
    icon?: SortOrder;
    active?: SortOrder;
    categoryId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    description?: SortOrder;
    icon?: SortOrder;
    active?: SortOrder;
    categoryId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    description?: SortOrder;
    icon?: SortOrder;
    active?: SortOrder;
    categoryId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ServiceRelationFilter = {
    is?: ServiceWhereInput;
    isNot?: ServiceWhereInput;
  };

  export type ServiceFieldOptionListRelationFilter = {
    every?: ServiceFieldOptionWhereInput;
    some?: ServiceFieldOptionWhereInput;
    none?: ServiceFieldOptionWhereInput;
  };

  export type ServiceFieldOptionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ServiceFieldCountOrderByAggregateInput = {
    id?: SortOrder;
    serviceId?: SortOrder;
    name?: SortOrder;
    label?: SortOrder;
    type?: SortOrder;
    placeholder?: SortOrder;
    required?: SortOrder;
    orderIndex?: SortOrder;
    active?: SortOrder;
    showIf?: SortOrder;
    validation?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ServiceFieldAvgOrderByAggregateInput = {
    orderIndex?: SortOrder;
  };

  export type ServiceFieldMaxOrderByAggregateInput = {
    id?: SortOrder;
    serviceId?: SortOrder;
    name?: SortOrder;
    label?: SortOrder;
    type?: SortOrder;
    placeholder?: SortOrder;
    required?: SortOrder;
    orderIndex?: SortOrder;
    active?: SortOrder;
    showIf?: SortOrder;
    validation?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ServiceFieldMinOrderByAggregateInput = {
    id?: SortOrder;
    serviceId?: SortOrder;
    name?: SortOrder;
    label?: SortOrder;
    type?: SortOrder;
    placeholder?: SortOrder;
    required?: SortOrder;
    orderIndex?: SortOrder;
    active?: SortOrder;
    showIf?: SortOrder;
    validation?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ServiceFieldSumOrderByAggregateInput = {
    orderIndex?: SortOrder;
  };

  export type ServiceFieldRelationFilter = {
    is?: ServiceFieldWhereInput;
    isNot?: ServiceFieldWhereInput;
  };

  export type ServiceFieldOptionCountOrderByAggregateInput = {
    id?: SortOrder;
    fieldId?: SortOrder;
    value?: SortOrder;
    label?: SortOrder;
    orderIndex?: SortOrder;
    requiredDocs?: SortOrder;
    showFields?: SortOrder;
    createdAt?: SortOrder;
  };

  export type ServiceFieldOptionAvgOrderByAggregateInput = {
    orderIndex?: SortOrder;
  };

  export type ServiceFieldOptionMaxOrderByAggregateInput = {
    id?: SortOrder;
    fieldId?: SortOrder;
    value?: SortOrder;
    label?: SortOrder;
    orderIndex?: SortOrder;
    requiredDocs?: SortOrder;
    showFields?: SortOrder;
    createdAt?: SortOrder;
  };

  export type ServiceFieldOptionMinOrderByAggregateInput = {
    id?: SortOrder;
    fieldId?: SortOrder;
    value?: SortOrder;
    label?: SortOrder;
    orderIndex?: SortOrder;
    requiredDocs?: SortOrder;
    showFields?: SortOrder;
    createdAt?: SortOrder;
  };

  export type ServiceFieldOptionSumOrderByAggregateInput = {
    orderIndex?: SortOrder;
  };

  export type FormTypeVariantListRelationFilter = {
    every?: FormTypeVariantWhereInput;
    some?: FormTypeVariantWhereInput;
    none?: FormTypeVariantWhereInput;
  };

  export type FormTypeVariantOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ServiceVariantCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    priceCents?: SortOrder;
    etaDays?: SortOrder;
    serviceId?: SortOrder;
    active?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ServiceVariantAvgOrderByAggregateInput = {
    priceCents?: SortOrder;
    etaDays?: SortOrder;
  };

  export type ServiceVariantMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    priceCents?: SortOrder;
    etaDays?: SortOrder;
    serviceId?: SortOrder;
    active?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ServiceVariantMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    priceCents?: SortOrder;
    etaDays?: SortOrder;
    serviceId?: SortOrder;
    active?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ServiceVariantSumOrderByAggregateInput = {
    priceCents?: SortOrder;
    etaDays?: SortOrder;
  };

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput;
    some?: DocumentWhereInput;
    none?: DocumentWhereInput;
  };

  export type ServiceVariantRelationFilter = {
    is?: ServiceVariantWhereInput;
    isNot?: ServiceVariantWhereInput;
  };

  export type OrderDocumentListRelationFilter = {
    every?: OrderDocumentWhereInput;
    some?: OrderDocumentWhereInput;
    none?: OrderDocumentWhereInput;
  };

  export type PaymentNullableRelationFilter = {
    is?: PaymentWhereInput | null;
    isNot?: PaymentWhereInput | null;
  };

  export type PromoCodeNullableRelationFilter = {
    is?: PromoCodeWhereInput | null;
    isNot?: PromoCodeWhereInput | null;
  };

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type OrderDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    serviceId?: SortOrder;
    variantId?: SortOrder;
    status?: SortOrder;
    totalPrice?: SortOrder;
    totalCents?: SortOrder;
    customerName?: SortOrder;
    customerPhone?: SortOrder;
    additionalPhone?: SortOrder;
    customerEmail?: SortOrder;
    address?: SortOrder;
    governorate?: SortOrder;
    city?: SortOrder;
    district?: SortOrder;
    street?: SortOrder;
    buildingNumber?: SortOrder;
    apartmentNumber?: SortOrder;
    landmark?: SortOrder;
    notes?: SortOrder;
    adminNotes?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    completedAt?: SortOrder;
    estimatedCompletionDate?: SortOrder;
    deliveryFee?: SortOrder;
    deliveryType?: SortOrder;
    createdByAdminId?: SortOrder;
    birthDate?: SortOrder;
    fatherName?: SortOrder;
    idNumber?: SortOrder;
    motherName?: SortOrder;
    nationality?: SortOrder;
    wifeName?: SortOrder;
    photographyLocation?: SortOrder;
    photographyDate?: SortOrder;
    marriageDate?: SortOrder;
    divorceDate?: SortOrder;
    wifeMotherName?: SortOrder;
    quantity?: SortOrder;
    serviceDetails?: SortOrder;
    otherFees?: SortOrder;
    discount?: SortOrder;
    gender?: SortOrder;
    policeStation?: SortOrder;
    pickupLocation?: SortOrder;
    originalDocuments?: SortOrder;
    attachedDocuments?: SortOrder;
    hasAttachments?: SortOrder;
    selectedFines?: SortOrder;
    finesDetails?: SortOrder;
    servicesDetails?: SortOrder;
    customerFollowUp?: SortOrder;
    promoCodeId?: SortOrder;
    discountAmount?: SortOrder;
  };

  export type OrderAvgOrderByAggregateInput = {
    totalPrice?: SortOrder;
    totalCents?: SortOrder;
    deliveryFee?: SortOrder;
    quantity?: SortOrder;
    otherFees?: SortOrder;
    discount?: SortOrder;
    discountAmount?: SortOrder;
  };

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    serviceId?: SortOrder;
    variantId?: SortOrder;
    status?: SortOrder;
    totalPrice?: SortOrder;
    totalCents?: SortOrder;
    customerName?: SortOrder;
    customerPhone?: SortOrder;
    additionalPhone?: SortOrder;
    customerEmail?: SortOrder;
    address?: SortOrder;
    governorate?: SortOrder;
    city?: SortOrder;
    district?: SortOrder;
    street?: SortOrder;
    buildingNumber?: SortOrder;
    apartmentNumber?: SortOrder;
    landmark?: SortOrder;
    notes?: SortOrder;
    adminNotes?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    completedAt?: SortOrder;
    estimatedCompletionDate?: SortOrder;
    deliveryFee?: SortOrder;
    deliveryType?: SortOrder;
    createdByAdminId?: SortOrder;
    birthDate?: SortOrder;
    fatherName?: SortOrder;
    idNumber?: SortOrder;
    motherName?: SortOrder;
    nationality?: SortOrder;
    wifeName?: SortOrder;
    photographyLocation?: SortOrder;
    photographyDate?: SortOrder;
    marriageDate?: SortOrder;
    divorceDate?: SortOrder;
    wifeMotherName?: SortOrder;
    quantity?: SortOrder;
    serviceDetails?: SortOrder;
    otherFees?: SortOrder;
    discount?: SortOrder;
    gender?: SortOrder;
    policeStation?: SortOrder;
    pickupLocation?: SortOrder;
    originalDocuments?: SortOrder;
    attachedDocuments?: SortOrder;
    hasAttachments?: SortOrder;
    selectedFines?: SortOrder;
    finesDetails?: SortOrder;
    servicesDetails?: SortOrder;
    customerFollowUp?: SortOrder;
    promoCodeId?: SortOrder;
    discountAmount?: SortOrder;
  };

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    serviceId?: SortOrder;
    variantId?: SortOrder;
    status?: SortOrder;
    totalPrice?: SortOrder;
    totalCents?: SortOrder;
    customerName?: SortOrder;
    customerPhone?: SortOrder;
    additionalPhone?: SortOrder;
    customerEmail?: SortOrder;
    address?: SortOrder;
    governorate?: SortOrder;
    city?: SortOrder;
    district?: SortOrder;
    street?: SortOrder;
    buildingNumber?: SortOrder;
    apartmentNumber?: SortOrder;
    landmark?: SortOrder;
    notes?: SortOrder;
    adminNotes?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    completedAt?: SortOrder;
    estimatedCompletionDate?: SortOrder;
    deliveryFee?: SortOrder;
    deliveryType?: SortOrder;
    createdByAdminId?: SortOrder;
    birthDate?: SortOrder;
    fatherName?: SortOrder;
    idNumber?: SortOrder;
    motherName?: SortOrder;
    nationality?: SortOrder;
    wifeName?: SortOrder;
    photographyLocation?: SortOrder;
    photographyDate?: SortOrder;
    marriageDate?: SortOrder;
    divorceDate?: SortOrder;
    wifeMotherName?: SortOrder;
    quantity?: SortOrder;
    serviceDetails?: SortOrder;
    otherFees?: SortOrder;
    discount?: SortOrder;
    gender?: SortOrder;
    policeStation?: SortOrder;
    pickupLocation?: SortOrder;
    originalDocuments?: SortOrder;
    attachedDocuments?: SortOrder;
    hasAttachments?: SortOrder;
    selectedFines?: SortOrder;
    finesDetails?: SortOrder;
    servicesDetails?: SortOrder;
    customerFollowUp?: SortOrder;
    promoCodeId?: SortOrder;
    discountAmount?: SortOrder;
  };

  export type OrderSumOrderByAggregateInput = {
    totalPrice?: SortOrder;
    totalCents?: SortOrder;
    deliveryFee?: SortOrder;
    quantity?: SortOrder;
    otherFees?: SortOrder;
    discount?: SortOrder;
    discountAmount?: SortOrder;
  };

  export type OrderRelationFilter = {
    is?: OrderWhereInput;
    isNot?: OrderWhereInput;
  };

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    amount?: SortOrder;
    currency?: SortOrder;
    method?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    paymentScreenshot?: SortOrder;
    senderPhone?: SortOrder;
    notes?: SortOrder;
  };

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder;
  };

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    amount?: SortOrder;
    currency?: SortOrder;
    method?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    paymentScreenshot?: SortOrder;
    senderPhone?: SortOrder;
    notes?: SortOrder;
  };

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    amount?: SortOrder;
    currency?: SortOrder;
    method?: SortOrder;
    status?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    paymentScreenshot?: SortOrder;
    senderPhone?: SortOrder;
    notes?: SortOrder;
  };

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder;
  };

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    action?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    oldValues?: SortOrder;
    newValues?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    createdAt?: SortOrder;
  };

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    action?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    oldValues?: SortOrder;
    newValues?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    createdAt?: SortOrder;
  };

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    action?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    oldValues?: SortOrder;
    newValues?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    createdAt?: SortOrder;
  };

  export type FAQCountOrderByAggregateInput = {
    id?: SortOrder;
    question?: SortOrder;
    answer?: SortOrder;
    orderIndex?: SortOrder;
    active?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type FAQAvgOrderByAggregateInput = {
    orderIndex?: SortOrder;
  };

  export type FAQMaxOrderByAggregateInput = {
    id?: SortOrder;
    question?: SortOrder;
    answer?: SortOrder;
    orderIndex?: SortOrder;
    active?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type FAQMinOrderByAggregateInput = {
    id?: SortOrder;
    question?: SortOrder;
    answer?: SortOrder;
    orderIndex?: SortOrder;
    active?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type FAQSumOrderByAggregateInput = {
    orderIndex?: SortOrder;
  };

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    fileName?: SortOrder;
    filePath?: SortOrder;
    fileType?: SortOrder;
    fileSize?: SortOrder;
    uploadedAt?: SortOrder;
  };

  export type DocumentAvgOrderByAggregateInput = {
    fileSize?: SortOrder;
  };

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    fileName?: SortOrder;
    filePath?: SortOrder;
    fileType?: SortOrder;
    fileSize?: SortOrder;
    uploadedAt?: SortOrder;
  };

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    fileName?: SortOrder;
    filePath?: SortOrder;
    fileType?: SortOrder;
    fileSize?: SortOrder;
    uploadedAt?: SortOrder;
  };

  export type DocumentSumOrderByAggregateInput = {
    fileSize?: SortOrder;
  };

  export type OrderDocumentCountOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    fileName?: SortOrder;
    filePath?: SortOrder;
    fileSize?: SortOrder;
    fileType?: SortOrder;
    documentType?: SortOrder;
    uploadedAt?: SortOrder;
  };

  export type OrderDocumentAvgOrderByAggregateInput = {
    fileSize?: SortOrder;
  };

  export type OrderDocumentMaxOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    fileName?: SortOrder;
    filePath?: SortOrder;
    fileSize?: SortOrder;
    fileType?: SortOrder;
    documentType?: SortOrder;
    uploadedAt?: SortOrder;
  };

  export type OrderDocumentMinOrderByAggregateInput = {
    id?: SortOrder;
    orderId?: SortOrder;
    fileName?: SortOrder;
    filePath?: SortOrder;
    fileSize?: SortOrder;
    fileType?: SortOrder;
    documentType?: SortOrder;
    uploadedAt?: SortOrder;
  };

  export type OrderDocumentSumOrderByAggregateInput = {
    fileSize?: SortOrder;
  };

  export type ServiceDocumentCountOrderByAggregateInput = {
    id?: SortOrder;
    serviceId?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    required?: SortOrder;
    showIf?: SortOrder;
    orderIndex?: SortOrder;
    active?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ServiceDocumentAvgOrderByAggregateInput = {
    orderIndex?: SortOrder;
  };

  export type ServiceDocumentMaxOrderByAggregateInput = {
    id?: SortOrder;
    serviceId?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    required?: SortOrder;
    showIf?: SortOrder;
    orderIndex?: SortOrder;
    active?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ServiceDocumentMinOrderByAggregateInput = {
    id?: SortOrder;
    serviceId?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    required?: SortOrder;
    showIf?: SortOrder;
    orderIndex?: SortOrder;
    active?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ServiceDocumentSumOrderByAggregateInput = {
    orderIndex?: SortOrder;
  };

  export type SystemSettingsCountOrderByAggregateInput = {
    id?: SortOrder;
    siteName?: SortOrder;
    siteDescription?: SortOrder;
    contactEmail?: SortOrder;
    contactPhone?: SortOrder;
    address?: SortOrder;
    workingHours?: SortOrder;
    socialLinks?: SortOrder;
    seoSettings?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type SystemSettingsMaxOrderByAggregateInput = {
    id?: SortOrder;
    siteName?: SortOrder;
    siteDescription?: SortOrder;
    contactEmail?: SortOrder;
    contactPhone?: SortOrder;
    address?: SortOrder;
    workingHours?: SortOrder;
    socialLinks?: SortOrder;
    seoSettings?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type SystemSettingsMinOrderByAggregateInput = {
    id?: SortOrder;
    siteName?: SortOrder;
    siteDescription?: SortOrder;
    contactEmail?: SortOrder;
    contactPhone?: SortOrder;
    address?: SortOrder;
    workingHours?: SortOrder;
    socialLinks?: SortOrder;
    seoSettings?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type FormTypeCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    active?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type FormTypeMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    active?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type FormTypeMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    active?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type FormTypeRelationFilter = {
    is?: FormTypeWhereInput;
    isNot?: FormTypeWhereInput;
  };

  export type FormTypeVariantFormTypeIdServiceVariantIdCompoundUniqueInput = {
    formTypeId: string;
    serviceVariantId: string;
  };

  export type FormTypeVariantCountOrderByAggregateInput = {
    id?: SortOrder;
    formTypeId?: SortOrder;
    serviceVariantId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type FormTypeVariantMaxOrderByAggregateInput = {
    id?: SortOrder;
    formTypeId?: SortOrder;
    serviceVariantId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type FormTypeVariantMinOrderByAggregateInput = {
    id?: SortOrder;
    formTypeId?: SortOrder;
    serviceVariantId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type OrderNullableRelationFilter = {
    is?: OrderWhereInput | null;
    isNot?: OrderWhereInput | null;
  };

  export type FormSerialFormTypeIdSerialNumberCompoundUniqueInput = {
    formTypeId: string;
    serialNumber: string;
  };

  export type FormSerialCountOrderByAggregateInput = {
    id?: SortOrder;
    formTypeId?: SortOrder;
    serialNumber?: SortOrder;
    orderId?: SortOrder;
    consumed?: SortOrder;
    consumedAt?: SortOrder;
    addedByAdminId?: SortOrder;
    consumedByAdminId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type FormSerialMaxOrderByAggregateInput = {
    id?: SortOrder;
    formTypeId?: SortOrder;
    serialNumber?: SortOrder;
    orderId?: SortOrder;
    consumed?: SortOrder;
    consumedAt?: SortOrder;
    addedByAdminId?: SortOrder;
    consumedByAdminId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type FormSerialMinOrderByAggregateInput = {
    id?: SortOrder;
    formTypeId?: SortOrder;
    serialNumber?: SortOrder;
    orderId?: SortOrder;
    consumed?: SortOrder;
    consumedAt?: SortOrder;
    addedByAdminId?: SortOrder;
    consumedByAdminId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type DependentCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdByAdminId?: SortOrder;
  };

  export type DependentMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdByAdminId?: SortOrder;
  };

  export type DependentMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdByAdminId?: SortOrder;
  };

  export type PromoCodeCountOrderByAggregateInput = {
    id?: SortOrder;
    code?: SortOrder;
    type?: SortOrder;
    value?: SortOrder;
    minOrderAmount?: SortOrder;
    maxDiscount?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    usageLimit?: SortOrder;
    currentUsage?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type PromoCodeAvgOrderByAggregateInput = {
    value?: SortOrder;
    minOrderAmount?: SortOrder;
    maxDiscount?: SortOrder;
    usageLimit?: SortOrder;
    currentUsage?: SortOrder;
  };

  export type PromoCodeMaxOrderByAggregateInput = {
    id?: SortOrder;
    code?: SortOrder;
    type?: SortOrder;
    value?: SortOrder;
    minOrderAmount?: SortOrder;
    maxDiscount?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    usageLimit?: SortOrder;
    currentUsage?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type PromoCodeMinOrderByAggregateInput = {
    id?: SortOrder;
    code?: SortOrder;
    type?: SortOrder;
    value?: SortOrder;
    minOrderAmount?: SortOrder;
    maxDiscount?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    usageLimit?: SortOrder;
    currentUsage?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type PromoCodeSumOrderByAggregateInput = {
    value?: SortOrder;
    minOrderAmount?: SortOrder;
    maxDiscount?: SortOrder;
    usageLimit?: SortOrder;
    currentUsage?: SortOrder;
  };

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput;
    connect?: UserWhereUniqueInput;
  };

  export type StringFieldUpdateOperationsInput = {
    set?: string;
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
  };

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput;
    upsert?: UserUpsertWithoutAccountsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>,
      UserUncheckedUpdateWithoutAccountsInput
    >;
  };

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput;
    connect?: UserWhereUniqueInput;
  };

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
  };

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput;
    upsert?: UserUpsertWithoutSessionsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>,
      UserUncheckedUpdateWithoutSessionsInput
    >;
  };

  export type UserCreateNestedOneWithoutCreatedUsersInput = {
    create?: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>;
    connectOrCreate?: UserCreateOrConnectWithoutCreatedUsersInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserCreateNestedManyWithoutCreatedByAdminInput = {
    create?:
      | XOR<UserCreateWithoutCreatedByAdminInput, UserUncheckedCreateWithoutCreatedByAdminInput>
      | UserCreateWithoutCreatedByAdminInput[]
      | UserUncheckedCreateWithoutCreatedByAdminInput[];
    connectOrCreate?:
      | UserCreateOrConnectWithoutCreatedByAdminInput
      | UserCreateOrConnectWithoutCreatedByAdminInput[];
    createMany?: UserCreateManyCreatedByAdminInputEnvelope;
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[];
  };

  export type OrderCreateNestedManyWithoutCreatedByAdminInput = {
    create?:
      | XOR<OrderCreateWithoutCreatedByAdminInput, OrderUncheckedCreateWithoutCreatedByAdminInput>
      | OrderCreateWithoutCreatedByAdminInput[]
      | OrderUncheckedCreateWithoutCreatedByAdminInput[];
    connectOrCreate?:
      | OrderCreateOrConnectWithoutCreatedByAdminInput
      | OrderCreateOrConnectWithoutCreatedByAdminInput[];
    createMany?: OrderCreateManyCreatedByAdminInputEnvelope;
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
  };

  export type OrderCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
      | OrderCreateWithoutUserInput[]
      | OrderUncheckedCreateWithoutUserInput[];
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[];
    createMany?: OrderCreateManyUserInputEnvelope;
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
  };

  export type AccountCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
  };

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
      | AuditLogCreateWithoutUserInput[]
      | AuditLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutUserInput
      | AuditLogCreateOrConnectWithoutUserInput[];
    createMany?: AuditLogCreateManyUserInputEnvelope;
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
  };

  export type SessionCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
  };

  export type FormSerialCreateNestedManyWithoutAddedByAdminInput = {
    create?:
      | XOR<
          FormSerialCreateWithoutAddedByAdminInput,
          FormSerialUncheckedCreateWithoutAddedByAdminInput
        >
      | FormSerialCreateWithoutAddedByAdminInput[]
      | FormSerialUncheckedCreateWithoutAddedByAdminInput[];
    connectOrCreate?:
      | FormSerialCreateOrConnectWithoutAddedByAdminInput
      | FormSerialCreateOrConnectWithoutAddedByAdminInput[];
    createMany?: FormSerialCreateManyAddedByAdminInputEnvelope;
    connect?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
  };

  export type FormSerialCreateNestedManyWithoutConsumedByAdminInput = {
    create?:
      | XOR<
          FormSerialCreateWithoutConsumedByAdminInput,
          FormSerialUncheckedCreateWithoutConsumedByAdminInput
        >
      | FormSerialCreateWithoutConsumedByAdminInput[]
      | FormSerialUncheckedCreateWithoutConsumedByAdminInput[];
    connectOrCreate?:
      | FormSerialCreateOrConnectWithoutConsumedByAdminInput
      | FormSerialCreateOrConnectWithoutConsumedByAdminInput[];
    createMany?: FormSerialCreateManyConsumedByAdminInputEnvelope;
    connect?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
  };

  export type DependentCreateNestedManyWithoutCreatedByAdminInput = {
    create?:
      | XOR<
          DependentCreateWithoutCreatedByAdminInput,
          DependentUncheckedCreateWithoutCreatedByAdminInput
        >
      | DependentCreateWithoutCreatedByAdminInput[]
      | DependentUncheckedCreateWithoutCreatedByAdminInput[];
    connectOrCreate?:
      | DependentCreateOrConnectWithoutCreatedByAdminInput
      | DependentCreateOrConnectWithoutCreatedByAdminInput[];
    createMany?: DependentCreateManyCreatedByAdminInputEnvelope;
    connect?: DependentWhereUniqueInput | DependentWhereUniqueInput[];
  };

  export type UserUncheckedCreateNestedManyWithoutCreatedByAdminInput = {
    create?:
      | XOR<UserCreateWithoutCreatedByAdminInput, UserUncheckedCreateWithoutCreatedByAdminInput>
      | UserCreateWithoutCreatedByAdminInput[]
      | UserUncheckedCreateWithoutCreatedByAdminInput[];
    connectOrCreate?:
      | UserCreateOrConnectWithoutCreatedByAdminInput
      | UserCreateOrConnectWithoutCreatedByAdminInput[];
    createMany?: UserCreateManyCreatedByAdminInputEnvelope;
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[];
  };

  export type OrderUncheckedCreateNestedManyWithoutCreatedByAdminInput = {
    create?:
      | XOR<OrderCreateWithoutCreatedByAdminInput, OrderUncheckedCreateWithoutCreatedByAdminInput>
      | OrderCreateWithoutCreatedByAdminInput[]
      | OrderUncheckedCreateWithoutCreatedByAdminInput[];
    connectOrCreate?:
      | OrderCreateOrConnectWithoutCreatedByAdminInput
      | OrderCreateOrConnectWithoutCreatedByAdminInput[];
    createMany?: OrderCreateManyCreatedByAdminInputEnvelope;
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
  };

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
      | OrderCreateWithoutUserInput[]
      | OrderUncheckedCreateWithoutUserInput[];
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[];
    createMany?: OrderCreateManyUserInputEnvelope;
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
  };

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
  };

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
      | AuditLogCreateWithoutUserInput[]
      | AuditLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutUserInput
      | AuditLogCreateOrConnectWithoutUserInput[];
    createMany?: AuditLogCreateManyUserInputEnvelope;
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
  };

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
  };

  export type FormSerialUncheckedCreateNestedManyWithoutAddedByAdminInput = {
    create?:
      | XOR<
          FormSerialCreateWithoutAddedByAdminInput,
          FormSerialUncheckedCreateWithoutAddedByAdminInput
        >
      | FormSerialCreateWithoutAddedByAdminInput[]
      | FormSerialUncheckedCreateWithoutAddedByAdminInput[];
    connectOrCreate?:
      | FormSerialCreateOrConnectWithoutAddedByAdminInput
      | FormSerialCreateOrConnectWithoutAddedByAdminInput[];
    createMany?: FormSerialCreateManyAddedByAdminInputEnvelope;
    connect?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
  };

  export type FormSerialUncheckedCreateNestedManyWithoutConsumedByAdminInput = {
    create?:
      | XOR<
          FormSerialCreateWithoutConsumedByAdminInput,
          FormSerialUncheckedCreateWithoutConsumedByAdminInput
        >
      | FormSerialCreateWithoutConsumedByAdminInput[]
      | FormSerialUncheckedCreateWithoutConsumedByAdminInput[];
    connectOrCreate?:
      | FormSerialCreateOrConnectWithoutConsumedByAdminInput
      | FormSerialCreateOrConnectWithoutConsumedByAdminInput[];
    createMany?: FormSerialCreateManyConsumedByAdminInputEnvelope;
    connect?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
  };

  export type DependentUncheckedCreateNestedManyWithoutCreatedByAdminInput = {
    create?:
      | XOR<
          DependentCreateWithoutCreatedByAdminInput,
          DependentUncheckedCreateWithoutCreatedByAdminInput
        >
      | DependentCreateWithoutCreatedByAdminInput[]
      | DependentUncheckedCreateWithoutCreatedByAdminInput[];
    connectOrCreate?:
      | DependentCreateOrConnectWithoutCreatedByAdminInput
      | DependentCreateOrConnectWithoutCreatedByAdminInput[];
    createMany?: DependentCreateManyCreatedByAdminInputEnvelope;
    connect?: DependentWhereUniqueInput | DependentWhereUniqueInput[];
  };

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
  };

  export type UserUpdateOneWithoutCreatedUsersNestedInput = {
    create?: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>;
    connectOrCreate?: UserCreateOrConnectWithoutCreatedUsersInput;
    upsert?: UserUpsertWithoutCreatedUsersInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutCreatedUsersInput, UserUpdateWithoutCreatedUsersInput>,
      UserUncheckedUpdateWithoutCreatedUsersInput
    >;
  };

  export type UserUpdateManyWithoutCreatedByAdminNestedInput = {
    create?:
      | XOR<UserCreateWithoutCreatedByAdminInput, UserUncheckedCreateWithoutCreatedByAdminInput>
      | UserCreateWithoutCreatedByAdminInput[]
      | UserUncheckedCreateWithoutCreatedByAdminInput[];
    connectOrCreate?:
      | UserCreateOrConnectWithoutCreatedByAdminInput
      | UserCreateOrConnectWithoutCreatedByAdminInput[];
    upsert?:
      | UserUpsertWithWhereUniqueWithoutCreatedByAdminInput
      | UserUpsertWithWhereUniqueWithoutCreatedByAdminInput[];
    createMany?: UserCreateManyCreatedByAdminInputEnvelope;
    set?: UserWhereUniqueInput | UserWhereUniqueInput[];
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[];
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[];
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[];
    update?:
      | UserUpdateWithWhereUniqueWithoutCreatedByAdminInput
      | UserUpdateWithWhereUniqueWithoutCreatedByAdminInput[];
    updateMany?:
      | UserUpdateManyWithWhereWithoutCreatedByAdminInput
      | UserUpdateManyWithWhereWithoutCreatedByAdminInput[];
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[];
  };

  export type OrderUpdateManyWithoutCreatedByAdminNestedInput = {
    create?:
      | XOR<OrderCreateWithoutCreatedByAdminInput, OrderUncheckedCreateWithoutCreatedByAdminInput>
      | OrderCreateWithoutCreatedByAdminInput[]
      | OrderUncheckedCreateWithoutCreatedByAdminInput[];
    connectOrCreate?:
      | OrderCreateOrConnectWithoutCreatedByAdminInput
      | OrderCreateOrConnectWithoutCreatedByAdminInput[];
    upsert?:
      | OrderUpsertWithWhereUniqueWithoutCreatedByAdminInput
      | OrderUpsertWithWhereUniqueWithoutCreatedByAdminInput[];
    createMany?: OrderCreateManyCreatedByAdminInputEnvelope;
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    update?:
      | OrderUpdateWithWhereUniqueWithoutCreatedByAdminInput
      | OrderUpdateWithWhereUniqueWithoutCreatedByAdminInput[];
    updateMany?:
      | OrderUpdateManyWithWhereWithoutCreatedByAdminInput
      | OrderUpdateManyWithWhereWithoutCreatedByAdminInput[];
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[];
  };

  export type OrderUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
      | OrderCreateWithoutUserInput[]
      | OrderUncheckedCreateWithoutUserInput[];
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[];
    upsert?:
      | OrderUpsertWithWhereUniqueWithoutUserInput
      | OrderUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: OrderCreateManyUserInputEnvelope;
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    update?:
      | OrderUpdateWithWhereUniqueWithoutUserInput
      | OrderUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | OrderUpdateManyWithWhereWithoutUserInput
      | OrderUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[];
  };

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    upsert?:
      | AccountUpsertWithWhereUniqueWithoutUserInput
      | AccountUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    update?:
      | AccountUpdateWithWhereUniqueWithoutUserInput
      | AccountUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AccountUpdateManyWithWhereWithoutUserInput
      | AccountUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[];
  };

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
      | AuditLogCreateWithoutUserInput[]
      | AuditLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutUserInput
      | AuditLogCreateOrConnectWithoutUserInput[];
    upsert?:
      | AuditLogUpsertWithWhereUniqueWithoutUserInput
      | AuditLogUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AuditLogCreateManyUserInputEnvelope;
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    update?:
      | AuditLogUpdateWithWhereUniqueWithoutUserInput
      | AuditLogUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AuditLogUpdateManyWithWhereWithoutUserInput
      | AuditLogUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
  };

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    upsert?:
      | SessionUpsertWithWhereUniqueWithoutUserInput
      | SessionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    update?:
      | SessionUpdateWithWhereUniqueWithoutUserInput
      | SessionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | SessionUpdateManyWithWhereWithoutUserInput
      | SessionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[];
  };

  export type FormSerialUpdateManyWithoutAddedByAdminNestedInput = {
    create?:
      | XOR<
          FormSerialCreateWithoutAddedByAdminInput,
          FormSerialUncheckedCreateWithoutAddedByAdminInput
        >
      | FormSerialCreateWithoutAddedByAdminInput[]
      | FormSerialUncheckedCreateWithoutAddedByAdminInput[];
    connectOrCreate?:
      | FormSerialCreateOrConnectWithoutAddedByAdminInput
      | FormSerialCreateOrConnectWithoutAddedByAdminInput[];
    upsert?:
      | FormSerialUpsertWithWhereUniqueWithoutAddedByAdminInput
      | FormSerialUpsertWithWhereUniqueWithoutAddedByAdminInput[];
    createMany?: FormSerialCreateManyAddedByAdminInputEnvelope;
    set?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
    disconnect?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
    delete?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
    connect?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
    update?:
      | FormSerialUpdateWithWhereUniqueWithoutAddedByAdminInput
      | FormSerialUpdateWithWhereUniqueWithoutAddedByAdminInput[];
    updateMany?:
      | FormSerialUpdateManyWithWhereWithoutAddedByAdminInput
      | FormSerialUpdateManyWithWhereWithoutAddedByAdminInput[];
    deleteMany?: FormSerialScalarWhereInput | FormSerialScalarWhereInput[];
  };

  export type FormSerialUpdateManyWithoutConsumedByAdminNestedInput = {
    create?:
      | XOR<
          FormSerialCreateWithoutConsumedByAdminInput,
          FormSerialUncheckedCreateWithoutConsumedByAdminInput
        >
      | FormSerialCreateWithoutConsumedByAdminInput[]
      | FormSerialUncheckedCreateWithoutConsumedByAdminInput[];
    connectOrCreate?:
      | FormSerialCreateOrConnectWithoutConsumedByAdminInput
      | FormSerialCreateOrConnectWithoutConsumedByAdminInput[];
    upsert?:
      | FormSerialUpsertWithWhereUniqueWithoutConsumedByAdminInput
      | FormSerialUpsertWithWhereUniqueWithoutConsumedByAdminInput[];
    createMany?: FormSerialCreateManyConsumedByAdminInputEnvelope;
    set?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
    disconnect?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
    delete?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
    connect?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
    update?:
      | FormSerialUpdateWithWhereUniqueWithoutConsumedByAdminInput
      | FormSerialUpdateWithWhereUniqueWithoutConsumedByAdminInput[];
    updateMany?:
      | FormSerialUpdateManyWithWhereWithoutConsumedByAdminInput
      | FormSerialUpdateManyWithWhereWithoutConsumedByAdminInput[];
    deleteMany?: FormSerialScalarWhereInput | FormSerialScalarWhereInput[];
  };

  export type DependentUpdateManyWithoutCreatedByAdminNestedInput = {
    create?:
      | XOR<
          DependentCreateWithoutCreatedByAdminInput,
          DependentUncheckedCreateWithoutCreatedByAdminInput
        >
      | DependentCreateWithoutCreatedByAdminInput[]
      | DependentUncheckedCreateWithoutCreatedByAdminInput[];
    connectOrCreate?:
      | DependentCreateOrConnectWithoutCreatedByAdminInput
      | DependentCreateOrConnectWithoutCreatedByAdminInput[];
    upsert?:
      | DependentUpsertWithWhereUniqueWithoutCreatedByAdminInput
      | DependentUpsertWithWhereUniqueWithoutCreatedByAdminInput[];
    createMany?: DependentCreateManyCreatedByAdminInputEnvelope;
    set?: DependentWhereUniqueInput | DependentWhereUniqueInput[];
    disconnect?: DependentWhereUniqueInput | DependentWhereUniqueInput[];
    delete?: DependentWhereUniqueInput | DependentWhereUniqueInput[];
    connect?: DependentWhereUniqueInput | DependentWhereUniqueInput[];
    update?:
      | DependentUpdateWithWhereUniqueWithoutCreatedByAdminInput
      | DependentUpdateWithWhereUniqueWithoutCreatedByAdminInput[];
    updateMany?:
      | DependentUpdateManyWithWhereWithoutCreatedByAdminInput
      | DependentUpdateManyWithWhereWithoutCreatedByAdminInput[];
    deleteMany?: DependentScalarWhereInput | DependentScalarWhereInput[];
  };

  export type UserUncheckedUpdateManyWithoutCreatedByAdminNestedInput = {
    create?:
      | XOR<UserCreateWithoutCreatedByAdminInput, UserUncheckedCreateWithoutCreatedByAdminInput>
      | UserCreateWithoutCreatedByAdminInput[]
      | UserUncheckedCreateWithoutCreatedByAdminInput[];
    connectOrCreate?:
      | UserCreateOrConnectWithoutCreatedByAdminInput
      | UserCreateOrConnectWithoutCreatedByAdminInput[];
    upsert?:
      | UserUpsertWithWhereUniqueWithoutCreatedByAdminInput
      | UserUpsertWithWhereUniqueWithoutCreatedByAdminInput[];
    createMany?: UserCreateManyCreatedByAdminInputEnvelope;
    set?: UserWhereUniqueInput | UserWhereUniqueInput[];
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[];
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[];
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[];
    update?:
      | UserUpdateWithWhereUniqueWithoutCreatedByAdminInput
      | UserUpdateWithWhereUniqueWithoutCreatedByAdminInput[];
    updateMany?:
      | UserUpdateManyWithWhereWithoutCreatedByAdminInput
      | UserUpdateManyWithWhereWithoutCreatedByAdminInput[];
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[];
  };

  export type OrderUncheckedUpdateManyWithoutCreatedByAdminNestedInput = {
    create?:
      | XOR<OrderCreateWithoutCreatedByAdminInput, OrderUncheckedCreateWithoutCreatedByAdminInput>
      | OrderCreateWithoutCreatedByAdminInput[]
      | OrderUncheckedCreateWithoutCreatedByAdminInput[];
    connectOrCreate?:
      | OrderCreateOrConnectWithoutCreatedByAdminInput
      | OrderCreateOrConnectWithoutCreatedByAdminInput[];
    upsert?:
      | OrderUpsertWithWhereUniqueWithoutCreatedByAdminInput
      | OrderUpsertWithWhereUniqueWithoutCreatedByAdminInput[];
    createMany?: OrderCreateManyCreatedByAdminInputEnvelope;
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    update?:
      | OrderUpdateWithWhereUniqueWithoutCreatedByAdminInput
      | OrderUpdateWithWhereUniqueWithoutCreatedByAdminInput[];
    updateMany?:
      | OrderUpdateManyWithWhereWithoutCreatedByAdminInput
      | OrderUpdateManyWithWhereWithoutCreatedByAdminInput[];
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[];
  };

  export type OrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
      | OrderCreateWithoutUserInput[]
      | OrderUncheckedCreateWithoutUserInput[];
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[];
    upsert?:
      | OrderUpsertWithWhereUniqueWithoutUserInput
      | OrderUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: OrderCreateManyUserInputEnvelope;
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    update?:
      | OrderUpdateWithWhereUniqueWithoutUserInput
      | OrderUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | OrderUpdateManyWithWhereWithoutUserInput
      | OrderUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[];
  };

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    upsert?:
      | AccountUpsertWithWhereUniqueWithoutUserInput
      | AccountUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    update?:
      | AccountUpdateWithWhereUniqueWithoutUserInput
      | AccountUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AccountUpdateManyWithWhereWithoutUserInput
      | AccountUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[];
  };

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
      | AuditLogCreateWithoutUserInput[]
      | AuditLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutUserInput
      | AuditLogCreateOrConnectWithoutUserInput[];
    upsert?:
      | AuditLogUpsertWithWhereUniqueWithoutUserInput
      | AuditLogUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AuditLogCreateManyUserInputEnvelope;
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    update?:
      | AuditLogUpdateWithWhereUniqueWithoutUserInput
      | AuditLogUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AuditLogUpdateManyWithWhereWithoutUserInput
      | AuditLogUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
  };

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    upsert?:
      | SessionUpsertWithWhereUniqueWithoutUserInput
      | SessionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    update?:
      | SessionUpdateWithWhereUniqueWithoutUserInput
      | SessionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | SessionUpdateManyWithWhereWithoutUserInput
      | SessionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[];
  };

  export type FormSerialUncheckedUpdateManyWithoutAddedByAdminNestedInput = {
    create?:
      | XOR<
          FormSerialCreateWithoutAddedByAdminInput,
          FormSerialUncheckedCreateWithoutAddedByAdminInput
        >
      | FormSerialCreateWithoutAddedByAdminInput[]
      | FormSerialUncheckedCreateWithoutAddedByAdminInput[];
    connectOrCreate?:
      | FormSerialCreateOrConnectWithoutAddedByAdminInput
      | FormSerialCreateOrConnectWithoutAddedByAdminInput[];
    upsert?:
      | FormSerialUpsertWithWhereUniqueWithoutAddedByAdminInput
      | FormSerialUpsertWithWhereUniqueWithoutAddedByAdminInput[];
    createMany?: FormSerialCreateManyAddedByAdminInputEnvelope;
    set?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
    disconnect?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
    delete?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
    connect?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
    update?:
      | FormSerialUpdateWithWhereUniqueWithoutAddedByAdminInput
      | FormSerialUpdateWithWhereUniqueWithoutAddedByAdminInput[];
    updateMany?:
      | FormSerialUpdateManyWithWhereWithoutAddedByAdminInput
      | FormSerialUpdateManyWithWhereWithoutAddedByAdminInput[];
    deleteMany?: FormSerialScalarWhereInput | FormSerialScalarWhereInput[];
  };

  export type FormSerialUncheckedUpdateManyWithoutConsumedByAdminNestedInput = {
    create?:
      | XOR<
          FormSerialCreateWithoutConsumedByAdminInput,
          FormSerialUncheckedCreateWithoutConsumedByAdminInput
        >
      | FormSerialCreateWithoutConsumedByAdminInput[]
      | FormSerialUncheckedCreateWithoutConsumedByAdminInput[];
    connectOrCreate?:
      | FormSerialCreateOrConnectWithoutConsumedByAdminInput
      | FormSerialCreateOrConnectWithoutConsumedByAdminInput[];
    upsert?:
      | FormSerialUpsertWithWhereUniqueWithoutConsumedByAdminInput
      | FormSerialUpsertWithWhereUniqueWithoutConsumedByAdminInput[];
    createMany?: FormSerialCreateManyConsumedByAdminInputEnvelope;
    set?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
    disconnect?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
    delete?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
    connect?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
    update?:
      | FormSerialUpdateWithWhereUniqueWithoutConsumedByAdminInput
      | FormSerialUpdateWithWhereUniqueWithoutConsumedByAdminInput[];
    updateMany?:
      | FormSerialUpdateManyWithWhereWithoutConsumedByAdminInput
      | FormSerialUpdateManyWithWhereWithoutConsumedByAdminInput[];
    deleteMany?: FormSerialScalarWhereInput | FormSerialScalarWhereInput[];
  };

  export type DependentUncheckedUpdateManyWithoutCreatedByAdminNestedInput = {
    create?:
      | XOR<
          DependentCreateWithoutCreatedByAdminInput,
          DependentUncheckedCreateWithoutCreatedByAdminInput
        >
      | DependentCreateWithoutCreatedByAdminInput[]
      | DependentUncheckedCreateWithoutCreatedByAdminInput[];
    connectOrCreate?:
      | DependentCreateOrConnectWithoutCreatedByAdminInput
      | DependentCreateOrConnectWithoutCreatedByAdminInput[];
    upsert?:
      | DependentUpsertWithWhereUniqueWithoutCreatedByAdminInput
      | DependentUpsertWithWhereUniqueWithoutCreatedByAdminInput[];
    createMany?: DependentCreateManyCreatedByAdminInputEnvelope;
    set?: DependentWhereUniqueInput | DependentWhereUniqueInput[];
    disconnect?: DependentWhereUniqueInput | DependentWhereUniqueInput[];
    delete?: DependentWhereUniqueInput | DependentWhereUniqueInput[];
    connect?: DependentWhereUniqueInput | DependentWhereUniqueInput[];
    update?:
      | DependentUpdateWithWhereUniqueWithoutCreatedByAdminInput
      | DependentUpdateWithWhereUniqueWithoutCreatedByAdminInput[];
    updateMany?:
      | DependentUpdateManyWithWhereWithoutCreatedByAdminInput
      | DependentUpdateManyWithWhereWithoutCreatedByAdminInput[];
    deleteMany?: DependentScalarWhereInput | DependentScalarWhereInput[];
  };

  export type ServiceCreateNestedManyWithoutCategoryInput = {
    create?:
      | XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput>
      | ServiceCreateWithoutCategoryInput[]
      | ServiceUncheckedCreateWithoutCategoryInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutCategoryInput
      | ServiceCreateOrConnectWithoutCategoryInput[];
    createMany?: ServiceCreateManyCategoryInputEnvelope;
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
  };

  export type ServiceUncheckedCreateNestedManyWithoutCategoryInput = {
    create?:
      | XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput>
      | ServiceCreateWithoutCategoryInput[]
      | ServiceUncheckedCreateWithoutCategoryInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutCategoryInput
      | ServiceCreateOrConnectWithoutCategoryInput[];
    createMany?: ServiceCreateManyCategoryInputEnvelope;
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
  };

  export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean;
  };

  export type ServiceUpdateManyWithoutCategoryNestedInput = {
    create?:
      | XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput>
      | ServiceCreateWithoutCategoryInput[]
      | ServiceUncheckedCreateWithoutCategoryInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutCategoryInput
      | ServiceCreateOrConnectWithoutCategoryInput[];
    upsert?:
      | ServiceUpsertWithWhereUniqueWithoutCategoryInput
      | ServiceUpsertWithWhereUniqueWithoutCategoryInput[];
    createMany?: ServiceCreateManyCategoryInputEnvelope;
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    update?:
      | ServiceUpdateWithWhereUniqueWithoutCategoryInput
      | ServiceUpdateWithWhereUniqueWithoutCategoryInput[];
    updateMany?:
      | ServiceUpdateManyWithWhereWithoutCategoryInput
      | ServiceUpdateManyWithWhereWithoutCategoryInput[];
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[];
  };

  export type ServiceUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?:
      | XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput>
      | ServiceCreateWithoutCategoryInput[]
      | ServiceUncheckedCreateWithoutCategoryInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutCategoryInput
      | ServiceCreateOrConnectWithoutCategoryInput[];
    upsert?:
      | ServiceUpsertWithWhereUniqueWithoutCategoryInput
      | ServiceUpsertWithWhereUniqueWithoutCategoryInput[];
    createMany?: ServiceCreateManyCategoryInputEnvelope;
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    update?:
      | ServiceUpdateWithWhereUniqueWithoutCategoryInput
      | ServiceUpdateWithWhereUniqueWithoutCategoryInput[];
    updateMany?:
      | ServiceUpdateManyWithWhereWithoutCategoryInput
      | ServiceUpdateManyWithWhereWithoutCategoryInput[];
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[];
  };

  export type OrderCreateNestedManyWithoutServiceInput = {
    create?:
      | XOR<OrderCreateWithoutServiceInput, OrderUncheckedCreateWithoutServiceInput>
      | OrderCreateWithoutServiceInput[]
      | OrderUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | OrderCreateOrConnectWithoutServiceInput
      | OrderCreateOrConnectWithoutServiceInput[];
    createMany?: OrderCreateManyServiceInputEnvelope;
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
  };

  export type CategoryCreateNestedOneWithoutServicesInput = {
    create?: XOR<CategoryCreateWithoutServicesInput, CategoryUncheckedCreateWithoutServicesInput>;
    connectOrCreate?: CategoryCreateOrConnectWithoutServicesInput;
    connect?: CategoryWhereUniqueInput;
  };

  export type ServiceDocumentCreateNestedManyWithoutServiceInput = {
    create?:
      | XOR<
          ServiceDocumentCreateWithoutServiceInput,
          ServiceDocumentUncheckedCreateWithoutServiceInput
        >
      | ServiceDocumentCreateWithoutServiceInput[]
      | ServiceDocumentUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | ServiceDocumentCreateOrConnectWithoutServiceInput
      | ServiceDocumentCreateOrConnectWithoutServiceInput[];
    createMany?: ServiceDocumentCreateManyServiceInputEnvelope;
    connect?: ServiceDocumentWhereUniqueInput | ServiceDocumentWhereUniqueInput[];
  };

  export type ServiceVariantCreateNestedManyWithoutServiceInput = {
    create?:
      | XOR<
          ServiceVariantCreateWithoutServiceInput,
          ServiceVariantUncheckedCreateWithoutServiceInput
        >
      | ServiceVariantCreateWithoutServiceInput[]
      | ServiceVariantUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | ServiceVariantCreateOrConnectWithoutServiceInput
      | ServiceVariantCreateOrConnectWithoutServiceInput[];
    createMany?: ServiceVariantCreateManyServiceInputEnvelope;
    connect?: ServiceVariantWhereUniqueInput | ServiceVariantWhereUniqueInput[];
  };

  export type ServiceFieldCreateNestedManyWithoutServiceInput = {
    create?:
      | XOR<ServiceFieldCreateWithoutServiceInput, ServiceFieldUncheckedCreateWithoutServiceInput>
      | ServiceFieldCreateWithoutServiceInput[]
      | ServiceFieldUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | ServiceFieldCreateOrConnectWithoutServiceInput
      | ServiceFieldCreateOrConnectWithoutServiceInput[];
    createMany?: ServiceFieldCreateManyServiceInputEnvelope;
    connect?: ServiceFieldWhereUniqueInput | ServiceFieldWhereUniqueInput[];
  };

  export type OrderUncheckedCreateNestedManyWithoutServiceInput = {
    create?:
      | XOR<OrderCreateWithoutServiceInput, OrderUncheckedCreateWithoutServiceInput>
      | OrderCreateWithoutServiceInput[]
      | OrderUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | OrderCreateOrConnectWithoutServiceInput
      | OrderCreateOrConnectWithoutServiceInput[];
    createMany?: OrderCreateManyServiceInputEnvelope;
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
  };

  export type ServiceDocumentUncheckedCreateNestedManyWithoutServiceInput = {
    create?:
      | XOR<
          ServiceDocumentCreateWithoutServiceInput,
          ServiceDocumentUncheckedCreateWithoutServiceInput
        >
      | ServiceDocumentCreateWithoutServiceInput[]
      | ServiceDocumentUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | ServiceDocumentCreateOrConnectWithoutServiceInput
      | ServiceDocumentCreateOrConnectWithoutServiceInput[];
    createMany?: ServiceDocumentCreateManyServiceInputEnvelope;
    connect?: ServiceDocumentWhereUniqueInput | ServiceDocumentWhereUniqueInput[];
  };

  export type ServiceVariantUncheckedCreateNestedManyWithoutServiceInput = {
    create?:
      | XOR<
          ServiceVariantCreateWithoutServiceInput,
          ServiceVariantUncheckedCreateWithoutServiceInput
        >
      | ServiceVariantCreateWithoutServiceInput[]
      | ServiceVariantUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | ServiceVariantCreateOrConnectWithoutServiceInput
      | ServiceVariantCreateOrConnectWithoutServiceInput[];
    createMany?: ServiceVariantCreateManyServiceInputEnvelope;
    connect?: ServiceVariantWhereUniqueInput | ServiceVariantWhereUniqueInput[];
  };

  export type ServiceFieldUncheckedCreateNestedManyWithoutServiceInput = {
    create?:
      | XOR<ServiceFieldCreateWithoutServiceInput, ServiceFieldUncheckedCreateWithoutServiceInput>
      | ServiceFieldCreateWithoutServiceInput[]
      | ServiceFieldUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | ServiceFieldCreateOrConnectWithoutServiceInput
      | ServiceFieldCreateOrConnectWithoutServiceInput[];
    createMany?: ServiceFieldCreateManyServiceInputEnvelope;
    connect?: ServiceFieldWhereUniqueInput | ServiceFieldWhereUniqueInput[];
  };

  export type OrderUpdateManyWithoutServiceNestedInput = {
    create?:
      | XOR<OrderCreateWithoutServiceInput, OrderUncheckedCreateWithoutServiceInput>
      | OrderCreateWithoutServiceInput[]
      | OrderUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | OrderCreateOrConnectWithoutServiceInput
      | OrderCreateOrConnectWithoutServiceInput[];
    upsert?:
      | OrderUpsertWithWhereUniqueWithoutServiceInput
      | OrderUpsertWithWhereUniqueWithoutServiceInput[];
    createMany?: OrderCreateManyServiceInputEnvelope;
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    update?:
      | OrderUpdateWithWhereUniqueWithoutServiceInput
      | OrderUpdateWithWhereUniqueWithoutServiceInput[];
    updateMany?:
      | OrderUpdateManyWithWhereWithoutServiceInput
      | OrderUpdateManyWithWhereWithoutServiceInput[];
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[];
  };

  export type CategoryUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<CategoryCreateWithoutServicesInput, CategoryUncheckedCreateWithoutServicesInput>;
    connectOrCreate?: CategoryCreateOrConnectWithoutServicesInput;
    upsert?: CategoryUpsertWithoutServicesInput;
    connect?: CategoryWhereUniqueInput;
    update?: XOR<
      XOR<CategoryUpdateToOneWithWhereWithoutServicesInput, CategoryUpdateWithoutServicesInput>,
      CategoryUncheckedUpdateWithoutServicesInput
    >;
  };

  export type ServiceDocumentUpdateManyWithoutServiceNestedInput = {
    create?:
      | XOR<
          ServiceDocumentCreateWithoutServiceInput,
          ServiceDocumentUncheckedCreateWithoutServiceInput
        >
      | ServiceDocumentCreateWithoutServiceInput[]
      | ServiceDocumentUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | ServiceDocumentCreateOrConnectWithoutServiceInput
      | ServiceDocumentCreateOrConnectWithoutServiceInput[];
    upsert?:
      | ServiceDocumentUpsertWithWhereUniqueWithoutServiceInput
      | ServiceDocumentUpsertWithWhereUniqueWithoutServiceInput[];
    createMany?: ServiceDocumentCreateManyServiceInputEnvelope;
    set?: ServiceDocumentWhereUniqueInput | ServiceDocumentWhereUniqueInput[];
    disconnect?: ServiceDocumentWhereUniqueInput | ServiceDocumentWhereUniqueInput[];
    delete?: ServiceDocumentWhereUniqueInput | ServiceDocumentWhereUniqueInput[];
    connect?: ServiceDocumentWhereUniqueInput | ServiceDocumentWhereUniqueInput[];
    update?:
      | ServiceDocumentUpdateWithWhereUniqueWithoutServiceInput
      | ServiceDocumentUpdateWithWhereUniqueWithoutServiceInput[];
    updateMany?:
      | ServiceDocumentUpdateManyWithWhereWithoutServiceInput
      | ServiceDocumentUpdateManyWithWhereWithoutServiceInput[];
    deleteMany?: ServiceDocumentScalarWhereInput | ServiceDocumentScalarWhereInput[];
  };

  export type ServiceVariantUpdateManyWithoutServiceNestedInput = {
    create?:
      | XOR<
          ServiceVariantCreateWithoutServiceInput,
          ServiceVariantUncheckedCreateWithoutServiceInput
        >
      | ServiceVariantCreateWithoutServiceInput[]
      | ServiceVariantUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | ServiceVariantCreateOrConnectWithoutServiceInput
      | ServiceVariantCreateOrConnectWithoutServiceInput[];
    upsert?:
      | ServiceVariantUpsertWithWhereUniqueWithoutServiceInput
      | ServiceVariantUpsertWithWhereUniqueWithoutServiceInput[];
    createMany?: ServiceVariantCreateManyServiceInputEnvelope;
    set?: ServiceVariantWhereUniqueInput | ServiceVariantWhereUniqueInput[];
    disconnect?: ServiceVariantWhereUniqueInput | ServiceVariantWhereUniqueInput[];
    delete?: ServiceVariantWhereUniqueInput | ServiceVariantWhereUniqueInput[];
    connect?: ServiceVariantWhereUniqueInput | ServiceVariantWhereUniqueInput[];
    update?:
      | ServiceVariantUpdateWithWhereUniqueWithoutServiceInput
      | ServiceVariantUpdateWithWhereUniqueWithoutServiceInput[];
    updateMany?:
      | ServiceVariantUpdateManyWithWhereWithoutServiceInput
      | ServiceVariantUpdateManyWithWhereWithoutServiceInput[];
    deleteMany?: ServiceVariantScalarWhereInput | ServiceVariantScalarWhereInput[];
  };

  export type ServiceFieldUpdateManyWithoutServiceNestedInput = {
    create?:
      | XOR<ServiceFieldCreateWithoutServiceInput, ServiceFieldUncheckedCreateWithoutServiceInput>
      | ServiceFieldCreateWithoutServiceInput[]
      | ServiceFieldUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | ServiceFieldCreateOrConnectWithoutServiceInput
      | ServiceFieldCreateOrConnectWithoutServiceInput[];
    upsert?:
      | ServiceFieldUpsertWithWhereUniqueWithoutServiceInput
      | ServiceFieldUpsertWithWhereUniqueWithoutServiceInput[];
    createMany?: ServiceFieldCreateManyServiceInputEnvelope;
    set?: ServiceFieldWhereUniqueInput | ServiceFieldWhereUniqueInput[];
    disconnect?: ServiceFieldWhereUniqueInput | ServiceFieldWhereUniqueInput[];
    delete?: ServiceFieldWhereUniqueInput | ServiceFieldWhereUniqueInput[];
    connect?: ServiceFieldWhereUniqueInput | ServiceFieldWhereUniqueInput[];
    update?:
      | ServiceFieldUpdateWithWhereUniqueWithoutServiceInput
      | ServiceFieldUpdateWithWhereUniqueWithoutServiceInput[];
    updateMany?:
      | ServiceFieldUpdateManyWithWhereWithoutServiceInput
      | ServiceFieldUpdateManyWithWhereWithoutServiceInput[];
    deleteMany?: ServiceFieldScalarWhereInput | ServiceFieldScalarWhereInput[];
  };

  export type OrderUncheckedUpdateManyWithoutServiceNestedInput = {
    create?:
      | XOR<OrderCreateWithoutServiceInput, OrderUncheckedCreateWithoutServiceInput>
      | OrderCreateWithoutServiceInput[]
      | OrderUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | OrderCreateOrConnectWithoutServiceInput
      | OrderCreateOrConnectWithoutServiceInput[];
    upsert?:
      | OrderUpsertWithWhereUniqueWithoutServiceInput
      | OrderUpsertWithWhereUniqueWithoutServiceInput[];
    createMany?: OrderCreateManyServiceInputEnvelope;
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    update?:
      | OrderUpdateWithWhereUniqueWithoutServiceInput
      | OrderUpdateWithWhereUniqueWithoutServiceInput[];
    updateMany?:
      | OrderUpdateManyWithWhereWithoutServiceInput
      | OrderUpdateManyWithWhereWithoutServiceInput[];
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[];
  };

  export type ServiceDocumentUncheckedUpdateManyWithoutServiceNestedInput = {
    create?:
      | XOR<
          ServiceDocumentCreateWithoutServiceInput,
          ServiceDocumentUncheckedCreateWithoutServiceInput
        >
      | ServiceDocumentCreateWithoutServiceInput[]
      | ServiceDocumentUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | ServiceDocumentCreateOrConnectWithoutServiceInput
      | ServiceDocumentCreateOrConnectWithoutServiceInput[];
    upsert?:
      | ServiceDocumentUpsertWithWhereUniqueWithoutServiceInput
      | ServiceDocumentUpsertWithWhereUniqueWithoutServiceInput[];
    createMany?: ServiceDocumentCreateManyServiceInputEnvelope;
    set?: ServiceDocumentWhereUniqueInput | ServiceDocumentWhereUniqueInput[];
    disconnect?: ServiceDocumentWhereUniqueInput | ServiceDocumentWhereUniqueInput[];
    delete?: ServiceDocumentWhereUniqueInput | ServiceDocumentWhereUniqueInput[];
    connect?: ServiceDocumentWhereUniqueInput | ServiceDocumentWhereUniqueInput[];
    update?:
      | ServiceDocumentUpdateWithWhereUniqueWithoutServiceInput
      | ServiceDocumentUpdateWithWhereUniqueWithoutServiceInput[];
    updateMany?:
      | ServiceDocumentUpdateManyWithWhereWithoutServiceInput
      | ServiceDocumentUpdateManyWithWhereWithoutServiceInput[];
    deleteMany?: ServiceDocumentScalarWhereInput | ServiceDocumentScalarWhereInput[];
  };

  export type ServiceVariantUncheckedUpdateManyWithoutServiceNestedInput = {
    create?:
      | XOR<
          ServiceVariantCreateWithoutServiceInput,
          ServiceVariantUncheckedCreateWithoutServiceInput
        >
      | ServiceVariantCreateWithoutServiceInput[]
      | ServiceVariantUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | ServiceVariantCreateOrConnectWithoutServiceInput
      | ServiceVariantCreateOrConnectWithoutServiceInput[];
    upsert?:
      | ServiceVariantUpsertWithWhereUniqueWithoutServiceInput
      | ServiceVariantUpsertWithWhereUniqueWithoutServiceInput[];
    createMany?: ServiceVariantCreateManyServiceInputEnvelope;
    set?: ServiceVariantWhereUniqueInput | ServiceVariantWhereUniqueInput[];
    disconnect?: ServiceVariantWhereUniqueInput | ServiceVariantWhereUniqueInput[];
    delete?: ServiceVariantWhereUniqueInput | ServiceVariantWhereUniqueInput[];
    connect?: ServiceVariantWhereUniqueInput | ServiceVariantWhereUniqueInput[];
    update?:
      | ServiceVariantUpdateWithWhereUniqueWithoutServiceInput
      | ServiceVariantUpdateWithWhereUniqueWithoutServiceInput[];
    updateMany?:
      | ServiceVariantUpdateManyWithWhereWithoutServiceInput
      | ServiceVariantUpdateManyWithWhereWithoutServiceInput[];
    deleteMany?: ServiceVariantScalarWhereInput | ServiceVariantScalarWhereInput[];
  };

  export type ServiceFieldUncheckedUpdateManyWithoutServiceNestedInput = {
    create?:
      | XOR<ServiceFieldCreateWithoutServiceInput, ServiceFieldUncheckedCreateWithoutServiceInput>
      | ServiceFieldCreateWithoutServiceInput[]
      | ServiceFieldUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | ServiceFieldCreateOrConnectWithoutServiceInput
      | ServiceFieldCreateOrConnectWithoutServiceInput[];
    upsert?:
      | ServiceFieldUpsertWithWhereUniqueWithoutServiceInput
      | ServiceFieldUpsertWithWhereUniqueWithoutServiceInput[];
    createMany?: ServiceFieldCreateManyServiceInputEnvelope;
    set?: ServiceFieldWhereUniqueInput | ServiceFieldWhereUniqueInput[];
    disconnect?: ServiceFieldWhereUniqueInput | ServiceFieldWhereUniqueInput[];
    delete?: ServiceFieldWhereUniqueInput | ServiceFieldWhereUniqueInput[];
    connect?: ServiceFieldWhereUniqueInput | ServiceFieldWhereUniqueInput[];
    update?:
      | ServiceFieldUpdateWithWhereUniqueWithoutServiceInput
      | ServiceFieldUpdateWithWhereUniqueWithoutServiceInput[];
    updateMany?:
      | ServiceFieldUpdateManyWithWhereWithoutServiceInput
      | ServiceFieldUpdateManyWithWhereWithoutServiceInput[];
    deleteMany?: ServiceFieldScalarWhereInput | ServiceFieldScalarWhereInput[];
  };

  export type ServiceCreateNestedOneWithoutFieldsInput = {
    create?: XOR<ServiceCreateWithoutFieldsInput, ServiceUncheckedCreateWithoutFieldsInput>;
    connectOrCreate?: ServiceCreateOrConnectWithoutFieldsInput;
    connect?: ServiceWhereUniqueInput;
  };

  export type ServiceFieldOptionCreateNestedManyWithoutFieldInput = {
    create?:
      | XOR<
          ServiceFieldOptionCreateWithoutFieldInput,
          ServiceFieldOptionUncheckedCreateWithoutFieldInput
        >
      | ServiceFieldOptionCreateWithoutFieldInput[]
      | ServiceFieldOptionUncheckedCreateWithoutFieldInput[];
    connectOrCreate?:
      | ServiceFieldOptionCreateOrConnectWithoutFieldInput
      | ServiceFieldOptionCreateOrConnectWithoutFieldInput[];
    createMany?: ServiceFieldOptionCreateManyFieldInputEnvelope;
    connect?: ServiceFieldOptionWhereUniqueInput | ServiceFieldOptionWhereUniqueInput[];
  };

  export type ServiceFieldOptionUncheckedCreateNestedManyWithoutFieldInput = {
    create?:
      | XOR<
          ServiceFieldOptionCreateWithoutFieldInput,
          ServiceFieldOptionUncheckedCreateWithoutFieldInput
        >
      | ServiceFieldOptionCreateWithoutFieldInput[]
      | ServiceFieldOptionUncheckedCreateWithoutFieldInput[];
    connectOrCreate?:
      | ServiceFieldOptionCreateOrConnectWithoutFieldInput
      | ServiceFieldOptionCreateOrConnectWithoutFieldInput[];
    createMany?: ServiceFieldOptionCreateManyFieldInputEnvelope;
    connect?: ServiceFieldOptionWhereUniqueInput | ServiceFieldOptionWhereUniqueInput[];
  };

  export type ServiceUpdateOneRequiredWithoutFieldsNestedInput = {
    create?: XOR<ServiceCreateWithoutFieldsInput, ServiceUncheckedCreateWithoutFieldsInput>;
    connectOrCreate?: ServiceCreateOrConnectWithoutFieldsInput;
    upsert?: ServiceUpsertWithoutFieldsInput;
    connect?: ServiceWhereUniqueInput;
    update?: XOR<
      XOR<ServiceUpdateToOneWithWhereWithoutFieldsInput, ServiceUpdateWithoutFieldsInput>,
      ServiceUncheckedUpdateWithoutFieldsInput
    >;
  };

  export type ServiceFieldOptionUpdateManyWithoutFieldNestedInput = {
    create?:
      | XOR<
          ServiceFieldOptionCreateWithoutFieldInput,
          ServiceFieldOptionUncheckedCreateWithoutFieldInput
        >
      | ServiceFieldOptionCreateWithoutFieldInput[]
      | ServiceFieldOptionUncheckedCreateWithoutFieldInput[];
    connectOrCreate?:
      | ServiceFieldOptionCreateOrConnectWithoutFieldInput
      | ServiceFieldOptionCreateOrConnectWithoutFieldInput[];
    upsert?:
      | ServiceFieldOptionUpsertWithWhereUniqueWithoutFieldInput
      | ServiceFieldOptionUpsertWithWhereUniqueWithoutFieldInput[];
    createMany?: ServiceFieldOptionCreateManyFieldInputEnvelope;
    set?: ServiceFieldOptionWhereUniqueInput | ServiceFieldOptionWhereUniqueInput[];
    disconnect?: ServiceFieldOptionWhereUniqueInput | ServiceFieldOptionWhereUniqueInput[];
    delete?: ServiceFieldOptionWhereUniqueInput | ServiceFieldOptionWhereUniqueInput[];
    connect?: ServiceFieldOptionWhereUniqueInput | ServiceFieldOptionWhereUniqueInput[];
    update?:
      | ServiceFieldOptionUpdateWithWhereUniqueWithoutFieldInput
      | ServiceFieldOptionUpdateWithWhereUniqueWithoutFieldInput[];
    updateMany?:
      | ServiceFieldOptionUpdateManyWithWhereWithoutFieldInput
      | ServiceFieldOptionUpdateManyWithWhereWithoutFieldInput[];
    deleteMany?: ServiceFieldOptionScalarWhereInput | ServiceFieldOptionScalarWhereInput[];
  };

  export type ServiceFieldOptionUncheckedUpdateManyWithoutFieldNestedInput = {
    create?:
      | XOR<
          ServiceFieldOptionCreateWithoutFieldInput,
          ServiceFieldOptionUncheckedCreateWithoutFieldInput
        >
      | ServiceFieldOptionCreateWithoutFieldInput[]
      | ServiceFieldOptionUncheckedCreateWithoutFieldInput[];
    connectOrCreate?:
      | ServiceFieldOptionCreateOrConnectWithoutFieldInput
      | ServiceFieldOptionCreateOrConnectWithoutFieldInput[];
    upsert?:
      | ServiceFieldOptionUpsertWithWhereUniqueWithoutFieldInput
      | ServiceFieldOptionUpsertWithWhereUniqueWithoutFieldInput[];
    createMany?: ServiceFieldOptionCreateManyFieldInputEnvelope;
    set?: ServiceFieldOptionWhereUniqueInput | ServiceFieldOptionWhereUniqueInput[];
    disconnect?: ServiceFieldOptionWhereUniqueInput | ServiceFieldOptionWhereUniqueInput[];
    delete?: ServiceFieldOptionWhereUniqueInput | ServiceFieldOptionWhereUniqueInput[];
    connect?: ServiceFieldOptionWhereUniqueInput | ServiceFieldOptionWhereUniqueInput[];
    update?:
      | ServiceFieldOptionUpdateWithWhereUniqueWithoutFieldInput
      | ServiceFieldOptionUpdateWithWhereUniqueWithoutFieldInput[];
    updateMany?:
      | ServiceFieldOptionUpdateManyWithWhereWithoutFieldInput
      | ServiceFieldOptionUpdateManyWithWhereWithoutFieldInput[];
    deleteMany?: ServiceFieldOptionScalarWhereInput | ServiceFieldOptionScalarWhereInput[];
  };

  export type ServiceFieldCreateNestedOneWithoutOptionsInput = {
    create?: XOR<
      ServiceFieldCreateWithoutOptionsInput,
      ServiceFieldUncheckedCreateWithoutOptionsInput
    >;
    connectOrCreate?: ServiceFieldCreateOrConnectWithoutOptionsInput;
    connect?: ServiceFieldWhereUniqueInput;
  };

  export type ServiceFieldUpdateOneRequiredWithoutOptionsNestedInput = {
    create?: XOR<
      ServiceFieldCreateWithoutOptionsInput,
      ServiceFieldUncheckedCreateWithoutOptionsInput
    >;
    connectOrCreate?: ServiceFieldCreateOrConnectWithoutOptionsInput;
    upsert?: ServiceFieldUpsertWithoutOptionsInput;
    connect?: ServiceFieldWhereUniqueInput;
    update?: XOR<
      XOR<
        ServiceFieldUpdateToOneWithWhereWithoutOptionsInput,
        ServiceFieldUpdateWithoutOptionsInput
      >,
      ServiceFieldUncheckedUpdateWithoutOptionsInput
    >;
  };

  export type OrderCreateNestedManyWithoutVariantInput = {
    create?:
      | XOR<OrderCreateWithoutVariantInput, OrderUncheckedCreateWithoutVariantInput>
      | OrderCreateWithoutVariantInput[]
      | OrderUncheckedCreateWithoutVariantInput[];
    connectOrCreate?:
      | OrderCreateOrConnectWithoutVariantInput
      | OrderCreateOrConnectWithoutVariantInput[];
    createMany?: OrderCreateManyVariantInputEnvelope;
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
  };

  export type ServiceCreateNestedOneWithoutVariantsInput = {
    create?: XOR<ServiceCreateWithoutVariantsInput, ServiceUncheckedCreateWithoutVariantsInput>;
    connectOrCreate?: ServiceCreateOrConnectWithoutVariantsInput;
    connect?: ServiceWhereUniqueInput;
  };

  export type FormTypeVariantCreateNestedManyWithoutServiceVariantInput = {
    create?:
      | XOR<
          FormTypeVariantCreateWithoutServiceVariantInput,
          FormTypeVariantUncheckedCreateWithoutServiceVariantInput
        >
      | FormTypeVariantCreateWithoutServiceVariantInput[]
      | FormTypeVariantUncheckedCreateWithoutServiceVariantInput[];
    connectOrCreate?:
      | FormTypeVariantCreateOrConnectWithoutServiceVariantInput
      | FormTypeVariantCreateOrConnectWithoutServiceVariantInput[];
    createMany?: FormTypeVariantCreateManyServiceVariantInputEnvelope;
    connect?: FormTypeVariantWhereUniqueInput | FormTypeVariantWhereUniqueInput[];
  };

  export type OrderUncheckedCreateNestedManyWithoutVariantInput = {
    create?:
      | XOR<OrderCreateWithoutVariantInput, OrderUncheckedCreateWithoutVariantInput>
      | OrderCreateWithoutVariantInput[]
      | OrderUncheckedCreateWithoutVariantInput[];
    connectOrCreate?:
      | OrderCreateOrConnectWithoutVariantInput
      | OrderCreateOrConnectWithoutVariantInput[];
    createMany?: OrderCreateManyVariantInputEnvelope;
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
  };

  export type FormTypeVariantUncheckedCreateNestedManyWithoutServiceVariantInput = {
    create?:
      | XOR<
          FormTypeVariantCreateWithoutServiceVariantInput,
          FormTypeVariantUncheckedCreateWithoutServiceVariantInput
        >
      | FormTypeVariantCreateWithoutServiceVariantInput[]
      | FormTypeVariantUncheckedCreateWithoutServiceVariantInput[];
    connectOrCreate?:
      | FormTypeVariantCreateOrConnectWithoutServiceVariantInput
      | FormTypeVariantCreateOrConnectWithoutServiceVariantInput[];
    createMany?: FormTypeVariantCreateManyServiceVariantInputEnvelope;
    connect?: FormTypeVariantWhereUniqueInput | FormTypeVariantWhereUniqueInput[];
  };

  export type OrderUpdateManyWithoutVariantNestedInput = {
    create?:
      | XOR<OrderCreateWithoutVariantInput, OrderUncheckedCreateWithoutVariantInput>
      | OrderCreateWithoutVariantInput[]
      | OrderUncheckedCreateWithoutVariantInput[];
    connectOrCreate?:
      | OrderCreateOrConnectWithoutVariantInput
      | OrderCreateOrConnectWithoutVariantInput[];
    upsert?:
      | OrderUpsertWithWhereUniqueWithoutVariantInput
      | OrderUpsertWithWhereUniqueWithoutVariantInput[];
    createMany?: OrderCreateManyVariantInputEnvelope;
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    update?:
      | OrderUpdateWithWhereUniqueWithoutVariantInput
      | OrderUpdateWithWhereUniqueWithoutVariantInput[];
    updateMany?:
      | OrderUpdateManyWithWhereWithoutVariantInput
      | OrderUpdateManyWithWhereWithoutVariantInput[];
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[];
  };

  export type ServiceUpdateOneRequiredWithoutVariantsNestedInput = {
    create?: XOR<ServiceCreateWithoutVariantsInput, ServiceUncheckedCreateWithoutVariantsInput>;
    connectOrCreate?: ServiceCreateOrConnectWithoutVariantsInput;
    upsert?: ServiceUpsertWithoutVariantsInput;
    connect?: ServiceWhereUniqueInput;
    update?: XOR<
      XOR<ServiceUpdateToOneWithWhereWithoutVariantsInput, ServiceUpdateWithoutVariantsInput>,
      ServiceUncheckedUpdateWithoutVariantsInput
    >;
  };

  export type FormTypeVariantUpdateManyWithoutServiceVariantNestedInput = {
    create?:
      | XOR<
          FormTypeVariantCreateWithoutServiceVariantInput,
          FormTypeVariantUncheckedCreateWithoutServiceVariantInput
        >
      | FormTypeVariantCreateWithoutServiceVariantInput[]
      | FormTypeVariantUncheckedCreateWithoutServiceVariantInput[];
    connectOrCreate?:
      | FormTypeVariantCreateOrConnectWithoutServiceVariantInput
      | FormTypeVariantCreateOrConnectWithoutServiceVariantInput[];
    upsert?:
      | FormTypeVariantUpsertWithWhereUniqueWithoutServiceVariantInput
      | FormTypeVariantUpsertWithWhereUniqueWithoutServiceVariantInput[];
    createMany?: FormTypeVariantCreateManyServiceVariantInputEnvelope;
    set?: FormTypeVariantWhereUniqueInput | FormTypeVariantWhereUniqueInput[];
    disconnect?: FormTypeVariantWhereUniqueInput | FormTypeVariantWhereUniqueInput[];
    delete?: FormTypeVariantWhereUniqueInput | FormTypeVariantWhereUniqueInput[];
    connect?: FormTypeVariantWhereUniqueInput | FormTypeVariantWhereUniqueInput[];
    update?:
      | FormTypeVariantUpdateWithWhereUniqueWithoutServiceVariantInput
      | FormTypeVariantUpdateWithWhereUniqueWithoutServiceVariantInput[];
    updateMany?:
      | FormTypeVariantUpdateManyWithWhereWithoutServiceVariantInput
      | FormTypeVariantUpdateManyWithWhereWithoutServiceVariantInput[];
    deleteMany?: FormTypeVariantScalarWhereInput | FormTypeVariantScalarWhereInput[];
  };

  export type OrderUncheckedUpdateManyWithoutVariantNestedInput = {
    create?:
      | XOR<OrderCreateWithoutVariantInput, OrderUncheckedCreateWithoutVariantInput>
      | OrderCreateWithoutVariantInput[]
      | OrderUncheckedCreateWithoutVariantInput[];
    connectOrCreate?:
      | OrderCreateOrConnectWithoutVariantInput
      | OrderCreateOrConnectWithoutVariantInput[];
    upsert?:
      | OrderUpsertWithWhereUniqueWithoutVariantInput
      | OrderUpsertWithWhereUniqueWithoutVariantInput[];
    createMany?: OrderCreateManyVariantInputEnvelope;
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    update?:
      | OrderUpdateWithWhereUniqueWithoutVariantInput
      | OrderUpdateWithWhereUniqueWithoutVariantInput[];
    updateMany?:
      | OrderUpdateManyWithWhereWithoutVariantInput
      | OrderUpdateManyWithWhereWithoutVariantInput[];
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[];
  };

  export type FormTypeVariantUncheckedUpdateManyWithoutServiceVariantNestedInput = {
    create?:
      | XOR<
          FormTypeVariantCreateWithoutServiceVariantInput,
          FormTypeVariantUncheckedCreateWithoutServiceVariantInput
        >
      | FormTypeVariantCreateWithoutServiceVariantInput[]
      | FormTypeVariantUncheckedCreateWithoutServiceVariantInput[];
    connectOrCreate?:
      | FormTypeVariantCreateOrConnectWithoutServiceVariantInput
      | FormTypeVariantCreateOrConnectWithoutServiceVariantInput[];
    upsert?:
      | FormTypeVariantUpsertWithWhereUniqueWithoutServiceVariantInput
      | FormTypeVariantUpsertWithWhereUniqueWithoutServiceVariantInput[];
    createMany?: FormTypeVariantCreateManyServiceVariantInputEnvelope;
    set?: FormTypeVariantWhereUniqueInput | FormTypeVariantWhereUniqueInput[];
    disconnect?: FormTypeVariantWhereUniqueInput | FormTypeVariantWhereUniqueInput[];
    delete?: FormTypeVariantWhereUniqueInput | FormTypeVariantWhereUniqueInput[];
    connect?: FormTypeVariantWhereUniqueInput | FormTypeVariantWhereUniqueInput[];
    update?:
      | FormTypeVariantUpdateWithWhereUniqueWithoutServiceVariantInput
      | FormTypeVariantUpdateWithWhereUniqueWithoutServiceVariantInput[];
    updateMany?:
      | FormTypeVariantUpdateManyWithWhereWithoutServiceVariantInput
      | FormTypeVariantUpdateManyWithWhereWithoutServiceVariantInput[];
    deleteMany?: FormTypeVariantScalarWhereInput | FormTypeVariantScalarWhereInput[];
  };

  export type UserCreateNestedOneWithoutCreatedOrdersInput = {
    create?: XOR<UserCreateWithoutCreatedOrdersInput, UserUncheckedCreateWithoutCreatedOrdersInput>;
    connectOrCreate?: UserCreateOrConnectWithoutCreatedOrdersInput;
    connect?: UserWhereUniqueInput;
  };

  export type DocumentCreateNestedManyWithoutOrderInput = {
    create?:
      | XOR<DocumentCreateWithoutOrderInput, DocumentUncheckedCreateWithoutOrderInput>
      | DocumentCreateWithoutOrderInput[]
      | DocumentUncheckedCreateWithoutOrderInput[];
    connectOrCreate?:
      | DocumentCreateOrConnectWithoutOrderInput
      | DocumentCreateOrConnectWithoutOrderInput[];
    createMany?: DocumentCreateManyOrderInputEnvelope;
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
  };

  export type ServiceCreateNestedOneWithoutOrdersInput = {
    create?: XOR<ServiceCreateWithoutOrdersInput, ServiceUncheckedCreateWithoutOrdersInput>;
    connectOrCreate?: ServiceCreateOrConnectWithoutOrdersInput;
    connect?: ServiceWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>;
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput;
    connect?: UserWhereUniqueInput;
  };

  export type ServiceVariantCreateNestedOneWithoutOrdersInput = {
    create?: XOR<
      ServiceVariantCreateWithoutOrdersInput,
      ServiceVariantUncheckedCreateWithoutOrdersInput
    >;
    connectOrCreate?: ServiceVariantCreateOrConnectWithoutOrdersInput;
    connect?: ServiceVariantWhereUniqueInput;
  };

  export type OrderDocumentCreateNestedManyWithoutOrderInput = {
    create?:
      | XOR<OrderDocumentCreateWithoutOrderInput, OrderDocumentUncheckedCreateWithoutOrderInput>
      | OrderDocumentCreateWithoutOrderInput[]
      | OrderDocumentUncheckedCreateWithoutOrderInput[];
    connectOrCreate?:
      | OrderDocumentCreateOrConnectWithoutOrderInput
      | OrderDocumentCreateOrConnectWithoutOrderInput[];
    createMany?: OrderDocumentCreateManyOrderInputEnvelope;
    connect?: OrderDocumentWhereUniqueInput | OrderDocumentWhereUniqueInput[];
  };

  export type PaymentCreateNestedOneWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>;
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput;
    connect?: PaymentWhereUniqueInput;
  };

  export type FormSerialCreateNestedManyWithoutOrderInput = {
    create?:
      | XOR<FormSerialCreateWithoutOrderInput, FormSerialUncheckedCreateWithoutOrderInput>
      | FormSerialCreateWithoutOrderInput[]
      | FormSerialUncheckedCreateWithoutOrderInput[];
    connectOrCreate?:
      | FormSerialCreateOrConnectWithoutOrderInput
      | FormSerialCreateOrConnectWithoutOrderInput[];
    createMany?: FormSerialCreateManyOrderInputEnvelope;
    connect?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
  };

  export type PromoCodeCreateNestedOneWithoutOrdersInput = {
    create?: XOR<PromoCodeCreateWithoutOrdersInput, PromoCodeUncheckedCreateWithoutOrdersInput>;
    connectOrCreate?: PromoCodeCreateOrConnectWithoutOrdersInput;
    connect?: PromoCodeWhereUniqueInput;
  };

  export type DocumentUncheckedCreateNestedManyWithoutOrderInput = {
    create?:
      | XOR<DocumentCreateWithoutOrderInput, DocumentUncheckedCreateWithoutOrderInput>
      | DocumentCreateWithoutOrderInput[]
      | DocumentUncheckedCreateWithoutOrderInput[];
    connectOrCreate?:
      | DocumentCreateOrConnectWithoutOrderInput
      | DocumentCreateOrConnectWithoutOrderInput[];
    createMany?: DocumentCreateManyOrderInputEnvelope;
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
  };

  export type OrderDocumentUncheckedCreateNestedManyWithoutOrderInput = {
    create?:
      | XOR<OrderDocumentCreateWithoutOrderInput, OrderDocumentUncheckedCreateWithoutOrderInput>
      | OrderDocumentCreateWithoutOrderInput[]
      | OrderDocumentUncheckedCreateWithoutOrderInput[];
    connectOrCreate?:
      | OrderDocumentCreateOrConnectWithoutOrderInput
      | OrderDocumentCreateOrConnectWithoutOrderInput[];
    createMany?: OrderDocumentCreateManyOrderInputEnvelope;
    connect?: OrderDocumentWhereUniqueInput | OrderDocumentWhereUniqueInput[];
  };

  export type PaymentUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>;
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput;
    connect?: PaymentWhereUniqueInput;
  };

  export type FormSerialUncheckedCreateNestedManyWithoutOrderInput = {
    create?:
      | XOR<FormSerialCreateWithoutOrderInput, FormSerialUncheckedCreateWithoutOrderInput>
      | FormSerialCreateWithoutOrderInput[]
      | FormSerialUncheckedCreateWithoutOrderInput[];
    connectOrCreate?:
      | FormSerialCreateOrConnectWithoutOrderInput
      | FormSerialCreateOrConnectWithoutOrderInput[];
    createMany?: FormSerialCreateManyOrderInputEnvelope;
    connect?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
  };

  export type UserUpdateOneWithoutCreatedOrdersNestedInput = {
    create?: XOR<UserCreateWithoutCreatedOrdersInput, UserUncheckedCreateWithoutCreatedOrdersInput>;
    connectOrCreate?: UserCreateOrConnectWithoutCreatedOrdersInput;
    upsert?: UserUpsertWithoutCreatedOrdersInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutCreatedOrdersInput, UserUpdateWithoutCreatedOrdersInput>,
      UserUncheckedUpdateWithoutCreatedOrdersInput
    >;
  };

  export type DocumentUpdateManyWithoutOrderNestedInput = {
    create?:
      | XOR<DocumentCreateWithoutOrderInput, DocumentUncheckedCreateWithoutOrderInput>
      | DocumentCreateWithoutOrderInput[]
      | DocumentUncheckedCreateWithoutOrderInput[];
    connectOrCreate?:
      | DocumentCreateOrConnectWithoutOrderInput
      | DocumentCreateOrConnectWithoutOrderInput[];
    upsert?:
      | DocumentUpsertWithWhereUniqueWithoutOrderInput
      | DocumentUpsertWithWhereUniqueWithoutOrderInput[];
    createMany?: DocumentCreateManyOrderInputEnvelope;
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    update?:
      | DocumentUpdateWithWhereUniqueWithoutOrderInput
      | DocumentUpdateWithWhereUniqueWithoutOrderInput[];
    updateMany?:
      | DocumentUpdateManyWithWhereWithoutOrderInput
      | DocumentUpdateManyWithWhereWithoutOrderInput[];
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[];
  };

  export type ServiceUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<ServiceCreateWithoutOrdersInput, ServiceUncheckedCreateWithoutOrdersInput>;
    connectOrCreate?: ServiceCreateOrConnectWithoutOrdersInput;
    upsert?: ServiceUpsertWithoutOrdersInput;
    connect?: ServiceWhereUniqueInput;
    update?: XOR<
      XOR<ServiceUpdateToOneWithWhereWithoutOrdersInput, ServiceUpdateWithoutOrdersInput>,
      ServiceUncheckedUpdateWithoutOrdersInput
    >;
  };

  export type UserUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>;
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput;
    upsert?: UserUpsertWithoutOrdersInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutOrdersInput, UserUpdateWithoutOrdersInput>,
      UserUncheckedUpdateWithoutOrdersInput
    >;
  };

  export type ServiceVariantUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<
      ServiceVariantCreateWithoutOrdersInput,
      ServiceVariantUncheckedCreateWithoutOrdersInput
    >;
    connectOrCreate?: ServiceVariantCreateOrConnectWithoutOrdersInput;
    upsert?: ServiceVariantUpsertWithoutOrdersInput;
    connect?: ServiceVariantWhereUniqueInput;
    update?: XOR<
      XOR<
        ServiceVariantUpdateToOneWithWhereWithoutOrdersInput,
        ServiceVariantUpdateWithoutOrdersInput
      >,
      ServiceVariantUncheckedUpdateWithoutOrdersInput
    >;
  };

  export type OrderDocumentUpdateManyWithoutOrderNestedInput = {
    create?:
      | XOR<OrderDocumentCreateWithoutOrderInput, OrderDocumentUncheckedCreateWithoutOrderInput>
      | OrderDocumentCreateWithoutOrderInput[]
      | OrderDocumentUncheckedCreateWithoutOrderInput[];
    connectOrCreate?:
      | OrderDocumentCreateOrConnectWithoutOrderInput
      | OrderDocumentCreateOrConnectWithoutOrderInput[];
    upsert?:
      | OrderDocumentUpsertWithWhereUniqueWithoutOrderInput
      | OrderDocumentUpsertWithWhereUniqueWithoutOrderInput[];
    createMany?: OrderDocumentCreateManyOrderInputEnvelope;
    set?: OrderDocumentWhereUniqueInput | OrderDocumentWhereUniqueInput[];
    disconnect?: OrderDocumentWhereUniqueInput | OrderDocumentWhereUniqueInput[];
    delete?: OrderDocumentWhereUniqueInput | OrderDocumentWhereUniqueInput[];
    connect?: OrderDocumentWhereUniqueInput | OrderDocumentWhereUniqueInput[];
    update?:
      | OrderDocumentUpdateWithWhereUniqueWithoutOrderInput
      | OrderDocumentUpdateWithWhereUniqueWithoutOrderInput[];
    updateMany?:
      | OrderDocumentUpdateManyWithWhereWithoutOrderInput
      | OrderDocumentUpdateManyWithWhereWithoutOrderInput[];
    deleteMany?: OrderDocumentScalarWhereInput | OrderDocumentScalarWhereInput[];
  };

  export type PaymentUpdateOneWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>;
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput;
    upsert?: PaymentUpsertWithoutOrderInput;
    disconnect?: PaymentWhereInput | boolean;
    delete?: PaymentWhereInput | boolean;
    connect?: PaymentWhereUniqueInput;
    update?: XOR<
      XOR<PaymentUpdateToOneWithWhereWithoutOrderInput, PaymentUpdateWithoutOrderInput>,
      PaymentUncheckedUpdateWithoutOrderInput
    >;
  };

  export type FormSerialUpdateManyWithoutOrderNestedInput = {
    create?:
      | XOR<FormSerialCreateWithoutOrderInput, FormSerialUncheckedCreateWithoutOrderInput>
      | FormSerialCreateWithoutOrderInput[]
      | FormSerialUncheckedCreateWithoutOrderInput[];
    connectOrCreate?:
      | FormSerialCreateOrConnectWithoutOrderInput
      | FormSerialCreateOrConnectWithoutOrderInput[];
    upsert?:
      | FormSerialUpsertWithWhereUniqueWithoutOrderInput
      | FormSerialUpsertWithWhereUniqueWithoutOrderInput[];
    createMany?: FormSerialCreateManyOrderInputEnvelope;
    set?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
    disconnect?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
    delete?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
    connect?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
    update?:
      | FormSerialUpdateWithWhereUniqueWithoutOrderInput
      | FormSerialUpdateWithWhereUniqueWithoutOrderInput[];
    updateMany?:
      | FormSerialUpdateManyWithWhereWithoutOrderInput
      | FormSerialUpdateManyWithWhereWithoutOrderInput[];
    deleteMany?: FormSerialScalarWhereInput | FormSerialScalarWhereInput[];
  };

  export type PromoCodeUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<PromoCodeCreateWithoutOrdersInput, PromoCodeUncheckedCreateWithoutOrdersInput>;
    connectOrCreate?: PromoCodeCreateOrConnectWithoutOrdersInput;
    upsert?: PromoCodeUpsertWithoutOrdersInput;
    disconnect?: PromoCodeWhereInput | boolean;
    delete?: PromoCodeWhereInput | boolean;
    connect?: PromoCodeWhereUniqueInput;
    update?: XOR<
      XOR<PromoCodeUpdateToOneWithWhereWithoutOrdersInput, PromoCodeUpdateWithoutOrdersInput>,
      PromoCodeUncheckedUpdateWithoutOrdersInput
    >;
  };

  export type DocumentUncheckedUpdateManyWithoutOrderNestedInput = {
    create?:
      | XOR<DocumentCreateWithoutOrderInput, DocumentUncheckedCreateWithoutOrderInput>
      | DocumentCreateWithoutOrderInput[]
      | DocumentUncheckedCreateWithoutOrderInput[];
    connectOrCreate?:
      | DocumentCreateOrConnectWithoutOrderInput
      | DocumentCreateOrConnectWithoutOrderInput[];
    upsert?:
      | DocumentUpsertWithWhereUniqueWithoutOrderInput
      | DocumentUpsertWithWhereUniqueWithoutOrderInput[];
    createMany?: DocumentCreateManyOrderInputEnvelope;
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[];
    update?:
      | DocumentUpdateWithWhereUniqueWithoutOrderInput
      | DocumentUpdateWithWhereUniqueWithoutOrderInput[];
    updateMany?:
      | DocumentUpdateManyWithWhereWithoutOrderInput
      | DocumentUpdateManyWithWhereWithoutOrderInput[];
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[];
  };

  export type OrderDocumentUncheckedUpdateManyWithoutOrderNestedInput = {
    create?:
      | XOR<OrderDocumentCreateWithoutOrderInput, OrderDocumentUncheckedCreateWithoutOrderInput>
      | OrderDocumentCreateWithoutOrderInput[]
      | OrderDocumentUncheckedCreateWithoutOrderInput[];
    connectOrCreate?:
      | OrderDocumentCreateOrConnectWithoutOrderInput
      | OrderDocumentCreateOrConnectWithoutOrderInput[];
    upsert?:
      | OrderDocumentUpsertWithWhereUniqueWithoutOrderInput
      | OrderDocumentUpsertWithWhereUniqueWithoutOrderInput[];
    createMany?: OrderDocumentCreateManyOrderInputEnvelope;
    set?: OrderDocumentWhereUniqueInput | OrderDocumentWhereUniqueInput[];
    disconnect?: OrderDocumentWhereUniqueInput | OrderDocumentWhereUniqueInput[];
    delete?: OrderDocumentWhereUniqueInput | OrderDocumentWhereUniqueInput[];
    connect?: OrderDocumentWhereUniqueInput | OrderDocumentWhereUniqueInput[];
    update?:
      | OrderDocumentUpdateWithWhereUniqueWithoutOrderInput
      | OrderDocumentUpdateWithWhereUniqueWithoutOrderInput[];
    updateMany?:
      | OrderDocumentUpdateManyWithWhereWithoutOrderInput
      | OrderDocumentUpdateManyWithWhereWithoutOrderInput[];
    deleteMany?: OrderDocumentScalarWhereInput | OrderDocumentScalarWhereInput[];
  };

  export type PaymentUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>;
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput;
    upsert?: PaymentUpsertWithoutOrderInput;
    disconnect?: PaymentWhereInput | boolean;
    delete?: PaymentWhereInput | boolean;
    connect?: PaymentWhereUniqueInput;
    update?: XOR<
      XOR<PaymentUpdateToOneWithWhereWithoutOrderInput, PaymentUpdateWithoutOrderInput>,
      PaymentUncheckedUpdateWithoutOrderInput
    >;
  };

  export type FormSerialUncheckedUpdateManyWithoutOrderNestedInput = {
    create?:
      | XOR<FormSerialCreateWithoutOrderInput, FormSerialUncheckedCreateWithoutOrderInput>
      | FormSerialCreateWithoutOrderInput[]
      | FormSerialUncheckedCreateWithoutOrderInput[];
    connectOrCreate?:
      | FormSerialCreateOrConnectWithoutOrderInput
      | FormSerialCreateOrConnectWithoutOrderInput[];
    upsert?:
      | FormSerialUpsertWithWhereUniqueWithoutOrderInput
      | FormSerialUpsertWithWhereUniqueWithoutOrderInput[];
    createMany?: FormSerialCreateManyOrderInputEnvelope;
    set?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
    disconnect?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
    delete?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
    connect?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
    update?:
      | FormSerialUpdateWithWhereUniqueWithoutOrderInput
      | FormSerialUpdateWithWhereUniqueWithoutOrderInput[];
    updateMany?:
      | FormSerialUpdateManyWithWhereWithoutOrderInput
      | FormSerialUpdateManyWithWhereWithoutOrderInput[];
    deleteMany?: FormSerialScalarWhereInput | FormSerialScalarWhereInput[];
  };

  export type OrderCreateNestedOneWithoutPaymentInput = {
    create?: XOR<OrderCreateWithoutPaymentInput, OrderUncheckedCreateWithoutPaymentInput>;
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentInput;
    connect?: OrderWhereUniqueInput;
  };

  export type OrderUpdateOneRequiredWithoutPaymentNestedInput = {
    create?: XOR<OrderCreateWithoutPaymentInput, OrderUncheckedCreateWithoutPaymentInput>;
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentInput;
    upsert?: OrderUpsertWithoutPaymentInput;
    connect?: OrderWhereUniqueInput;
    update?: XOR<
      XOR<OrderUpdateToOneWithWhereWithoutPaymentInput, OrderUpdateWithoutPaymentInput>,
      OrderUncheckedUpdateWithoutPaymentInput
    >;
  };

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput;
    upsert?: UserUpsertWithoutAuditLogsInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>,
      UserUncheckedUpdateWithoutAuditLogsInput
    >;
  };

  export type OrderCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<OrderCreateWithoutDocumentsInput, OrderUncheckedCreateWithoutDocumentsInput>;
    connectOrCreate?: OrderCreateOrConnectWithoutDocumentsInput;
    connect?: OrderWhereUniqueInput;
  };

  export type OrderUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<OrderCreateWithoutDocumentsInput, OrderUncheckedCreateWithoutDocumentsInput>;
    connectOrCreate?: OrderCreateOrConnectWithoutDocumentsInput;
    upsert?: OrderUpsertWithoutDocumentsInput;
    connect?: OrderWhereUniqueInput;
    update?: XOR<
      XOR<OrderUpdateToOneWithWhereWithoutDocumentsInput, OrderUpdateWithoutDocumentsInput>,
      OrderUncheckedUpdateWithoutDocumentsInput
    >;
  };

  export type OrderCreateNestedOneWithoutOrderDocumentsInput = {
    create?: XOR<
      OrderCreateWithoutOrderDocumentsInput,
      OrderUncheckedCreateWithoutOrderDocumentsInput
    >;
    connectOrCreate?: OrderCreateOrConnectWithoutOrderDocumentsInput;
    connect?: OrderWhereUniqueInput;
  };

  export type OrderUpdateOneRequiredWithoutOrderDocumentsNestedInput = {
    create?: XOR<
      OrderCreateWithoutOrderDocumentsInput,
      OrderUncheckedCreateWithoutOrderDocumentsInput
    >;
    connectOrCreate?: OrderCreateOrConnectWithoutOrderDocumentsInput;
    upsert?: OrderUpsertWithoutOrderDocumentsInput;
    connect?: OrderWhereUniqueInput;
    update?: XOR<
      XOR<
        OrderUpdateToOneWithWhereWithoutOrderDocumentsInput,
        OrderUpdateWithoutOrderDocumentsInput
      >,
      OrderUncheckedUpdateWithoutOrderDocumentsInput
    >;
  };

  export type ServiceCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<ServiceCreateWithoutDocumentsInput, ServiceUncheckedCreateWithoutDocumentsInput>;
    connectOrCreate?: ServiceCreateOrConnectWithoutDocumentsInput;
    connect?: ServiceWhereUniqueInput;
  };

  export type ServiceUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<ServiceCreateWithoutDocumentsInput, ServiceUncheckedCreateWithoutDocumentsInput>;
    connectOrCreate?: ServiceCreateOrConnectWithoutDocumentsInput;
    upsert?: ServiceUpsertWithoutDocumentsInput;
    connect?: ServiceWhereUniqueInput;
    update?: XOR<
      XOR<ServiceUpdateToOneWithWhereWithoutDocumentsInput, ServiceUpdateWithoutDocumentsInput>,
      ServiceUncheckedUpdateWithoutDocumentsInput
    >;
  };

  export type FormTypeVariantCreateNestedManyWithoutFormTypeInput = {
    create?:
      | XOR<
          FormTypeVariantCreateWithoutFormTypeInput,
          FormTypeVariantUncheckedCreateWithoutFormTypeInput
        >
      | FormTypeVariantCreateWithoutFormTypeInput[]
      | FormTypeVariantUncheckedCreateWithoutFormTypeInput[];
    connectOrCreate?:
      | FormTypeVariantCreateOrConnectWithoutFormTypeInput
      | FormTypeVariantCreateOrConnectWithoutFormTypeInput[];
    createMany?: FormTypeVariantCreateManyFormTypeInputEnvelope;
    connect?: FormTypeVariantWhereUniqueInput | FormTypeVariantWhereUniqueInput[];
  };

  export type FormSerialCreateNestedManyWithoutFormTypeInput = {
    create?:
      | XOR<FormSerialCreateWithoutFormTypeInput, FormSerialUncheckedCreateWithoutFormTypeInput>
      | FormSerialCreateWithoutFormTypeInput[]
      | FormSerialUncheckedCreateWithoutFormTypeInput[];
    connectOrCreate?:
      | FormSerialCreateOrConnectWithoutFormTypeInput
      | FormSerialCreateOrConnectWithoutFormTypeInput[];
    createMany?: FormSerialCreateManyFormTypeInputEnvelope;
    connect?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
  };

  export type FormTypeVariantUncheckedCreateNestedManyWithoutFormTypeInput = {
    create?:
      | XOR<
          FormTypeVariantCreateWithoutFormTypeInput,
          FormTypeVariantUncheckedCreateWithoutFormTypeInput
        >
      | FormTypeVariantCreateWithoutFormTypeInput[]
      | FormTypeVariantUncheckedCreateWithoutFormTypeInput[];
    connectOrCreate?:
      | FormTypeVariantCreateOrConnectWithoutFormTypeInput
      | FormTypeVariantCreateOrConnectWithoutFormTypeInput[];
    createMany?: FormTypeVariantCreateManyFormTypeInputEnvelope;
    connect?: FormTypeVariantWhereUniqueInput | FormTypeVariantWhereUniqueInput[];
  };

  export type FormSerialUncheckedCreateNestedManyWithoutFormTypeInput = {
    create?:
      | XOR<FormSerialCreateWithoutFormTypeInput, FormSerialUncheckedCreateWithoutFormTypeInput>
      | FormSerialCreateWithoutFormTypeInput[]
      | FormSerialUncheckedCreateWithoutFormTypeInput[];
    connectOrCreate?:
      | FormSerialCreateOrConnectWithoutFormTypeInput
      | FormSerialCreateOrConnectWithoutFormTypeInput[];
    createMany?: FormSerialCreateManyFormTypeInputEnvelope;
    connect?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
  };

  export type FormTypeVariantUpdateManyWithoutFormTypeNestedInput = {
    create?:
      | XOR<
          FormTypeVariantCreateWithoutFormTypeInput,
          FormTypeVariantUncheckedCreateWithoutFormTypeInput
        >
      | FormTypeVariantCreateWithoutFormTypeInput[]
      | FormTypeVariantUncheckedCreateWithoutFormTypeInput[];
    connectOrCreate?:
      | FormTypeVariantCreateOrConnectWithoutFormTypeInput
      | FormTypeVariantCreateOrConnectWithoutFormTypeInput[];
    upsert?:
      | FormTypeVariantUpsertWithWhereUniqueWithoutFormTypeInput
      | FormTypeVariantUpsertWithWhereUniqueWithoutFormTypeInput[];
    createMany?: FormTypeVariantCreateManyFormTypeInputEnvelope;
    set?: FormTypeVariantWhereUniqueInput | FormTypeVariantWhereUniqueInput[];
    disconnect?: FormTypeVariantWhereUniqueInput | FormTypeVariantWhereUniqueInput[];
    delete?: FormTypeVariantWhereUniqueInput | FormTypeVariantWhereUniqueInput[];
    connect?: FormTypeVariantWhereUniqueInput | FormTypeVariantWhereUniqueInput[];
    update?:
      | FormTypeVariantUpdateWithWhereUniqueWithoutFormTypeInput
      | FormTypeVariantUpdateWithWhereUniqueWithoutFormTypeInput[];
    updateMany?:
      | FormTypeVariantUpdateManyWithWhereWithoutFormTypeInput
      | FormTypeVariantUpdateManyWithWhereWithoutFormTypeInput[];
    deleteMany?: FormTypeVariantScalarWhereInput | FormTypeVariantScalarWhereInput[];
  };

  export type FormSerialUpdateManyWithoutFormTypeNestedInput = {
    create?:
      | XOR<FormSerialCreateWithoutFormTypeInput, FormSerialUncheckedCreateWithoutFormTypeInput>
      | FormSerialCreateWithoutFormTypeInput[]
      | FormSerialUncheckedCreateWithoutFormTypeInput[];
    connectOrCreate?:
      | FormSerialCreateOrConnectWithoutFormTypeInput
      | FormSerialCreateOrConnectWithoutFormTypeInput[];
    upsert?:
      | FormSerialUpsertWithWhereUniqueWithoutFormTypeInput
      | FormSerialUpsertWithWhereUniqueWithoutFormTypeInput[];
    createMany?: FormSerialCreateManyFormTypeInputEnvelope;
    set?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
    disconnect?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
    delete?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
    connect?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
    update?:
      | FormSerialUpdateWithWhereUniqueWithoutFormTypeInput
      | FormSerialUpdateWithWhereUniqueWithoutFormTypeInput[];
    updateMany?:
      | FormSerialUpdateManyWithWhereWithoutFormTypeInput
      | FormSerialUpdateManyWithWhereWithoutFormTypeInput[];
    deleteMany?: FormSerialScalarWhereInput | FormSerialScalarWhereInput[];
  };

  export type FormTypeVariantUncheckedUpdateManyWithoutFormTypeNestedInput = {
    create?:
      | XOR<
          FormTypeVariantCreateWithoutFormTypeInput,
          FormTypeVariantUncheckedCreateWithoutFormTypeInput
        >
      | FormTypeVariantCreateWithoutFormTypeInput[]
      | FormTypeVariantUncheckedCreateWithoutFormTypeInput[];
    connectOrCreate?:
      | FormTypeVariantCreateOrConnectWithoutFormTypeInput
      | FormTypeVariantCreateOrConnectWithoutFormTypeInput[];
    upsert?:
      | FormTypeVariantUpsertWithWhereUniqueWithoutFormTypeInput
      | FormTypeVariantUpsertWithWhereUniqueWithoutFormTypeInput[];
    createMany?: FormTypeVariantCreateManyFormTypeInputEnvelope;
    set?: FormTypeVariantWhereUniqueInput | FormTypeVariantWhereUniqueInput[];
    disconnect?: FormTypeVariantWhereUniqueInput | FormTypeVariantWhereUniqueInput[];
    delete?: FormTypeVariantWhereUniqueInput | FormTypeVariantWhereUniqueInput[];
    connect?: FormTypeVariantWhereUniqueInput | FormTypeVariantWhereUniqueInput[];
    update?:
      | FormTypeVariantUpdateWithWhereUniqueWithoutFormTypeInput
      | FormTypeVariantUpdateWithWhereUniqueWithoutFormTypeInput[];
    updateMany?:
      | FormTypeVariantUpdateManyWithWhereWithoutFormTypeInput
      | FormTypeVariantUpdateManyWithWhereWithoutFormTypeInput[];
    deleteMany?: FormTypeVariantScalarWhereInput | FormTypeVariantScalarWhereInput[];
  };

  export type FormSerialUncheckedUpdateManyWithoutFormTypeNestedInput = {
    create?:
      | XOR<FormSerialCreateWithoutFormTypeInput, FormSerialUncheckedCreateWithoutFormTypeInput>
      | FormSerialCreateWithoutFormTypeInput[]
      | FormSerialUncheckedCreateWithoutFormTypeInput[];
    connectOrCreate?:
      | FormSerialCreateOrConnectWithoutFormTypeInput
      | FormSerialCreateOrConnectWithoutFormTypeInput[];
    upsert?:
      | FormSerialUpsertWithWhereUniqueWithoutFormTypeInput
      | FormSerialUpsertWithWhereUniqueWithoutFormTypeInput[];
    createMany?: FormSerialCreateManyFormTypeInputEnvelope;
    set?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
    disconnect?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
    delete?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
    connect?: FormSerialWhereUniqueInput | FormSerialWhereUniqueInput[];
    update?:
      | FormSerialUpdateWithWhereUniqueWithoutFormTypeInput
      | FormSerialUpdateWithWhereUniqueWithoutFormTypeInput[];
    updateMany?:
      | FormSerialUpdateManyWithWhereWithoutFormTypeInput
      | FormSerialUpdateManyWithWhereWithoutFormTypeInput[];
    deleteMany?: FormSerialScalarWhereInput | FormSerialScalarWhereInput[];
  };

  export type FormTypeCreateNestedOneWithoutVariantLinksInput = {
    create?: XOR<
      FormTypeCreateWithoutVariantLinksInput,
      FormTypeUncheckedCreateWithoutVariantLinksInput
    >;
    connectOrCreate?: FormTypeCreateOrConnectWithoutVariantLinksInput;
    connect?: FormTypeWhereUniqueInput;
  };

  export type ServiceVariantCreateNestedOneWithoutFormTypeLinksInput = {
    create?: XOR<
      ServiceVariantCreateWithoutFormTypeLinksInput,
      ServiceVariantUncheckedCreateWithoutFormTypeLinksInput
    >;
    connectOrCreate?: ServiceVariantCreateOrConnectWithoutFormTypeLinksInput;
    connect?: ServiceVariantWhereUniqueInput;
  };

  export type FormTypeUpdateOneRequiredWithoutVariantLinksNestedInput = {
    create?: XOR<
      FormTypeCreateWithoutVariantLinksInput,
      FormTypeUncheckedCreateWithoutVariantLinksInput
    >;
    connectOrCreate?: FormTypeCreateOrConnectWithoutVariantLinksInput;
    upsert?: FormTypeUpsertWithoutVariantLinksInput;
    connect?: FormTypeWhereUniqueInput;
    update?: XOR<
      XOR<
        FormTypeUpdateToOneWithWhereWithoutVariantLinksInput,
        FormTypeUpdateWithoutVariantLinksInput
      >,
      FormTypeUncheckedUpdateWithoutVariantLinksInput
    >;
  };

  export type ServiceVariantUpdateOneRequiredWithoutFormTypeLinksNestedInput = {
    create?: XOR<
      ServiceVariantCreateWithoutFormTypeLinksInput,
      ServiceVariantUncheckedCreateWithoutFormTypeLinksInput
    >;
    connectOrCreate?: ServiceVariantCreateOrConnectWithoutFormTypeLinksInput;
    upsert?: ServiceVariantUpsertWithoutFormTypeLinksInput;
    connect?: ServiceVariantWhereUniqueInput;
    update?: XOR<
      XOR<
        ServiceVariantUpdateToOneWithWhereWithoutFormTypeLinksInput,
        ServiceVariantUpdateWithoutFormTypeLinksInput
      >,
      ServiceVariantUncheckedUpdateWithoutFormTypeLinksInput
    >;
  };

  export type FormTypeCreateNestedOneWithoutSerialsInput = {
    create?: XOR<FormTypeCreateWithoutSerialsInput, FormTypeUncheckedCreateWithoutSerialsInput>;
    connectOrCreate?: FormTypeCreateOrConnectWithoutSerialsInput;
    connect?: FormTypeWhereUniqueInput;
  };

  export type OrderCreateNestedOneWithoutFormSerialsInput = {
    create?: XOR<OrderCreateWithoutFormSerialsInput, OrderUncheckedCreateWithoutFormSerialsInput>;
    connectOrCreate?: OrderCreateOrConnectWithoutFormSerialsInput;
    connect?: OrderWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutAddedFormSerialsInput = {
    create?: XOR<
      UserCreateWithoutAddedFormSerialsInput,
      UserUncheckedCreateWithoutAddedFormSerialsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAddedFormSerialsInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutConsumedFormSerialsInput = {
    create?: XOR<
      UserCreateWithoutConsumedFormSerialsInput,
      UserUncheckedCreateWithoutConsumedFormSerialsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutConsumedFormSerialsInput;
    connect?: UserWhereUniqueInput;
  };

  export type FormTypeUpdateOneRequiredWithoutSerialsNestedInput = {
    create?: XOR<FormTypeCreateWithoutSerialsInput, FormTypeUncheckedCreateWithoutSerialsInput>;
    connectOrCreate?: FormTypeCreateOrConnectWithoutSerialsInput;
    upsert?: FormTypeUpsertWithoutSerialsInput;
    connect?: FormTypeWhereUniqueInput;
    update?: XOR<
      XOR<FormTypeUpdateToOneWithWhereWithoutSerialsInput, FormTypeUpdateWithoutSerialsInput>,
      FormTypeUncheckedUpdateWithoutSerialsInput
    >;
  };

  export type OrderUpdateOneWithoutFormSerialsNestedInput = {
    create?: XOR<OrderCreateWithoutFormSerialsInput, OrderUncheckedCreateWithoutFormSerialsInput>;
    connectOrCreate?: OrderCreateOrConnectWithoutFormSerialsInput;
    upsert?: OrderUpsertWithoutFormSerialsInput;
    disconnect?: OrderWhereInput | boolean;
    delete?: OrderWhereInput | boolean;
    connect?: OrderWhereUniqueInput;
    update?: XOR<
      XOR<OrderUpdateToOneWithWhereWithoutFormSerialsInput, OrderUpdateWithoutFormSerialsInput>,
      OrderUncheckedUpdateWithoutFormSerialsInput
    >;
  };

  export type UserUpdateOneWithoutAddedFormSerialsNestedInput = {
    create?: XOR<
      UserCreateWithoutAddedFormSerialsInput,
      UserUncheckedCreateWithoutAddedFormSerialsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAddedFormSerialsInput;
    upsert?: UserUpsertWithoutAddedFormSerialsInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutAddedFormSerialsInput,
        UserUpdateWithoutAddedFormSerialsInput
      >,
      UserUncheckedUpdateWithoutAddedFormSerialsInput
    >;
  };

  export type UserUpdateOneWithoutConsumedFormSerialsNestedInput = {
    create?: XOR<
      UserCreateWithoutConsumedFormSerialsInput,
      UserUncheckedCreateWithoutConsumedFormSerialsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutConsumedFormSerialsInput;
    upsert?: UserUpsertWithoutConsumedFormSerialsInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutConsumedFormSerialsInput,
        UserUpdateWithoutConsumedFormSerialsInput
      >,
      UserUncheckedUpdateWithoutConsumedFormSerialsInput
    >;
  };

  export type UserCreateNestedOneWithoutCreatedDependentsInput = {
    create?: XOR<
      UserCreateWithoutCreatedDependentsInput,
      UserUncheckedCreateWithoutCreatedDependentsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutCreatedDependentsInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneWithoutCreatedDependentsNestedInput = {
    create?: XOR<
      UserCreateWithoutCreatedDependentsInput,
      UserUncheckedCreateWithoutCreatedDependentsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutCreatedDependentsInput;
    upsert?: UserUpsertWithoutCreatedDependentsInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutCreatedDependentsInput,
        UserUpdateWithoutCreatedDependentsInput
      >,
      UserUncheckedUpdateWithoutCreatedDependentsInput
    >;
  };

  export type OrderCreateNestedManyWithoutPromoCodeInput = {
    create?:
      | XOR<OrderCreateWithoutPromoCodeInput, OrderUncheckedCreateWithoutPromoCodeInput>
      | OrderCreateWithoutPromoCodeInput[]
      | OrderUncheckedCreateWithoutPromoCodeInput[];
    connectOrCreate?:
      | OrderCreateOrConnectWithoutPromoCodeInput
      | OrderCreateOrConnectWithoutPromoCodeInput[];
    createMany?: OrderCreateManyPromoCodeInputEnvelope;
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
  };

  export type OrderUncheckedCreateNestedManyWithoutPromoCodeInput = {
    create?:
      | XOR<OrderCreateWithoutPromoCodeInput, OrderUncheckedCreateWithoutPromoCodeInput>
      | OrderCreateWithoutPromoCodeInput[]
      | OrderUncheckedCreateWithoutPromoCodeInput[];
    connectOrCreate?:
      | OrderCreateOrConnectWithoutPromoCodeInput
      | OrderCreateOrConnectWithoutPromoCodeInput[];
    createMany?: OrderCreateManyPromoCodeInputEnvelope;
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
  };

  export type OrderUpdateManyWithoutPromoCodeNestedInput = {
    create?:
      | XOR<OrderCreateWithoutPromoCodeInput, OrderUncheckedCreateWithoutPromoCodeInput>
      | OrderCreateWithoutPromoCodeInput[]
      | OrderUncheckedCreateWithoutPromoCodeInput[];
    connectOrCreate?:
      | OrderCreateOrConnectWithoutPromoCodeInput
      | OrderCreateOrConnectWithoutPromoCodeInput[];
    upsert?:
      | OrderUpsertWithWhereUniqueWithoutPromoCodeInput
      | OrderUpsertWithWhereUniqueWithoutPromoCodeInput[];
    createMany?: OrderCreateManyPromoCodeInputEnvelope;
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    update?:
      | OrderUpdateWithWhereUniqueWithoutPromoCodeInput
      | OrderUpdateWithWhereUniqueWithoutPromoCodeInput[];
    updateMany?:
      | OrderUpdateManyWithWhereWithoutPromoCodeInput
      | OrderUpdateManyWithWhereWithoutPromoCodeInput[];
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[];
  };

  export type OrderUncheckedUpdateManyWithoutPromoCodeNestedInput = {
    create?:
      | XOR<OrderCreateWithoutPromoCodeInput, OrderUncheckedCreateWithoutPromoCodeInput>
      | OrderCreateWithoutPromoCodeInput[]
      | OrderUncheckedCreateWithoutPromoCodeInput[];
    connectOrCreate?:
      | OrderCreateOrConnectWithoutPromoCodeInput
      | OrderCreateOrConnectWithoutPromoCodeInput[];
    upsert?:
      | OrderUpsertWithWhereUniqueWithoutPromoCodeInput
      | OrderUpsertWithWhereUniqueWithoutPromoCodeInput[];
    createMany?: OrderCreateManyPromoCodeInputEnvelope;
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[];
    update?:
      | OrderUpdateWithWhereUniqueWithoutPromoCodeInput
      | OrderUpdateWithWhereUniqueWithoutPromoCodeInput[];
    updateMany?:
      | OrderUpdateManyWithWhereWithoutPromoCodeInput
      | OrderUpdateManyWithWhereWithoutPromoCodeInput[];
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[];
  };

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type UserCreateWithoutAccountsInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    passwordHash?: string | null;
    phone?: string | null;
    additionalPhone?: string | null;
    role?: string;
    resetToken?: string | null;
    resetTokenExpiry?: Date | string | null;
    verificationToken?: string | null;
    verificationTokenExpiry?: Date | string | null;
    verificationCode?: string | null;
    verificationCodeExpiry?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    wifeMotherName?: string | null;
    createdByAdmin?: UserCreateNestedOneWithoutCreatedUsersInput;
    createdUsers?: UserCreateNestedManyWithoutCreatedByAdminInput;
    createdOrders?: OrderCreateNestedManyWithoutCreatedByAdminInput;
    orders?: OrderCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    addedFormSerials?: FormSerialCreateNestedManyWithoutAddedByAdminInput;
    consumedFormSerials?: FormSerialCreateNestedManyWithoutConsumedByAdminInput;
    createdDependents?: DependentCreateNestedManyWithoutCreatedByAdminInput;
  };

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    passwordHash?: string | null;
    phone?: string | null;
    additionalPhone?: string | null;
    role?: string;
    createdByAdminId?: string | null;
    resetToken?: string | null;
    resetTokenExpiry?: Date | string | null;
    verificationToken?: string | null;
    verificationTokenExpiry?: Date | string | null;
    verificationCode?: string | null;
    verificationCodeExpiry?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    wifeMotherName?: string | null;
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByAdminInput;
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByAdminInput;
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    addedFormSerials?: FormSerialUncheckedCreateNestedManyWithoutAddedByAdminInput;
    consumedFormSerials?: FormSerialUncheckedCreateNestedManyWithoutConsumedByAdminInput;
    createdDependents?: DependentUncheckedCreateNestedManyWithoutCreatedByAdminInput;
  };

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>;
  };

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>;
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>;
  };

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationCodeExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdByAdmin?: UserUpdateOneWithoutCreatedUsersNestedInput;
    createdUsers?: UserUpdateManyWithoutCreatedByAdminNestedInput;
    createdOrders?: OrderUpdateManyWithoutCreatedByAdminNestedInput;
    orders?: OrderUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    addedFormSerials?: FormSerialUpdateManyWithoutAddedByAdminNestedInput;
    consumedFormSerials?: FormSerialUpdateManyWithoutConsumedByAdminNestedInput;
    createdDependents?: DependentUpdateManyWithoutCreatedByAdminNestedInput;
  };

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationCodeExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByAdminNestedInput;
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByAdminNestedInput;
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    addedFormSerials?: FormSerialUncheckedUpdateManyWithoutAddedByAdminNestedInput;
    consumedFormSerials?: FormSerialUncheckedUpdateManyWithoutConsumedByAdminNestedInput;
    createdDependents?: DependentUncheckedUpdateManyWithoutCreatedByAdminNestedInput;
  };

  export type UserCreateWithoutSessionsInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    passwordHash?: string | null;
    phone?: string | null;
    additionalPhone?: string | null;
    role?: string;
    resetToken?: string | null;
    resetTokenExpiry?: Date | string | null;
    verificationToken?: string | null;
    verificationTokenExpiry?: Date | string | null;
    verificationCode?: string | null;
    verificationCodeExpiry?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    wifeMotherName?: string | null;
    createdByAdmin?: UserCreateNestedOneWithoutCreatedUsersInput;
    createdUsers?: UserCreateNestedManyWithoutCreatedByAdminInput;
    createdOrders?: OrderCreateNestedManyWithoutCreatedByAdminInput;
    orders?: OrderCreateNestedManyWithoutUserInput;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    addedFormSerials?: FormSerialCreateNestedManyWithoutAddedByAdminInput;
    consumedFormSerials?: FormSerialCreateNestedManyWithoutConsumedByAdminInput;
    createdDependents?: DependentCreateNestedManyWithoutCreatedByAdminInput;
  };

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    passwordHash?: string | null;
    phone?: string | null;
    additionalPhone?: string | null;
    role?: string;
    createdByAdminId?: string | null;
    resetToken?: string | null;
    resetTokenExpiry?: Date | string | null;
    verificationToken?: string | null;
    verificationTokenExpiry?: Date | string | null;
    verificationCode?: string | null;
    verificationCodeExpiry?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    wifeMotherName?: string | null;
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByAdminInput;
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByAdminInput;
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    addedFormSerials?: FormSerialUncheckedCreateNestedManyWithoutAddedByAdminInput;
    consumedFormSerials?: FormSerialUncheckedCreateNestedManyWithoutConsumedByAdminInput;
    createdDependents?: DependentUncheckedCreateNestedManyWithoutCreatedByAdminInput;
  };

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>;
  };

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>;
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>;
  };

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationCodeExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdByAdmin?: UserUpdateOneWithoutCreatedUsersNestedInput;
    createdUsers?: UserUpdateManyWithoutCreatedByAdminNestedInput;
    createdOrders?: OrderUpdateManyWithoutCreatedByAdminNestedInput;
    orders?: OrderUpdateManyWithoutUserNestedInput;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    addedFormSerials?: FormSerialUpdateManyWithoutAddedByAdminNestedInput;
    consumedFormSerials?: FormSerialUpdateManyWithoutConsumedByAdminNestedInput;
    createdDependents?: DependentUpdateManyWithoutCreatedByAdminNestedInput;
  };

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationCodeExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByAdminNestedInput;
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByAdminNestedInput;
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    addedFormSerials?: FormSerialUncheckedUpdateManyWithoutAddedByAdminNestedInput;
    consumedFormSerials?: FormSerialUncheckedUpdateManyWithoutConsumedByAdminNestedInput;
    createdDependents?: DependentUncheckedUpdateManyWithoutCreatedByAdminNestedInput;
  };

  export type UserCreateWithoutCreatedUsersInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    passwordHash?: string | null;
    phone?: string | null;
    additionalPhone?: string | null;
    role?: string;
    resetToken?: string | null;
    resetTokenExpiry?: Date | string | null;
    verificationToken?: string | null;
    verificationTokenExpiry?: Date | string | null;
    verificationCode?: string | null;
    verificationCodeExpiry?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    wifeMotherName?: string | null;
    createdByAdmin?: UserCreateNestedOneWithoutCreatedUsersInput;
    createdOrders?: OrderCreateNestedManyWithoutCreatedByAdminInput;
    orders?: OrderCreateNestedManyWithoutUserInput;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    addedFormSerials?: FormSerialCreateNestedManyWithoutAddedByAdminInput;
    consumedFormSerials?: FormSerialCreateNestedManyWithoutConsumedByAdminInput;
    createdDependents?: DependentCreateNestedManyWithoutCreatedByAdminInput;
  };

  export type UserUncheckedCreateWithoutCreatedUsersInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    passwordHash?: string | null;
    phone?: string | null;
    additionalPhone?: string | null;
    role?: string;
    createdByAdminId?: string | null;
    resetToken?: string | null;
    resetTokenExpiry?: Date | string | null;
    verificationToken?: string | null;
    verificationTokenExpiry?: Date | string | null;
    verificationCode?: string | null;
    verificationCodeExpiry?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    wifeMotherName?: string | null;
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByAdminInput;
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    addedFormSerials?: FormSerialUncheckedCreateNestedManyWithoutAddedByAdminInput;
    consumedFormSerials?: FormSerialUncheckedCreateNestedManyWithoutConsumedByAdminInput;
    createdDependents?: DependentUncheckedCreateNestedManyWithoutCreatedByAdminInput;
  };

  export type UserCreateOrConnectWithoutCreatedUsersInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>;
  };

  export type UserCreateWithoutCreatedByAdminInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    passwordHash?: string | null;
    phone?: string | null;
    additionalPhone?: string | null;
    role?: string;
    resetToken?: string | null;
    resetTokenExpiry?: Date | string | null;
    verificationToken?: string | null;
    verificationTokenExpiry?: Date | string | null;
    verificationCode?: string | null;
    verificationCodeExpiry?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    wifeMotherName?: string | null;
    createdUsers?: UserCreateNestedManyWithoutCreatedByAdminInput;
    createdOrders?: OrderCreateNestedManyWithoutCreatedByAdminInput;
    orders?: OrderCreateNestedManyWithoutUserInput;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    addedFormSerials?: FormSerialCreateNestedManyWithoutAddedByAdminInput;
    consumedFormSerials?: FormSerialCreateNestedManyWithoutConsumedByAdminInput;
    createdDependents?: DependentCreateNestedManyWithoutCreatedByAdminInput;
  };

  export type UserUncheckedCreateWithoutCreatedByAdminInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    passwordHash?: string | null;
    phone?: string | null;
    additionalPhone?: string | null;
    role?: string;
    resetToken?: string | null;
    resetTokenExpiry?: Date | string | null;
    verificationToken?: string | null;
    verificationTokenExpiry?: Date | string | null;
    verificationCode?: string | null;
    verificationCodeExpiry?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    wifeMotherName?: string | null;
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByAdminInput;
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByAdminInput;
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    addedFormSerials?: FormSerialUncheckedCreateNestedManyWithoutAddedByAdminInput;
    consumedFormSerials?: FormSerialUncheckedCreateNestedManyWithoutConsumedByAdminInput;
    createdDependents?: DependentUncheckedCreateNestedManyWithoutCreatedByAdminInput;
  };

  export type UserCreateOrConnectWithoutCreatedByAdminInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutCreatedByAdminInput,
      UserUncheckedCreateWithoutCreatedByAdminInput
    >;
  };

  export type UserCreateManyCreatedByAdminInputEnvelope = {
    data: UserCreateManyCreatedByAdminInput | UserCreateManyCreatedByAdminInput[];
    skipDuplicates?: boolean;
  };

  export type OrderCreateWithoutCreatedByAdminInput = {
    id?: string;
    status?: string;
    totalPrice: number;
    totalCents: number;
    customerName: string;
    customerPhone: string;
    additionalPhone?: string | null;
    customerEmail: string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    notes?: string | null;
    adminNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    completedAt?: Date | string | null;
    estimatedCompletionDate?: Date | string | null;
    deliveryFee?: number;
    deliveryType?: string;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    photographyLocation?: string | null;
    photographyDate?: Date | string | null;
    marriageDate?: Date | string | null;
    divorceDate?: Date | string | null;
    wifeMotherName?: string | null;
    quantity?: number;
    serviceDetails?: string | null;
    otherFees?: number;
    discount?: number;
    gender?: string | null;
    policeStation?: string | null;
    pickupLocation?: string | null;
    originalDocuments?: string | null;
    attachedDocuments?: string | null;
    hasAttachments?: boolean;
    selectedFines?: string | null;
    finesDetails?: string | null;
    servicesDetails?: string | null;
    customerFollowUp?: string | null;
    discountAmount?: number;
    documents?: DocumentCreateNestedManyWithoutOrderInput;
    service: ServiceCreateNestedOneWithoutOrdersInput;
    user: UserCreateNestedOneWithoutOrdersInput;
    variant: ServiceVariantCreateNestedOneWithoutOrdersInput;
    orderDocuments?: OrderDocumentCreateNestedManyWithoutOrderInput;
    payment?: PaymentCreateNestedOneWithoutOrderInput;
    formSerials?: FormSerialCreateNestedManyWithoutOrderInput;
    promoCode?: PromoCodeCreateNestedOneWithoutOrdersInput;
  };

  export type OrderUncheckedCreateWithoutCreatedByAdminInput = {
    id?: string;
    userId: string;
    serviceId: string;
    variantId: string;
    status?: string;
    totalPrice: number;
    totalCents: number;
    customerName: string;
    customerPhone: string;
    additionalPhone?: string | null;
    customerEmail: string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    notes?: string | null;
    adminNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    completedAt?: Date | string | null;
    estimatedCompletionDate?: Date | string | null;
    deliveryFee?: number;
    deliveryType?: string;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    photographyLocation?: string | null;
    photographyDate?: Date | string | null;
    marriageDate?: Date | string | null;
    divorceDate?: Date | string | null;
    wifeMotherName?: string | null;
    quantity?: number;
    serviceDetails?: string | null;
    otherFees?: number;
    discount?: number;
    gender?: string | null;
    policeStation?: string | null;
    pickupLocation?: string | null;
    originalDocuments?: string | null;
    attachedDocuments?: string | null;
    hasAttachments?: boolean;
    selectedFines?: string | null;
    finesDetails?: string | null;
    servicesDetails?: string | null;
    customerFollowUp?: string | null;
    promoCodeId?: string | null;
    discountAmount?: number;
    documents?: DocumentUncheckedCreateNestedManyWithoutOrderInput;
    orderDocuments?: OrderDocumentUncheckedCreateNestedManyWithoutOrderInput;
    payment?: PaymentUncheckedCreateNestedOneWithoutOrderInput;
    formSerials?: FormSerialUncheckedCreateNestedManyWithoutOrderInput;
  };

  export type OrderCreateOrConnectWithoutCreatedByAdminInput = {
    where: OrderWhereUniqueInput;
    create: XOR<
      OrderCreateWithoutCreatedByAdminInput,
      OrderUncheckedCreateWithoutCreatedByAdminInput
    >;
  };

  export type OrderCreateManyCreatedByAdminInputEnvelope = {
    data: OrderCreateManyCreatedByAdminInput | OrderCreateManyCreatedByAdminInput[];
    skipDuplicates?: boolean;
  };

  export type OrderCreateWithoutUserInput = {
    id?: string;
    status?: string;
    totalPrice: number;
    totalCents: number;
    customerName: string;
    customerPhone: string;
    additionalPhone?: string | null;
    customerEmail: string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    notes?: string | null;
    adminNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    completedAt?: Date | string | null;
    estimatedCompletionDate?: Date | string | null;
    deliveryFee?: number;
    deliveryType?: string;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    photographyLocation?: string | null;
    photographyDate?: Date | string | null;
    marriageDate?: Date | string | null;
    divorceDate?: Date | string | null;
    wifeMotherName?: string | null;
    quantity?: number;
    serviceDetails?: string | null;
    otherFees?: number;
    discount?: number;
    gender?: string | null;
    policeStation?: string | null;
    pickupLocation?: string | null;
    originalDocuments?: string | null;
    attachedDocuments?: string | null;
    hasAttachments?: boolean;
    selectedFines?: string | null;
    finesDetails?: string | null;
    servicesDetails?: string | null;
    customerFollowUp?: string | null;
    discountAmount?: number;
    createdByAdmin?: UserCreateNestedOneWithoutCreatedOrdersInput;
    documents?: DocumentCreateNestedManyWithoutOrderInput;
    service: ServiceCreateNestedOneWithoutOrdersInput;
    variant: ServiceVariantCreateNestedOneWithoutOrdersInput;
    orderDocuments?: OrderDocumentCreateNestedManyWithoutOrderInput;
    payment?: PaymentCreateNestedOneWithoutOrderInput;
    formSerials?: FormSerialCreateNestedManyWithoutOrderInput;
    promoCode?: PromoCodeCreateNestedOneWithoutOrdersInput;
  };

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: string;
    serviceId: string;
    variantId: string;
    status?: string;
    totalPrice: number;
    totalCents: number;
    customerName: string;
    customerPhone: string;
    additionalPhone?: string | null;
    customerEmail: string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    notes?: string | null;
    adminNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    completedAt?: Date | string | null;
    estimatedCompletionDate?: Date | string | null;
    deliveryFee?: number;
    deliveryType?: string;
    createdByAdminId?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    photographyLocation?: string | null;
    photographyDate?: Date | string | null;
    marriageDate?: Date | string | null;
    divorceDate?: Date | string | null;
    wifeMotherName?: string | null;
    quantity?: number;
    serviceDetails?: string | null;
    otherFees?: number;
    discount?: number;
    gender?: string | null;
    policeStation?: string | null;
    pickupLocation?: string | null;
    originalDocuments?: string | null;
    attachedDocuments?: string | null;
    hasAttachments?: boolean;
    selectedFines?: string | null;
    finesDetails?: string | null;
    servicesDetails?: string | null;
    customerFollowUp?: string | null;
    promoCodeId?: string | null;
    discountAmount?: number;
    documents?: DocumentUncheckedCreateNestedManyWithoutOrderInput;
    orderDocuments?: OrderDocumentUncheckedCreateNestedManyWithoutOrderInput;
    payment?: PaymentUncheckedCreateNestedOneWithoutOrderInput;
    formSerials?: FormSerialUncheckedCreateNestedManyWithoutOrderInput;
  };

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput;
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>;
  };

  export type OrderCreateManyUserInputEnvelope = {
    data: OrderCreateManyUserInput | OrderCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type AccountCreateWithoutUserInput = {
    id?: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
  };

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
  };

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput;
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>;
  };

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type AuditLogCreateWithoutUserInput = {
    id?: string;
    action: string;
    entityType: string;
    entityId?: string | null;
    oldValues?: string | null;
    newValues?: string | null;
    ipAddress?: string | null;
    userAgent?: string | null;
    createdAt?: Date | string;
  };

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string;
    action: string;
    entityType: string;
    entityId?: string | null;
    oldValues?: string | null;
    newValues?: string | null;
    ipAddress?: string | null;
    userAgent?: string | null;
    createdAt?: Date | string;
  };

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput;
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>;
  };

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type SessionCreateWithoutUserInput = {
    id?: string;
    sessionToken: string;
    expires: Date | string;
  };

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string;
    sessionToken: string;
    expires: Date | string;
  };

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput;
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>;
  };

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type FormSerialCreateWithoutAddedByAdminInput = {
    id?: string;
    serialNumber: string;
    consumed?: boolean;
    consumedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    formType: FormTypeCreateNestedOneWithoutSerialsInput;
    order?: OrderCreateNestedOneWithoutFormSerialsInput;
    consumedByAdmin?: UserCreateNestedOneWithoutConsumedFormSerialsInput;
  };

  export type FormSerialUncheckedCreateWithoutAddedByAdminInput = {
    id?: string;
    formTypeId: string;
    serialNumber: string;
    orderId?: string | null;
    consumed?: boolean;
    consumedAt?: Date | string | null;
    consumedByAdminId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FormSerialCreateOrConnectWithoutAddedByAdminInput = {
    where: FormSerialWhereUniqueInput;
    create: XOR<
      FormSerialCreateWithoutAddedByAdminInput,
      FormSerialUncheckedCreateWithoutAddedByAdminInput
    >;
  };

  export type FormSerialCreateManyAddedByAdminInputEnvelope = {
    data: FormSerialCreateManyAddedByAdminInput | FormSerialCreateManyAddedByAdminInput[];
    skipDuplicates?: boolean;
  };

  export type FormSerialCreateWithoutConsumedByAdminInput = {
    id?: string;
    serialNumber: string;
    consumed?: boolean;
    consumedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    formType: FormTypeCreateNestedOneWithoutSerialsInput;
    order?: OrderCreateNestedOneWithoutFormSerialsInput;
    addedByAdmin?: UserCreateNestedOneWithoutAddedFormSerialsInput;
  };

  export type FormSerialUncheckedCreateWithoutConsumedByAdminInput = {
    id?: string;
    formTypeId: string;
    serialNumber: string;
    orderId?: string | null;
    consumed?: boolean;
    consumedAt?: Date | string | null;
    addedByAdminId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FormSerialCreateOrConnectWithoutConsumedByAdminInput = {
    where: FormSerialWhereUniqueInput;
    create: XOR<
      FormSerialCreateWithoutConsumedByAdminInput,
      FormSerialUncheckedCreateWithoutConsumedByAdminInput
    >;
  };

  export type FormSerialCreateManyConsumedByAdminInputEnvelope = {
    data: FormSerialCreateManyConsumedByAdminInput | FormSerialCreateManyConsumedByAdminInput[];
    skipDuplicates?: boolean;
  };

  export type DependentCreateWithoutCreatedByAdminInput = {
    id?: string;
    name: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type DependentUncheckedCreateWithoutCreatedByAdminInput = {
    id?: string;
    name: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type DependentCreateOrConnectWithoutCreatedByAdminInput = {
    where: DependentWhereUniqueInput;
    create: XOR<
      DependentCreateWithoutCreatedByAdminInput,
      DependentUncheckedCreateWithoutCreatedByAdminInput
    >;
  };

  export type DependentCreateManyCreatedByAdminInputEnvelope = {
    data: DependentCreateManyCreatedByAdminInput | DependentCreateManyCreatedByAdminInput[];
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithoutCreatedUsersInput = {
    update: XOR<UserUpdateWithoutCreatedUsersInput, UserUncheckedUpdateWithoutCreatedUsersInput>;
    create: XOR<UserCreateWithoutCreatedUsersInput, UserUncheckedCreateWithoutCreatedUsersInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutCreatedUsersInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutCreatedUsersInput, UserUncheckedUpdateWithoutCreatedUsersInput>;
  };

  export type UserUpdateWithoutCreatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationCodeExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdByAdmin?: UserUpdateOneWithoutCreatedUsersNestedInput;
    createdOrders?: OrderUpdateManyWithoutCreatedByAdminNestedInput;
    orders?: OrderUpdateManyWithoutUserNestedInput;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    addedFormSerials?: FormSerialUpdateManyWithoutAddedByAdminNestedInput;
    consumedFormSerials?: FormSerialUpdateManyWithoutConsumedByAdminNestedInput;
    createdDependents?: DependentUpdateManyWithoutCreatedByAdminNestedInput;
  };

  export type UserUncheckedUpdateWithoutCreatedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationCodeExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByAdminNestedInput;
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    addedFormSerials?: FormSerialUncheckedUpdateManyWithoutAddedByAdminNestedInput;
    consumedFormSerials?: FormSerialUncheckedUpdateManyWithoutConsumedByAdminNestedInput;
    createdDependents?: DependentUncheckedUpdateManyWithoutCreatedByAdminNestedInput;
  };

  export type UserUpsertWithWhereUniqueWithoutCreatedByAdminInput = {
    where: UserWhereUniqueInput;
    update: XOR<
      UserUpdateWithoutCreatedByAdminInput,
      UserUncheckedUpdateWithoutCreatedByAdminInput
    >;
    create: XOR<
      UserCreateWithoutCreatedByAdminInput,
      UserUncheckedCreateWithoutCreatedByAdminInput
    >;
  };

  export type UserUpdateWithWhereUniqueWithoutCreatedByAdminInput = {
    where: UserWhereUniqueInput;
    data: XOR<UserUpdateWithoutCreatedByAdminInput, UserUncheckedUpdateWithoutCreatedByAdminInput>;
  };

  export type UserUpdateManyWithWhereWithoutCreatedByAdminInput = {
    where: UserScalarWhereInput;
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCreatedByAdminInput>;
  };

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[];
    OR?: UserScalarWhereInput[];
    NOT?: UserScalarWhereInput | UserScalarWhereInput[];
    id?: StringFilter<'User'> | string;
    name?: StringNullableFilter<'User'> | string | null;
    email?: StringNullableFilter<'User'> | string | null;
    emailVerified?: DateTimeNullableFilter<'User'> | Date | string | null;
    image?: StringNullableFilter<'User'> | string | null;
    passwordHash?: StringNullableFilter<'User'> | string | null;
    phone?: StringNullableFilter<'User'> | string | null;
    additionalPhone?: StringNullableFilter<'User'> | string | null;
    role?: StringFilter<'User'> | string;
    createdByAdminId?: StringNullableFilter<'User'> | string | null;
    resetToken?: StringNullableFilter<'User'> | string | null;
    resetTokenExpiry?: DateTimeNullableFilter<'User'> | Date | string | null;
    verificationToken?: StringNullableFilter<'User'> | string | null;
    verificationTokenExpiry?: DateTimeNullableFilter<'User'> | Date | string | null;
    verificationCode?: StringNullableFilter<'User'> | string | null;
    verificationCodeExpiry?: DateTimeNullableFilter<'User'> | Date | string | null;
    createdAt?: DateTimeFilter<'User'> | Date | string;
    updatedAt?: DateTimeFilter<'User'> | Date | string;
    address?: StringNullableFilter<'User'> | string | null;
    governorate?: StringNullableFilter<'User'> | string | null;
    city?: StringNullableFilter<'User'> | string | null;
    district?: StringNullableFilter<'User'> | string | null;
    street?: StringNullableFilter<'User'> | string | null;
    buildingNumber?: StringNullableFilter<'User'> | string | null;
    apartmentNumber?: StringNullableFilter<'User'> | string | null;
    landmark?: StringNullableFilter<'User'> | string | null;
    birthDate?: DateTimeNullableFilter<'User'> | Date | string | null;
    fatherName?: StringNullableFilter<'User'> | string | null;
    idNumber?: StringNullableFilter<'User'> | string | null;
    motherName?: StringNullableFilter<'User'> | string | null;
    nationality?: StringNullableFilter<'User'> | string | null;
    wifeName?: StringNullableFilter<'User'> | string | null;
    wifeMotherName?: StringNullableFilter<'User'> | string | null;
  };

  export type OrderUpsertWithWhereUniqueWithoutCreatedByAdminInput = {
    where: OrderWhereUniqueInput;
    update: XOR<
      OrderUpdateWithoutCreatedByAdminInput,
      OrderUncheckedUpdateWithoutCreatedByAdminInput
    >;
    create: XOR<
      OrderCreateWithoutCreatedByAdminInput,
      OrderUncheckedCreateWithoutCreatedByAdminInput
    >;
  };

  export type OrderUpdateWithWhereUniqueWithoutCreatedByAdminInput = {
    where: OrderWhereUniqueInput;
    data: XOR<
      OrderUpdateWithoutCreatedByAdminInput,
      OrderUncheckedUpdateWithoutCreatedByAdminInput
    >;
  };

  export type OrderUpdateManyWithWhereWithoutCreatedByAdminInput = {
    where: OrderScalarWhereInput;
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutCreatedByAdminInput>;
  };

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[];
    OR?: OrderScalarWhereInput[];
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[];
    id?: StringFilter<'Order'> | string;
    userId?: StringFilter<'Order'> | string;
    serviceId?: StringFilter<'Order'> | string;
    variantId?: StringFilter<'Order'> | string;
    status?: StringFilter<'Order'> | string;
    totalPrice?: IntFilter<'Order'> | number;
    totalCents?: IntFilter<'Order'> | number;
    customerName?: StringFilter<'Order'> | string;
    customerPhone?: StringFilter<'Order'> | string;
    additionalPhone?: StringNullableFilter<'Order'> | string | null;
    customerEmail?: StringFilter<'Order'> | string;
    address?: StringNullableFilter<'Order'> | string | null;
    governorate?: StringNullableFilter<'Order'> | string | null;
    city?: StringNullableFilter<'Order'> | string | null;
    district?: StringNullableFilter<'Order'> | string | null;
    street?: StringNullableFilter<'Order'> | string | null;
    buildingNumber?: StringNullableFilter<'Order'> | string | null;
    apartmentNumber?: StringNullableFilter<'Order'> | string | null;
    landmark?: StringNullableFilter<'Order'> | string | null;
    notes?: StringNullableFilter<'Order'> | string | null;
    adminNotes?: StringNullableFilter<'Order'> | string | null;
    createdAt?: DateTimeFilter<'Order'> | Date | string;
    updatedAt?: DateTimeFilter<'Order'> | Date | string;
    completedAt?: DateTimeNullableFilter<'Order'> | Date | string | null;
    estimatedCompletionDate?: DateTimeNullableFilter<'Order'> | Date | string | null;
    deliveryFee?: IntFilter<'Order'> | number;
    deliveryType?: StringFilter<'Order'> | string;
    createdByAdminId?: StringNullableFilter<'Order'> | string | null;
    birthDate?: DateTimeNullableFilter<'Order'> | Date | string | null;
    fatherName?: StringNullableFilter<'Order'> | string | null;
    idNumber?: StringNullableFilter<'Order'> | string | null;
    motherName?: StringNullableFilter<'Order'> | string | null;
    nationality?: StringNullableFilter<'Order'> | string | null;
    wifeName?: StringNullableFilter<'Order'> | string | null;
    photographyLocation?: StringNullableFilter<'Order'> | string | null;
    photographyDate?: DateTimeNullableFilter<'Order'> | Date | string | null;
    marriageDate?: DateTimeNullableFilter<'Order'> | Date | string | null;
    divorceDate?: DateTimeNullableFilter<'Order'> | Date | string | null;
    wifeMotherName?: StringNullableFilter<'Order'> | string | null;
    quantity?: IntFilter<'Order'> | number;
    serviceDetails?: StringNullableFilter<'Order'> | string | null;
    otherFees?: IntFilter<'Order'> | number;
    discount?: IntFilter<'Order'> | number;
    gender?: StringNullableFilter<'Order'> | string | null;
    policeStation?: StringNullableFilter<'Order'> | string | null;
    pickupLocation?: StringNullableFilter<'Order'> | string | null;
    originalDocuments?: StringNullableFilter<'Order'> | string | null;
    attachedDocuments?: StringNullableFilter<'Order'> | string | null;
    hasAttachments?: BoolFilter<'Order'> | boolean;
    selectedFines?: StringNullableFilter<'Order'> | string | null;
    finesDetails?: StringNullableFilter<'Order'> | string | null;
    servicesDetails?: StringNullableFilter<'Order'> | string | null;
    customerFollowUp?: StringNullableFilter<'Order'> | string | null;
    promoCodeId?: StringNullableFilter<'Order'> | string | null;
    discountAmount?: IntFilter<'Order'> | number;
  };

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput;
    update: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>;
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>;
  };

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput;
    data: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>;
  };

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput;
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutUserInput>;
  };

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput;
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>;
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>;
  };

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput;
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>;
  };

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput;
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>;
  };

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[];
    OR?: AccountScalarWhereInput[];
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[];
    id?: StringFilter<'Account'> | string;
    userId?: StringFilter<'Account'> | string;
    type?: StringFilter<'Account'> | string;
    provider?: StringFilter<'Account'> | string;
    providerAccountId?: StringFilter<'Account'> | string;
    refresh_token?: StringNullableFilter<'Account'> | string | null;
    access_token?: StringNullableFilter<'Account'> | string | null;
    expires_at?: IntNullableFilter<'Account'> | number | null;
    token_type?: StringNullableFilter<'Account'> | string | null;
    scope?: StringNullableFilter<'Account'> | string | null;
    id_token?: StringNullableFilter<'Account'> | string | null;
    session_state?: StringNullableFilter<'Account'> | string | null;
  };

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput;
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>;
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>;
  };

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput;
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>;
  };

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput;
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>;
  };

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
    OR?: AuditLogScalarWhereInput[];
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
    id?: StringFilter<'AuditLog'> | string;
    userId?: StringNullableFilter<'AuditLog'> | string | null;
    action?: StringFilter<'AuditLog'> | string;
    entityType?: StringFilter<'AuditLog'> | string;
    entityId?: StringNullableFilter<'AuditLog'> | string | null;
    oldValues?: StringNullableFilter<'AuditLog'> | string | null;
    newValues?: StringNullableFilter<'AuditLog'> | string | null;
    ipAddress?: StringNullableFilter<'AuditLog'> | string | null;
    userAgent?: StringNullableFilter<'AuditLog'> | string | null;
    createdAt?: DateTimeFilter<'AuditLog'> | Date | string;
  };

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput;
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>;
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>;
  };

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput;
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>;
  };

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput;
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>;
  };

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[];
    OR?: SessionScalarWhereInput[];
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[];
    id?: StringFilter<'Session'> | string;
    sessionToken?: StringFilter<'Session'> | string;
    userId?: StringFilter<'Session'> | string;
    expires?: DateTimeFilter<'Session'> | Date | string;
  };

  export type FormSerialUpsertWithWhereUniqueWithoutAddedByAdminInput = {
    where: FormSerialWhereUniqueInput;
    update: XOR<
      FormSerialUpdateWithoutAddedByAdminInput,
      FormSerialUncheckedUpdateWithoutAddedByAdminInput
    >;
    create: XOR<
      FormSerialCreateWithoutAddedByAdminInput,
      FormSerialUncheckedCreateWithoutAddedByAdminInput
    >;
  };

  export type FormSerialUpdateWithWhereUniqueWithoutAddedByAdminInput = {
    where: FormSerialWhereUniqueInput;
    data: XOR<
      FormSerialUpdateWithoutAddedByAdminInput,
      FormSerialUncheckedUpdateWithoutAddedByAdminInput
    >;
  };

  export type FormSerialUpdateManyWithWhereWithoutAddedByAdminInput = {
    where: FormSerialScalarWhereInput;
    data: XOR<
      FormSerialUpdateManyMutationInput,
      FormSerialUncheckedUpdateManyWithoutAddedByAdminInput
    >;
  };

  export type FormSerialScalarWhereInput = {
    AND?: FormSerialScalarWhereInput | FormSerialScalarWhereInput[];
    OR?: FormSerialScalarWhereInput[];
    NOT?: FormSerialScalarWhereInput | FormSerialScalarWhereInput[];
    id?: StringFilter<'FormSerial'> | string;
    formTypeId?: StringFilter<'FormSerial'> | string;
    serialNumber?: StringFilter<'FormSerial'> | string;
    orderId?: StringNullableFilter<'FormSerial'> | string | null;
    consumed?: BoolFilter<'FormSerial'> | boolean;
    consumedAt?: DateTimeNullableFilter<'FormSerial'> | Date | string | null;
    addedByAdminId?: StringNullableFilter<'FormSerial'> | string | null;
    consumedByAdminId?: StringNullableFilter<'FormSerial'> | string | null;
    createdAt?: DateTimeFilter<'FormSerial'> | Date | string;
    updatedAt?: DateTimeFilter<'FormSerial'> | Date | string;
  };

  export type FormSerialUpsertWithWhereUniqueWithoutConsumedByAdminInput = {
    where: FormSerialWhereUniqueInput;
    update: XOR<
      FormSerialUpdateWithoutConsumedByAdminInput,
      FormSerialUncheckedUpdateWithoutConsumedByAdminInput
    >;
    create: XOR<
      FormSerialCreateWithoutConsumedByAdminInput,
      FormSerialUncheckedCreateWithoutConsumedByAdminInput
    >;
  };

  export type FormSerialUpdateWithWhereUniqueWithoutConsumedByAdminInput = {
    where: FormSerialWhereUniqueInput;
    data: XOR<
      FormSerialUpdateWithoutConsumedByAdminInput,
      FormSerialUncheckedUpdateWithoutConsumedByAdminInput
    >;
  };

  export type FormSerialUpdateManyWithWhereWithoutConsumedByAdminInput = {
    where: FormSerialScalarWhereInput;
    data: XOR<
      FormSerialUpdateManyMutationInput,
      FormSerialUncheckedUpdateManyWithoutConsumedByAdminInput
    >;
  };

  export type DependentUpsertWithWhereUniqueWithoutCreatedByAdminInput = {
    where: DependentWhereUniqueInput;
    update: XOR<
      DependentUpdateWithoutCreatedByAdminInput,
      DependentUncheckedUpdateWithoutCreatedByAdminInput
    >;
    create: XOR<
      DependentCreateWithoutCreatedByAdminInput,
      DependentUncheckedCreateWithoutCreatedByAdminInput
    >;
  };

  export type DependentUpdateWithWhereUniqueWithoutCreatedByAdminInput = {
    where: DependentWhereUniqueInput;
    data: XOR<
      DependentUpdateWithoutCreatedByAdminInput,
      DependentUncheckedUpdateWithoutCreatedByAdminInput
    >;
  };

  export type DependentUpdateManyWithWhereWithoutCreatedByAdminInput = {
    where: DependentScalarWhereInput;
    data: XOR<
      DependentUpdateManyMutationInput,
      DependentUncheckedUpdateManyWithoutCreatedByAdminInput
    >;
  };

  export type DependentScalarWhereInput = {
    AND?: DependentScalarWhereInput | DependentScalarWhereInput[];
    OR?: DependentScalarWhereInput[];
    NOT?: DependentScalarWhereInput | DependentScalarWhereInput[];
    id?: StringFilter<'Dependent'> | string;
    name?: StringFilter<'Dependent'> | string;
    createdAt?: DateTimeFilter<'Dependent'> | Date | string;
    updatedAt?: DateTimeFilter<'Dependent'> | Date | string;
    createdByAdminId?: StringNullableFilter<'Dependent'> | string | null;
  };

  export type ServiceCreateWithoutCategoryInput = {
    id?: string;
    name: string;
    slug: string;
    description?: string | null;
    icon?: string | null;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    orders?: OrderCreateNestedManyWithoutServiceInput;
    documents?: ServiceDocumentCreateNestedManyWithoutServiceInput;
    variants?: ServiceVariantCreateNestedManyWithoutServiceInput;
    fields?: ServiceFieldCreateNestedManyWithoutServiceInput;
  };

  export type ServiceUncheckedCreateWithoutCategoryInput = {
    id?: string;
    name: string;
    slug: string;
    description?: string | null;
    icon?: string | null;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    orders?: OrderUncheckedCreateNestedManyWithoutServiceInput;
    documents?: ServiceDocumentUncheckedCreateNestedManyWithoutServiceInput;
    variants?: ServiceVariantUncheckedCreateNestedManyWithoutServiceInput;
    fields?: ServiceFieldUncheckedCreateNestedManyWithoutServiceInput;
  };

  export type ServiceCreateOrConnectWithoutCategoryInput = {
    where: ServiceWhereUniqueInput;
    create: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput>;
  };

  export type ServiceCreateManyCategoryInputEnvelope = {
    data: ServiceCreateManyCategoryInput | ServiceCreateManyCategoryInput[];
    skipDuplicates?: boolean;
  };

  export type ServiceUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ServiceWhereUniqueInput;
    update: XOR<ServiceUpdateWithoutCategoryInput, ServiceUncheckedUpdateWithoutCategoryInput>;
    create: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput>;
  };

  export type ServiceUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ServiceWhereUniqueInput;
    data: XOR<ServiceUpdateWithoutCategoryInput, ServiceUncheckedUpdateWithoutCategoryInput>;
  };

  export type ServiceUpdateManyWithWhereWithoutCategoryInput = {
    where: ServiceScalarWhereInput;
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutCategoryInput>;
  };

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[];
    OR?: ServiceScalarWhereInput[];
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[];
    id?: StringFilter<'Service'> | string;
    name?: StringFilter<'Service'> | string;
    slug?: StringFilter<'Service'> | string;
    description?: StringNullableFilter<'Service'> | string | null;
    icon?: StringNullableFilter<'Service'> | string | null;
    active?: BoolFilter<'Service'> | boolean;
    categoryId?: StringFilter<'Service'> | string;
    createdAt?: DateTimeFilter<'Service'> | Date | string;
    updatedAt?: DateTimeFilter<'Service'> | Date | string;
  };

  export type OrderCreateWithoutServiceInput = {
    id?: string;
    status?: string;
    totalPrice: number;
    totalCents: number;
    customerName: string;
    customerPhone: string;
    additionalPhone?: string | null;
    customerEmail: string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    notes?: string | null;
    adminNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    completedAt?: Date | string | null;
    estimatedCompletionDate?: Date | string | null;
    deliveryFee?: number;
    deliveryType?: string;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    photographyLocation?: string | null;
    photographyDate?: Date | string | null;
    marriageDate?: Date | string | null;
    divorceDate?: Date | string | null;
    wifeMotherName?: string | null;
    quantity?: number;
    serviceDetails?: string | null;
    otherFees?: number;
    discount?: number;
    gender?: string | null;
    policeStation?: string | null;
    pickupLocation?: string | null;
    originalDocuments?: string | null;
    attachedDocuments?: string | null;
    hasAttachments?: boolean;
    selectedFines?: string | null;
    finesDetails?: string | null;
    servicesDetails?: string | null;
    customerFollowUp?: string | null;
    discountAmount?: number;
    createdByAdmin?: UserCreateNestedOneWithoutCreatedOrdersInput;
    documents?: DocumentCreateNestedManyWithoutOrderInput;
    user: UserCreateNestedOneWithoutOrdersInput;
    variant: ServiceVariantCreateNestedOneWithoutOrdersInput;
    orderDocuments?: OrderDocumentCreateNestedManyWithoutOrderInput;
    payment?: PaymentCreateNestedOneWithoutOrderInput;
    formSerials?: FormSerialCreateNestedManyWithoutOrderInput;
    promoCode?: PromoCodeCreateNestedOneWithoutOrdersInput;
  };

  export type OrderUncheckedCreateWithoutServiceInput = {
    id?: string;
    userId: string;
    variantId: string;
    status?: string;
    totalPrice: number;
    totalCents: number;
    customerName: string;
    customerPhone: string;
    additionalPhone?: string | null;
    customerEmail: string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    notes?: string | null;
    adminNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    completedAt?: Date | string | null;
    estimatedCompletionDate?: Date | string | null;
    deliveryFee?: number;
    deliveryType?: string;
    createdByAdminId?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    photographyLocation?: string | null;
    photographyDate?: Date | string | null;
    marriageDate?: Date | string | null;
    divorceDate?: Date | string | null;
    wifeMotherName?: string | null;
    quantity?: number;
    serviceDetails?: string | null;
    otherFees?: number;
    discount?: number;
    gender?: string | null;
    policeStation?: string | null;
    pickupLocation?: string | null;
    originalDocuments?: string | null;
    attachedDocuments?: string | null;
    hasAttachments?: boolean;
    selectedFines?: string | null;
    finesDetails?: string | null;
    servicesDetails?: string | null;
    customerFollowUp?: string | null;
    promoCodeId?: string | null;
    discountAmount?: number;
    documents?: DocumentUncheckedCreateNestedManyWithoutOrderInput;
    orderDocuments?: OrderDocumentUncheckedCreateNestedManyWithoutOrderInput;
    payment?: PaymentUncheckedCreateNestedOneWithoutOrderInput;
    formSerials?: FormSerialUncheckedCreateNestedManyWithoutOrderInput;
  };

  export type OrderCreateOrConnectWithoutServiceInput = {
    where: OrderWhereUniqueInput;
    create: XOR<OrderCreateWithoutServiceInput, OrderUncheckedCreateWithoutServiceInput>;
  };

  export type OrderCreateManyServiceInputEnvelope = {
    data: OrderCreateManyServiceInput | OrderCreateManyServiceInput[];
    skipDuplicates?: boolean;
  };

  export type CategoryCreateWithoutServicesInput = {
    id?: string;
    name: string;
    slug: string;
    orderIndex?: number;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    icon?: string | null;
  };

  export type CategoryUncheckedCreateWithoutServicesInput = {
    id?: string;
    name: string;
    slug: string;
    orderIndex?: number;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    icon?: string | null;
  };

  export type CategoryCreateOrConnectWithoutServicesInput = {
    where: CategoryWhereUniqueInput;
    create: XOR<CategoryCreateWithoutServicesInput, CategoryUncheckedCreateWithoutServicesInput>;
  };

  export type ServiceDocumentCreateWithoutServiceInput = {
    id?: string;
    title: string;
    description?: string | null;
    required?: boolean;
    showIf?: string | null;
    orderIndex?: number;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ServiceDocumentUncheckedCreateWithoutServiceInput = {
    id?: string;
    title: string;
    description?: string | null;
    required?: boolean;
    showIf?: string | null;
    orderIndex?: number;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ServiceDocumentCreateOrConnectWithoutServiceInput = {
    where: ServiceDocumentWhereUniqueInput;
    create: XOR<
      ServiceDocumentCreateWithoutServiceInput,
      ServiceDocumentUncheckedCreateWithoutServiceInput
    >;
  };

  export type ServiceDocumentCreateManyServiceInputEnvelope = {
    data: ServiceDocumentCreateManyServiceInput | ServiceDocumentCreateManyServiceInput[];
    skipDuplicates?: boolean;
  };

  export type ServiceVariantCreateWithoutServiceInput = {
    id?: string;
    name: string;
    priceCents: number;
    etaDays: number;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    orders?: OrderCreateNestedManyWithoutVariantInput;
    formTypeLinks?: FormTypeVariantCreateNestedManyWithoutServiceVariantInput;
  };

  export type ServiceVariantUncheckedCreateWithoutServiceInput = {
    id?: string;
    name: string;
    priceCents: number;
    etaDays: number;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    orders?: OrderUncheckedCreateNestedManyWithoutVariantInput;
    formTypeLinks?: FormTypeVariantUncheckedCreateNestedManyWithoutServiceVariantInput;
  };

  export type ServiceVariantCreateOrConnectWithoutServiceInput = {
    where: ServiceVariantWhereUniqueInput;
    create: XOR<
      ServiceVariantCreateWithoutServiceInput,
      ServiceVariantUncheckedCreateWithoutServiceInput
    >;
  };

  export type ServiceVariantCreateManyServiceInputEnvelope = {
    data: ServiceVariantCreateManyServiceInput | ServiceVariantCreateManyServiceInput[];
    skipDuplicates?: boolean;
  };

  export type ServiceFieldCreateWithoutServiceInput = {
    id?: string;
    name: string;
    label: string;
    type: string;
    placeholder?: string | null;
    required?: boolean;
    orderIndex?: number;
    active?: boolean;
    showIf?: string | null;
    validation?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    options?: ServiceFieldOptionCreateNestedManyWithoutFieldInput;
  };

  export type ServiceFieldUncheckedCreateWithoutServiceInput = {
    id?: string;
    name: string;
    label: string;
    type: string;
    placeholder?: string | null;
    required?: boolean;
    orderIndex?: number;
    active?: boolean;
    showIf?: string | null;
    validation?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    options?: ServiceFieldOptionUncheckedCreateNestedManyWithoutFieldInput;
  };

  export type ServiceFieldCreateOrConnectWithoutServiceInput = {
    where: ServiceFieldWhereUniqueInput;
    create: XOR<
      ServiceFieldCreateWithoutServiceInput,
      ServiceFieldUncheckedCreateWithoutServiceInput
    >;
  };

  export type ServiceFieldCreateManyServiceInputEnvelope = {
    data: ServiceFieldCreateManyServiceInput | ServiceFieldCreateManyServiceInput[];
    skipDuplicates?: boolean;
  };

  export type OrderUpsertWithWhereUniqueWithoutServiceInput = {
    where: OrderWhereUniqueInput;
    update: XOR<OrderUpdateWithoutServiceInput, OrderUncheckedUpdateWithoutServiceInput>;
    create: XOR<OrderCreateWithoutServiceInput, OrderUncheckedCreateWithoutServiceInput>;
  };

  export type OrderUpdateWithWhereUniqueWithoutServiceInput = {
    where: OrderWhereUniqueInput;
    data: XOR<OrderUpdateWithoutServiceInput, OrderUncheckedUpdateWithoutServiceInput>;
  };

  export type OrderUpdateManyWithWhereWithoutServiceInput = {
    where: OrderScalarWhereInput;
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutServiceInput>;
  };

  export type CategoryUpsertWithoutServicesInput = {
    update: XOR<CategoryUpdateWithoutServicesInput, CategoryUncheckedUpdateWithoutServicesInput>;
    create: XOR<CategoryCreateWithoutServicesInput, CategoryUncheckedCreateWithoutServicesInput>;
    where?: CategoryWhereInput;
  };

  export type CategoryUpdateToOneWithWhereWithoutServicesInput = {
    where?: CategoryWhereInput;
    data: XOR<CategoryUpdateWithoutServicesInput, CategoryUncheckedUpdateWithoutServicesInput>;
  };

  export type CategoryUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    orderIndex?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    icon?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type CategoryUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    orderIndex?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    icon?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ServiceDocumentUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceDocumentWhereUniqueInput;
    update: XOR<
      ServiceDocumentUpdateWithoutServiceInput,
      ServiceDocumentUncheckedUpdateWithoutServiceInput
    >;
    create: XOR<
      ServiceDocumentCreateWithoutServiceInput,
      ServiceDocumentUncheckedCreateWithoutServiceInput
    >;
  };

  export type ServiceDocumentUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceDocumentWhereUniqueInput;
    data: XOR<
      ServiceDocumentUpdateWithoutServiceInput,
      ServiceDocumentUncheckedUpdateWithoutServiceInput
    >;
  };

  export type ServiceDocumentUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceDocumentScalarWhereInput;
    data: XOR<
      ServiceDocumentUpdateManyMutationInput,
      ServiceDocumentUncheckedUpdateManyWithoutServiceInput
    >;
  };

  export type ServiceDocumentScalarWhereInput = {
    AND?: ServiceDocumentScalarWhereInput | ServiceDocumentScalarWhereInput[];
    OR?: ServiceDocumentScalarWhereInput[];
    NOT?: ServiceDocumentScalarWhereInput | ServiceDocumentScalarWhereInput[];
    id?: StringFilter<'ServiceDocument'> | string;
    serviceId?: StringFilter<'ServiceDocument'> | string;
    title?: StringFilter<'ServiceDocument'> | string;
    description?: StringNullableFilter<'ServiceDocument'> | string | null;
    required?: BoolFilter<'ServiceDocument'> | boolean;
    showIf?: StringNullableFilter<'ServiceDocument'> | string | null;
    orderIndex?: IntFilter<'ServiceDocument'> | number;
    active?: BoolFilter<'ServiceDocument'> | boolean;
    createdAt?: DateTimeFilter<'ServiceDocument'> | Date | string;
    updatedAt?: DateTimeFilter<'ServiceDocument'> | Date | string;
  };

  export type ServiceVariantUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceVariantWhereUniqueInput;
    update: XOR<
      ServiceVariantUpdateWithoutServiceInput,
      ServiceVariantUncheckedUpdateWithoutServiceInput
    >;
    create: XOR<
      ServiceVariantCreateWithoutServiceInput,
      ServiceVariantUncheckedCreateWithoutServiceInput
    >;
  };

  export type ServiceVariantUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceVariantWhereUniqueInput;
    data: XOR<
      ServiceVariantUpdateWithoutServiceInput,
      ServiceVariantUncheckedUpdateWithoutServiceInput
    >;
  };

  export type ServiceVariantUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceVariantScalarWhereInput;
    data: XOR<
      ServiceVariantUpdateManyMutationInput,
      ServiceVariantUncheckedUpdateManyWithoutServiceInput
    >;
  };

  export type ServiceVariantScalarWhereInput = {
    AND?: ServiceVariantScalarWhereInput | ServiceVariantScalarWhereInput[];
    OR?: ServiceVariantScalarWhereInput[];
    NOT?: ServiceVariantScalarWhereInput | ServiceVariantScalarWhereInput[];
    id?: StringFilter<'ServiceVariant'> | string;
    name?: StringFilter<'ServiceVariant'> | string;
    priceCents?: IntFilter<'ServiceVariant'> | number;
    etaDays?: IntFilter<'ServiceVariant'> | number;
    serviceId?: StringFilter<'ServiceVariant'> | string;
    active?: BoolFilter<'ServiceVariant'> | boolean;
    createdAt?: DateTimeFilter<'ServiceVariant'> | Date | string;
    updatedAt?: DateTimeFilter<'ServiceVariant'> | Date | string;
  };

  export type ServiceFieldUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceFieldWhereUniqueInput;
    update: XOR<
      ServiceFieldUpdateWithoutServiceInput,
      ServiceFieldUncheckedUpdateWithoutServiceInput
    >;
    create: XOR<
      ServiceFieldCreateWithoutServiceInput,
      ServiceFieldUncheckedCreateWithoutServiceInput
    >;
  };

  export type ServiceFieldUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceFieldWhereUniqueInput;
    data: XOR<
      ServiceFieldUpdateWithoutServiceInput,
      ServiceFieldUncheckedUpdateWithoutServiceInput
    >;
  };

  export type ServiceFieldUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceFieldScalarWhereInput;
    data: XOR<
      ServiceFieldUpdateManyMutationInput,
      ServiceFieldUncheckedUpdateManyWithoutServiceInput
    >;
  };

  export type ServiceFieldScalarWhereInput = {
    AND?: ServiceFieldScalarWhereInput | ServiceFieldScalarWhereInput[];
    OR?: ServiceFieldScalarWhereInput[];
    NOT?: ServiceFieldScalarWhereInput | ServiceFieldScalarWhereInput[];
    id?: StringFilter<'ServiceField'> | string;
    serviceId?: StringFilter<'ServiceField'> | string;
    name?: StringFilter<'ServiceField'> | string;
    label?: StringFilter<'ServiceField'> | string;
    type?: StringFilter<'ServiceField'> | string;
    placeholder?: StringNullableFilter<'ServiceField'> | string | null;
    required?: BoolFilter<'ServiceField'> | boolean;
    orderIndex?: IntFilter<'ServiceField'> | number;
    active?: BoolFilter<'ServiceField'> | boolean;
    showIf?: StringNullableFilter<'ServiceField'> | string | null;
    validation?: StringNullableFilter<'ServiceField'> | string | null;
    createdAt?: DateTimeFilter<'ServiceField'> | Date | string;
    updatedAt?: DateTimeFilter<'ServiceField'> | Date | string;
  };

  export type ServiceCreateWithoutFieldsInput = {
    id?: string;
    name: string;
    slug: string;
    description?: string | null;
    icon?: string | null;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    orders?: OrderCreateNestedManyWithoutServiceInput;
    category: CategoryCreateNestedOneWithoutServicesInput;
    documents?: ServiceDocumentCreateNestedManyWithoutServiceInput;
    variants?: ServiceVariantCreateNestedManyWithoutServiceInput;
  };

  export type ServiceUncheckedCreateWithoutFieldsInput = {
    id?: string;
    name: string;
    slug: string;
    description?: string | null;
    icon?: string | null;
    active?: boolean;
    categoryId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    orders?: OrderUncheckedCreateNestedManyWithoutServiceInput;
    documents?: ServiceDocumentUncheckedCreateNestedManyWithoutServiceInput;
    variants?: ServiceVariantUncheckedCreateNestedManyWithoutServiceInput;
  };

  export type ServiceCreateOrConnectWithoutFieldsInput = {
    where: ServiceWhereUniqueInput;
    create: XOR<ServiceCreateWithoutFieldsInput, ServiceUncheckedCreateWithoutFieldsInput>;
  };

  export type ServiceFieldOptionCreateWithoutFieldInput = {
    id?: string;
    value: string;
    label: string;
    orderIndex?: number;
    requiredDocs?: string | null;
    showFields?: string | null;
    createdAt?: Date | string;
  };

  export type ServiceFieldOptionUncheckedCreateWithoutFieldInput = {
    id?: string;
    value: string;
    label: string;
    orderIndex?: number;
    requiredDocs?: string | null;
    showFields?: string | null;
    createdAt?: Date | string;
  };

  export type ServiceFieldOptionCreateOrConnectWithoutFieldInput = {
    where: ServiceFieldOptionWhereUniqueInput;
    create: XOR<
      ServiceFieldOptionCreateWithoutFieldInput,
      ServiceFieldOptionUncheckedCreateWithoutFieldInput
    >;
  };

  export type ServiceFieldOptionCreateManyFieldInputEnvelope = {
    data: ServiceFieldOptionCreateManyFieldInput | ServiceFieldOptionCreateManyFieldInput[];
    skipDuplicates?: boolean;
  };

  export type ServiceUpsertWithoutFieldsInput = {
    update: XOR<ServiceUpdateWithoutFieldsInput, ServiceUncheckedUpdateWithoutFieldsInput>;
    create: XOR<ServiceCreateWithoutFieldsInput, ServiceUncheckedCreateWithoutFieldsInput>;
    where?: ServiceWhereInput;
  };

  export type ServiceUpdateToOneWithWhereWithoutFieldsInput = {
    where?: ServiceWhereInput;
    data: XOR<ServiceUpdateWithoutFieldsInput, ServiceUncheckedUpdateWithoutFieldsInput>;
  };

  export type ServiceUpdateWithoutFieldsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    icon?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    orders?: OrderUpdateManyWithoutServiceNestedInput;
    category?: CategoryUpdateOneRequiredWithoutServicesNestedInput;
    documents?: ServiceDocumentUpdateManyWithoutServiceNestedInput;
    variants?: ServiceVariantUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceUncheckedUpdateWithoutFieldsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    icon?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    categoryId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    orders?: OrderUncheckedUpdateManyWithoutServiceNestedInput;
    documents?: ServiceDocumentUncheckedUpdateManyWithoutServiceNestedInput;
    variants?: ServiceVariantUncheckedUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceFieldOptionUpsertWithWhereUniqueWithoutFieldInput = {
    where: ServiceFieldOptionWhereUniqueInput;
    update: XOR<
      ServiceFieldOptionUpdateWithoutFieldInput,
      ServiceFieldOptionUncheckedUpdateWithoutFieldInput
    >;
    create: XOR<
      ServiceFieldOptionCreateWithoutFieldInput,
      ServiceFieldOptionUncheckedCreateWithoutFieldInput
    >;
  };

  export type ServiceFieldOptionUpdateWithWhereUniqueWithoutFieldInput = {
    where: ServiceFieldOptionWhereUniqueInput;
    data: XOR<
      ServiceFieldOptionUpdateWithoutFieldInput,
      ServiceFieldOptionUncheckedUpdateWithoutFieldInput
    >;
  };

  export type ServiceFieldOptionUpdateManyWithWhereWithoutFieldInput = {
    where: ServiceFieldOptionScalarWhereInput;
    data: XOR<
      ServiceFieldOptionUpdateManyMutationInput,
      ServiceFieldOptionUncheckedUpdateManyWithoutFieldInput
    >;
  };

  export type ServiceFieldOptionScalarWhereInput = {
    AND?: ServiceFieldOptionScalarWhereInput | ServiceFieldOptionScalarWhereInput[];
    OR?: ServiceFieldOptionScalarWhereInput[];
    NOT?: ServiceFieldOptionScalarWhereInput | ServiceFieldOptionScalarWhereInput[];
    id?: StringFilter<'ServiceFieldOption'> | string;
    fieldId?: StringFilter<'ServiceFieldOption'> | string;
    value?: StringFilter<'ServiceFieldOption'> | string;
    label?: StringFilter<'ServiceFieldOption'> | string;
    orderIndex?: IntFilter<'ServiceFieldOption'> | number;
    requiredDocs?: StringNullableFilter<'ServiceFieldOption'> | string | null;
    showFields?: StringNullableFilter<'ServiceFieldOption'> | string | null;
    createdAt?: DateTimeFilter<'ServiceFieldOption'> | Date | string;
  };

  export type ServiceFieldCreateWithoutOptionsInput = {
    id?: string;
    name: string;
    label: string;
    type: string;
    placeholder?: string | null;
    required?: boolean;
    orderIndex?: number;
    active?: boolean;
    showIf?: string | null;
    validation?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    service: ServiceCreateNestedOneWithoutFieldsInput;
  };

  export type ServiceFieldUncheckedCreateWithoutOptionsInput = {
    id?: string;
    serviceId: string;
    name: string;
    label: string;
    type: string;
    placeholder?: string | null;
    required?: boolean;
    orderIndex?: number;
    active?: boolean;
    showIf?: string | null;
    validation?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ServiceFieldCreateOrConnectWithoutOptionsInput = {
    where: ServiceFieldWhereUniqueInput;
    create: XOR<
      ServiceFieldCreateWithoutOptionsInput,
      ServiceFieldUncheckedCreateWithoutOptionsInput
    >;
  };

  export type ServiceFieldUpsertWithoutOptionsInput = {
    update: XOR<
      ServiceFieldUpdateWithoutOptionsInput,
      ServiceFieldUncheckedUpdateWithoutOptionsInput
    >;
    create: XOR<
      ServiceFieldCreateWithoutOptionsInput,
      ServiceFieldUncheckedCreateWithoutOptionsInput
    >;
    where?: ServiceFieldWhereInput;
  };

  export type ServiceFieldUpdateToOneWithWhereWithoutOptionsInput = {
    where?: ServiceFieldWhereInput;
    data: XOR<
      ServiceFieldUpdateWithoutOptionsInput,
      ServiceFieldUncheckedUpdateWithoutOptionsInput
    >;
  };

  export type ServiceFieldUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null;
    required?: BoolFieldUpdateOperationsInput | boolean;
    orderIndex?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    showIf?: NullableStringFieldUpdateOperationsInput | string | null;
    validation?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    service?: ServiceUpdateOneRequiredWithoutFieldsNestedInput;
  };

  export type ServiceFieldUncheckedUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null;
    required?: BoolFieldUpdateOperationsInput | boolean;
    orderIndex?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    showIf?: NullableStringFieldUpdateOperationsInput | string | null;
    validation?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrderCreateWithoutVariantInput = {
    id?: string;
    status?: string;
    totalPrice: number;
    totalCents: number;
    customerName: string;
    customerPhone: string;
    additionalPhone?: string | null;
    customerEmail: string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    notes?: string | null;
    adminNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    completedAt?: Date | string | null;
    estimatedCompletionDate?: Date | string | null;
    deliveryFee?: number;
    deliveryType?: string;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    photographyLocation?: string | null;
    photographyDate?: Date | string | null;
    marriageDate?: Date | string | null;
    divorceDate?: Date | string | null;
    wifeMotherName?: string | null;
    quantity?: number;
    serviceDetails?: string | null;
    otherFees?: number;
    discount?: number;
    gender?: string | null;
    policeStation?: string | null;
    pickupLocation?: string | null;
    originalDocuments?: string | null;
    attachedDocuments?: string | null;
    hasAttachments?: boolean;
    selectedFines?: string | null;
    finesDetails?: string | null;
    servicesDetails?: string | null;
    customerFollowUp?: string | null;
    discountAmount?: number;
    createdByAdmin?: UserCreateNestedOneWithoutCreatedOrdersInput;
    documents?: DocumentCreateNestedManyWithoutOrderInput;
    service: ServiceCreateNestedOneWithoutOrdersInput;
    user: UserCreateNestedOneWithoutOrdersInput;
    orderDocuments?: OrderDocumentCreateNestedManyWithoutOrderInput;
    payment?: PaymentCreateNestedOneWithoutOrderInput;
    formSerials?: FormSerialCreateNestedManyWithoutOrderInput;
    promoCode?: PromoCodeCreateNestedOneWithoutOrdersInput;
  };

  export type OrderUncheckedCreateWithoutVariantInput = {
    id?: string;
    userId: string;
    serviceId: string;
    status?: string;
    totalPrice: number;
    totalCents: number;
    customerName: string;
    customerPhone: string;
    additionalPhone?: string | null;
    customerEmail: string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    notes?: string | null;
    adminNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    completedAt?: Date | string | null;
    estimatedCompletionDate?: Date | string | null;
    deliveryFee?: number;
    deliveryType?: string;
    createdByAdminId?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    photographyLocation?: string | null;
    photographyDate?: Date | string | null;
    marriageDate?: Date | string | null;
    divorceDate?: Date | string | null;
    wifeMotherName?: string | null;
    quantity?: number;
    serviceDetails?: string | null;
    otherFees?: number;
    discount?: number;
    gender?: string | null;
    policeStation?: string | null;
    pickupLocation?: string | null;
    originalDocuments?: string | null;
    attachedDocuments?: string | null;
    hasAttachments?: boolean;
    selectedFines?: string | null;
    finesDetails?: string | null;
    servicesDetails?: string | null;
    customerFollowUp?: string | null;
    promoCodeId?: string | null;
    discountAmount?: number;
    documents?: DocumentUncheckedCreateNestedManyWithoutOrderInput;
    orderDocuments?: OrderDocumentUncheckedCreateNestedManyWithoutOrderInput;
    payment?: PaymentUncheckedCreateNestedOneWithoutOrderInput;
    formSerials?: FormSerialUncheckedCreateNestedManyWithoutOrderInput;
  };

  export type OrderCreateOrConnectWithoutVariantInput = {
    where: OrderWhereUniqueInput;
    create: XOR<OrderCreateWithoutVariantInput, OrderUncheckedCreateWithoutVariantInput>;
  };

  export type OrderCreateManyVariantInputEnvelope = {
    data: OrderCreateManyVariantInput | OrderCreateManyVariantInput[];
    skipDuplicates?: boolean;
  };

  export type ServiceCreateWithoutVariantsInput = {
    id?: string;
    name: string;
    slug: string;
    description?: string | null;
    icon?: string | null;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    orders?: OrderCreateNestedManyWithoutServiceInput;
    category: CategoryCreateNestedOneWithoutServicesInput;
    documents?: ServiceDocumentCreateNestedManyWithoutServiceInput;
    fields?: ServiceFieldCreateNestedManyWithoutServiceInput;
  };

  export type ServiceUncheckedCreateWithoutVariantsInput = {
    id?: string;
    name: string;
    slug: string;
    description?: string | null;
    icon?: string | null;
    active?: boolean;
    categoryId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    orders?: OrderUncheckedCreateNestedManyWithoutServiceInput;
    documents?: ServiceDocumentUncheckedCreateNestedManyWithoutServiceInput;
    fields?: ServiceFieldUncheckedCreateNestedManyWithoutServiceInput;
  };

  export type ServiceCreateOrConnectWithoutVariantsInput = {
    where: ServiceWhereUniqueInput;
    create: XOR<ServiceCreateWithoutVariantsInput, ServiceUncheckedCreateWithoutVariantsInput>;
  };

  export type FormTypeVariantCreateWithoutServiceVariantInput = {
    id?: string;
    createdAt?: Date | string;
    formType: FormTypeCreateNestedOneWithoutVariantLinksInput;
  };

  export type FormTypeVariantUncheckedCreateWithoutServiceVariantInput = {
    id?: string;
    formTypeId: string;
    createdAt?: Date | string;
  };

  export type FormTypeVariantCreateOrConnectWithoutServiceVariantInput = {
    where: FormTypeVariantWhereUniqueInput;
    create: XOR<
      FormTypeVariantCreateWithoutServiceVariantInput,
      FormTypeVariantUncheckedCreateWithoutServiceVariantInput
    >;
  };

  export type FormTypeVariantCreateManyServiceVariantInputEnvelope = {
    data:
      | FormTypeVariantCreateManyServiceVariantInput
      | FormTypeVariantCreateManyServiceVariantInput[];
    skipDuplicates?: boolean;
  };

  export type OrderUpsertWithWhereUniqueWithoutVariantInput = {
    where: OrderWhereUniqueInput;
    update: XOR<OrderUpdateWithoutVariantInput, OrderUncheckedUpdateWithoutVariantInput>;
    create: XOR<OrderCreateWithoutVariantInput, OrderUncheckedCreateWithoutVariantInput>;
  };

  export type OrderUpdateWithWhereUniqueWithoutVariantInput = {
    where: OrderWhereUniqueInput;
    data: XOR<OrderUpdateWithoutVariantInput, OrderUncheckedUpdateWithoutVariantInput>;
  };

  export type OrderUpdateManyWithWhereWithoutVariantInput = {
    where: OrderScalarWhereInput;
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutVariantInput>;
  };

  export type ServiceUpsertWithoutVariantsInput = {
    update: XOR<ServiceUpdateWithoutVariantsInput, ServiceUncheckedUpdateWithoutVariantsInput>;
    create: XOR<ServiceCreateWithoutVariantsInput, ServiceUncheckedCreateWithoutVariantsInput>;
    where?: ServiceWhereInput;
  };

  export type ServiceUpdateToOneWithWhereWithoutVariantsInput = {
    where?: ServiceWhereInput;
    data: XOR<ServiceUpdateWithoutVariantsInput, ServiceUncheckedUpdateWithoutVariantsInput>;
  };

  export type ServiceUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    icon?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    orders?: OrderUpdateManyWithoutServiceNestedInput;
    category?: CategoryUpdateOneRequiredWithoutServicesNestedInput;
    documents?: ServiceDocumentUpdateManyWithoutServiceNestedInput;
    fields?: ServiceFieldUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceUncheckedUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    icon?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    categoryId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    orders?: OrderUncheckedUpdateManyWithoutServiceNestedInput;
    documents?: ServiceDocumentUncheckedUpdateManyWithoutServiceNestedInput;
    fields?: ServiceFieldUncheckedUpdateManyWithoutServiceNestedInput;
  };

  export type FormTypeVariantUpsertWithWhereUniqueWithoutServiceVariantInput = {
    where: FormTypeVariantWhereUniqueInput;
    update: XOR<
      FormTypeVariantUpdateWithoutServiceVariantInput,
      FormTypeVariantUncheckedUpdateWithoutServiceVariantInput
    >;
    create: XOR<
      FormTypeVariantCreateWithoutServiceVariantInput,
      FormTypeVariantUncheckedCreateWithoutServiceVariantInput
    >;
  };

  export type FormTypeVariantUpdateWithWhereUniqueWithoutServiceVariantInput = {
    where: FormTypeVariantWhereUniqueInput;
    data: XOR<
      FormTypeVariantUpdateWithoutServiceVariantInput,
      FormTypeVariantUncheckedUpdateWithoutServiceVariantInput
    >;
  };

  export type FormTypeVariantUpdateManyWithWhereWithoutServiceVariantInput = {
    where: FormTypeVariantScalarWhereInput;
    data: XOR<
      FormTypeVariantUpdateManyMutationInput,
      FormTypeVariantUncheckedUpdateManyWithoutServiceVariantInput
    >;
  };

  export type FormTypeVariantScalarWhereInput = {
    AND?: FormTypeVariantScalarWhereInput | FormTypeVariantScalarWhereInput[];
    OR?: FormTypeVariantScalarWhereInput[];
    NOT?: FormTypeVariantScalarWhereInput | FormTypeVariantScalarWhereInput[];
    id?: StringFilter<'FormTypeVariant'> | string;
    formTypeId?: StringFilter<'FormTypeVariant'> | string;
    serviceVariantId?: StringFilter<'FormTypeVariant'> | string;
    createdAt?: DateTimeFilter<'FormTypeVariant'> | Date | string;
  };

  export type UserCreateWithoutCreatedOrdersInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    passwordHash?: string | null;
    phone?: string | null;
    additionalPhone?: string | null;
    role?: string;
    resetToken?: string | null;
    resetTokenExpiry?: Date | string | null;
    verificationToken?: string | null;
    verificationTokenExpiry?: Date | string | null;
    verificationCode?: string | null;
    verificationCodeExpiry?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    wifeMotherName?: string | null;
    createdByAdmin?: UserCreateNestedOneWithoutCreatedUsersInput;
    createdUsers?: UserCreateNestedManyWithoutCreatedByAdminInput;
    orders?: OrderCreateNestedManyWithoutUserInput;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    addedFormSerials?: FormSerialCreateNestedManyWithoutAddedByAdminInput;
    consumedFormSerials?: FormSerialCreateNestedManyWithoutConsumedByAdminInput;
    createdDependents?: DependentCreateNestedManyWithoutCreatedByAdminInput;
  };

  export type UserUncheckedCreateWithoutCreatedOrdersInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    passwordHash?: string | null;
    phone?: string | null;
    additionalPhone?: string | null;
    role?: string;
    createdByAdminId?: string | null;
    resetToken?: string | null;
    resetTokenExpiry?: Date | string | null;
    verificationToken?: string | null;
    verificationTokenExpiry?: Date | string | null;
    verificationCode?: string | null;
    verificationCodeExpiry?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    wifeMotherName?: string | null;
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByAdminInput;
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    addedFormSerials?: FormSerialUncheckedCreateNestedManyWithoutAddedByAdminInput;
    consumedFormSerials?: FormSerialUncheckedCreateNestedManyWithoutConsumedByAdminInput;
    createdDependents?: DependentUncheckedCreateNestedManyWithoutCreatedByAdminInput;
  };

  export type UserCreateOrConnectWithoutCreatedOrdersInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutCreatedOrdersInput, UserUncheckedCreateWithoutCreatedOrdersInput>;
  };

  export type DocumentCreateWithoutOrderInput = {
    id?: string;
    fileName: string;
    filePath: string;
    fileType: string;
    fileSize: number;
    uploadedAt?: Date | string;
  };

  export type DocumentUncheckedCreateWithoutOrderInput = {
    id?: string;
    fileName: string;
    filePath: string;
    fileType: string;
    fileSize: number;
    uploadedAt?: Date | string;
  };

  export type DocumentCreateOrConnectWithoutOrderInput = {
    where: DocumentWhereUniqueInput;
    create: XOR<DocumentCreateWithoutOrderInput, DocumentUncheckedCreateWithoutOrderInput>;
  };

  export type DocumentCreateManyOrderInputEnvelope = {
    data: DocumentCreateManyOrderInput | DocumentCreateManyOrderInput[];
    skipDuplicates?: boolean;
  };

  export type ServiceCreateWithoutOrdersInput = {
    id?: string;
    name: string;
    slug: string;
    description?: string | null;
    icon?: string | null;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    category: CategoryCreateNestedOneWithoutServicesInput;
    documents?: ServiceDocumentCreateNestedManyWithoutServiceInput;
    variants?: ServiceVariantCreateNestedManyWithoutServiceInput;
    fields?: ServiceFieldCreateNestedManyWithoutServiceInput;
  };

  export type ServiceUncheckedCreateWithoutOrdersInput = {
    id?: string;
    name: string;
    slug: string;
    description?: string | null;
    icon?: string | null;
    active?: boolean;
    categoryId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    documents?: ServiceDocumentUncheckedCreateNestedManyWithoutServiceInput;
    variants?: ServiceVariantUncheckedCreateNestedManyWithoutServiceInput;
    fields?: ServiceFieldUncheckedCreateNestedManyWithoutServiceInput;
  };

  export type ServiceCreateOrConnectWithoutOrdersInput = {
    where: ServiceWhereUniqueInput;
    create: XOR<ServiceCreateWithoutOrdersInput, ServiceUncheckedCreateWithoutOrdersInput>;
  };

  export type UserCreateWithoutOrdersInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    passwordHash?: string | null;
    phone?: string | null;
    additionalPhone?: string | null;
    role?: string;
    resetToken?: string | null;
    resetTokenExpiry?: Date | string | null;
    verificationToken?: string | null;
    verificationTokenExpiry?: Date | string | null;
    verificationCode?: string | null;
    verificationCodeExpiry?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    wifeMotherName?: string | null;
    createdByAdmin?: UserCreateNestedOneWithoutCreatedUsersInput;
    createdUsers?: UserCreateNestedManyWithoutCreatedByAdminInput;
    createdOrders?: OrderCreateNestedManyWithoutCreatedByAdminInput;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    addedFormSerials?: FormSerialCreateNestedManyWithoutAddedByAdminInput;
    consumedFormSerials?: FormSerialCreateNestedManyWithoutConsumedByAdminInput;
    createdDependents?: DependentCreateNestedManyWithoutCreatedByAdminInput;
  };

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    passwordHash?: string | null;
    phone?: string | null;
    additionalPhone?: string | null;
    role?: string;
    createdByAdminId?: string | null;
    resetToken?: string | null;
    resetTokenExpiry?: Date | string | null;
    verificationToken?: string | null;
    verificationTokenExpiry?: Date | string | null;
    verificationCode?: string | null;
    verificationCodeExpiry?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    wifeMotherName?: string | null;
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByAdminInput;
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByAdminInput;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    addedFormSerials?: FormSerialUncheckedCreateNestedManyWithoutAddedByAdminInput;
    consumedFormSerials?: FormSerialUncheckedCreateNestedManyWithoutConsumedByAdminInput;
    createdDependents?: DependentUncheckedCreateNestedManyWithoutCreatedByAdminInput;
  };

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>;
  };

  export type ServiceVariantCreateWithoutOrdersInput = {
    id?: string;
    name: string;
    priceCents: number;
    etaDays: number;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    service: ServiceCreateNestedOneWithoutVariantsInput;
    formTypeLinks?: FormTypeVariantCreateNestedManyWithoutServiceVariantInput;
  };

  export type ServiceVariantUncheckedCreateWithoutOrdersInput = {
    id?: string;
    name: string;
    priceCents: number;
    etaDays: number;
    serviceId: string;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    formTypeLinks?: FormTypeVariantUncheckedCreateNestedManyWithoutServiceVariantInput;
  };

  export type ServiceVariantCreateOrConnectWithoutOrdersInput = {
    where: ServiceVariantWhereUniqueInput;
    create: XOR<
      ServiceVariantCreateWithoutOrdersInput,
      ServiceVariantUncheckedCreateWithoutOrdersInput
    >;
  };

  export type OrderDocumentCreateWithoutOrderInput = {
    id?: string;
    fileName: string;
    filePath: string;
    fileSize: number;
    fileType: string;
    documentType: string;
    uploadedAt?: Date | string;
  };

  export type OrderDocumentUncheckedCreateWithoutOrderInput = {
    id?: string;
    fileName: string;
    filePath: string;
    fileSize: number;
    fileType: string;
    documentType: string;
    uploadedAt?: Date | string;
  };

  export type OrderDocumentCreateOrConnectWithoutOrderInput = {
    where: OrderDocumentWhereUniqueInput;
    create: XOR<
      OrderDocumentCreateWithoutOrderInput,
      OrderDocumentUncheckedCreateWithoutOrderInput
    >;
  };

  export type OrderDocumentCreateManyOrderInputEnvelope = {
    data: OrderDocumentCreateManyOrderInput | OrderDocumentCreateManyOrderInput[];
    skipDuplicates?: boolean;
  };

  export type PaymentCreateWithoutOrderInput = {
    id?: string;
    amount: number;
    currency?: string;
    method: string;
    status?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    paymentScreenshot?: string | null;
    senderPhone?: string | null;
    notes?: string | null;
  };

  export type PaymentUncheckedCreateWithoutOrderInput = {
    id?: string;
    amount: number;
    currency?: string;
    method: string;
    status?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    paymentScreenshot?: string | null;
    senderPhone?: string | null;
    notes?: string | null;
  };

  export type PaymentCreateOrConnectWithoutOrderInput = {
    where: PaymentWhereUniqueInput;
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>;
  };

  export type FormSerialCreateWithoutOrderInput = {
    id?: string;
    serialNumber: string;
    consumed?: boolean;
    consumedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    formType: FormTypeCreateNestedOneWithoutSerialsInput;
    addedByAdmin?: UserCreateNestedOneWithoutAddedFormSerialsInput;
    consumedByAdmin?: UserCreateNestedOneWithoutConsumedFormSerialsInput;
  };

  export type FormSerialUncheckedCreateWithoutOrderInput = {
    id?: string;
    formTypeId: string;
    serialNumber: string;
    consumed?: boolean;
    consumedAt?: Date | string | null;
    addedByAdminId?: string | null;
    consumedByAdminId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FormSerialCreateOrConnectWithoutOrderInput = {
    where: FormSerialWhereUniqueInput;
    create: XOR<FormSerialCreateWithoutOrderInput, FormSerialUncheckedCreateWithoutOrderInput>;
  };

  export type FormSerialCreateManyOrderInputEnvelope = {
    data: FormSerialCreateManyOrderInput | FormSerialCreateManyOrderInput[];
    skipDuplicates?: boolean;
  };

  export type PromoCodeCreateWithoutOrdersInput = {
    id?: string;
    code: string;
    type?: string;
    value: number;
    minOrderAmount?: number | null;
    maxDiscount?: number | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    usageLimit?: number | null;
    currentUsage?: number;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PromoCodeUncheckedCreateWithoutOrdersInput = {
    id?: string;
    code: string;
    type?: string;
    value: number;
    minOrderAmount?: number | null;
    maxDiscount?: number | null;
    startDate?: Date | string | null;
    endDate?: Date | string | null;
    usageLimit?: number | null;
    currentUsage?: number;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PromoCodeCreateOrConnectWithoutOrdersInput = {
    where: PromoCodeWhereUniqueInput;
    create: XOR<PromoCodeCreateWithoutOrdersInput, PromoCodeUncheckedCreateWithoutOrdersInput>;
  };

  export type UserUpsertWithoutCreatedOrdersInput = {
    update: XOR<UserUpdateWithoutCreatedOrdersInput, UserUncheckedUpdateWithoutCreatedOrdersInput>;
    create: XOR<UserCreateWithoutCreatedOrdersInput, UserUncheckedCreateWithoutCreatedOrdersInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutCreatedOrdersInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutCreatedOrdersInput, UserUncheckedUpdateWithoutCreatedOrdersInput>;
  };

  export type UserUpdateWithoutCreatedOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationCodeExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdByAdmin?: UserUpdateOneWithoutCreatedUsersNestedInput;
    createdUsers?: UserUpdateManyWithoutCreatedByAdminNestedInput;
    orders?: OrderUpdateManyWithoutUserNestedInput;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    addedFormSerials?: FormSerialUpdateManyWithoutAddedByAdminNestedInput;
    consumedFormSerials?: FormSerialUpdateManyWithoutConsumedByAdminNestedInput;
    createdDependents?: DependentUpdateManyWithoutCreatedByAdminNestedInput;
  };

  export type UserUncheckedUpdateWithoutCreatedOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationCodeExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByAdminNestedInput;
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    addedFormSerials?: FormSerialUncheckedUpdateManyWithoutAddedByAdminNestedInput;
    consumedFormSerials?: FormSerialUncheckedUpdateManyWithoutConsumedByAdminNestedInput;
    createdDependents?: DependentUncheckedUpdateManyWithoutCreatedByAdminNestedInput;
  };

  export type DocumentUpsertWithWhereUniqueWithoutOrderInput = {
    where: DocumentWhereUniqueInput;
    update: XOR<DocumentUpdateWithoutOrderInput, DocumentUncheckedUpdateWithoutOrderInput>;
    create: XOR<DocumentCreateWithoutOrderInput, DocumentUncheckedCreateWithoutOrderInput>;
  };

  export type DocumentUpdateWithWhereUniqueWithoutOrderInput = {
    where: DocumentWhereUniqueInput;
    data: XOR<DocumentUpdateWithoutOrderInput, DocumentUncheckedUpdateWithoutOrderInput>;
  };

  export type DocumentUpdateManyWithWhereWithoutOrderInput = {
    where: DocumentScalarWhereInput;
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutOrderInput>;
  };

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[];
    OR?: DocumentScalarWhereInput[];
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[];
    id?: StringFilter<'Document'> | string;
    orderId?: StringFilter<'Document'> | string;
    fileName?: StringFilter<'Document'> | string;
    filePath?: StringFilter<'Document'> | string;
    fileType?: StringFilter<'Document'> | string;
    fileSize?: IntFilter<'Document'> | number;
    uploadedAt?: DateTimeFilter<'Document'> | Date | string;
  };

  export type ServiceUpsertWithoutOrdersInput = {
    update: XOR<ServiceUpdateWithoutOrdersInput, ServiceUncheckedUpdateWithoutOrdersInput>;
    create: XOR<ServiceCreateWithoutOrdersInput, ServiceUncheckedCreateWithoutOrdersInput>;
    where?: ServiceWhereInput;
  };

  export type ServiceUpdateToOneWithWhereWithoutOrdersInput = {
    where?: ServiceWhereInput;
    data: XOR<ServiceUpdateWithoutOrdersInput, ServiceUncheckedUpdateWithoutOrdersInput>;
  };

  export type ServiceUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    icon?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    category?: CategoryUpdateOneRequiredWithoutServicesNestedInput;
    documents?: ServiceDocumentUpdateManyWithoutServiceNestedInput;
    variants?: ServiceVariantUpdateManyWithoutServiceNestedInput;
    fields?: ServiceFieldUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    icon?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    categoryId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    documents?: ServiceDocumentUncheckedUpdateManyWithoutServiceNestedInput;
    variants?: ServiceVariantUncheckedUpdateManyWithoutServiceNestedInput;
    fields?: ServiceFieldUncheckedUpdateManyWithoutServiceNestedInput;
  };

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>;
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutOrdersInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>;
  };

  export type UserUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationCodeExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdByAdmin?: UserUpdateOneWithoutCreatedUsersNestedInput;
    createdUsers?: UserUpdateManyWithoutCreatedByAdminNestedInput;
    createdOrders?: OrderUpdateManyWithoutCreatedByAdminNestedInput;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    addedFormSerials?: FormSerialUpdateManyWithoutAddedByAdminNestedInput;
    consumedFormSerials?: FormSerialUpdateManyWithoutConsumedByAdminNestedInput;
    createdDependents?: DependentUpdateManyWithoutCreatedByAdminNestedInput;
  };

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationCodeExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByAdminNestedInput;
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByAdminNestedInput;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    addedFormSerials?: FormSerialUncheckedUpdateManyWithoutAddedByAdminNestedInput;
    consumedFormSerials?: FormSerialUncheckedUpdateManyWithoutConsumedByAdminNestedInput;
    createdDependents?: DependentUncheckedUpdateManyWithoutCreatedByAdminNestedInput;
  };

  export type ServiceVariantUpsertWithoutOrdersInput = {
    update: XOR<
      ServiceVariantUpdateWithoutOrdersInput,
      ServiceVariantUncheckedUpdateWithoutOrdersInput
    >;
    create: XOR<
      ServiceVariantCreateWithoutOrdersInput,
      ServiceVariantUncheckedCreateWithoutOrdersInput
    >;
    where?: ServiceVariantWhereInput;
  };

  export type ServiceVariantUpdateToOneWithWhereWithoutOrdersInput = {
    where?: ServiceVariantWhereInput;
    data: XOR<
      ServiceVariantUpdateWithoutOrdersInput,
      ServiceVariantUncheckedUpdateWithoutOrdersInput
    >;
  };

  export type ServiceVariantUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    priceCents?: IntFieldUpdateOperationsInput | number;
    etaDays?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    service?: ServiceUpdateOneRequiredWithoutVariantsNestedInput;
    formTypeLinks?: FormTypeVariantUpdateManyWithoutServiceVariantNestedInput;
  };

  export type ServiceVariantUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    priceCents?: IntFieldUpdateOperationsInput | number;
    etaDays?: IntFieldUpdateOperationsInput | number;
    serviceId?: StringFieldUpdateOperationsInput | string;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    formTypeLinks?: FormTypeVariantUncheckedUpdateManyWithoutServiceVariantNestedInput;
  };

  export type OrderDocumentUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderDocumentWhereUniqueInput;
    update: XOR<
      OrderDocumentUpdateWithoutOrderInput,
      OrderDocumentUncheckedUpdateWithoutOrderInput
    >;
    create: XOR<
      OrderDocumentCreateWithoutOrderInput,
      OrderDocumentUncheckedCreateWithoutOrderInput
    >;
  };

  export type OrderDocumentUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderDocumentWhereUniqueInput;
    data: XOR<OrderDocumentUpdateWithoutOrderInput, OrderDocumentUncheckedUpdateWithoutOrderInput>;
  };

  export type OrderDocumentUpdateManyWithWhereWithoutOrderInput = {
    where: OrderDocumentScalarWhereInput;
    data: XOR<
      OrderDocumentUpdateManyMutationInput,
      OrderDocumentUncheckedUpdateManyWithoutOrderInput
    >;
  };

  export type OrderDocumentScalarWhereInput = {
    AND?: OrderDocumentScalarWhereInput | OrderDocumentScalarWhereInput[];
    OR?: OrderDocumentScalarWhereInput[];
    NOT?: OrderDocumentScalarWhereInput | OrderDocumentScalarWhereInput[];
    id?: StringFilter<'OrderDocument'> | string;
    orderId?: StringFilter<'OrderDocument'> | string;
    fileName?: StringFilter<'OrderDocument'> | string;
    filePath?: StringFilter<'OrderDocument'> | string;
    fileSize?: IntFilter<'OrderDocument'> | number;
    fileType?: StringFilter<'OrderDocument'> | string;
    documentType?: StringFilter<'OrderDocument'> | string;
    uploadedAt?: DateTimeFilter<'OrderDocument'> | Date | string;
  };

  export type PaymentUpsertWithoutOrderInput = {
    update: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>;
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>;
    where?: PaymentWhereInput;
  };

  export type PaymentUpdateToOneWithWhereWithoutOrderInput = {
    where?: PaymentWhereInput;
    data: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>;
  };

  export type PaymentUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string;
    amount?: IntFieldUpdateOperationsInput | number;
    currency?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    paymentScreenshot?: NullableStringFieldUpdateOperationsInput | string | null;
    senderPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type PaymentUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string;
    amount?: IntFieldUpdateOperationsInput | number;
    currency?: StringFieldUpdateOperationsInput | string;
    method?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    paymentScreenshot?: NullableStringFieldUpdateOperationsInput | string | null;
    senderPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type FormSerialUpsertWithWhereUniqueWithoutOrderInput = {
    where: FormSerialWhereUniqueInput;
    update: XOR<FormSerialUpdateWithoutOrderInput, FormSerialUncheckedUpdateWithoutOrderInput>;
    create: XOR<FormSerialCreateWithoutOrderInput, FormSerialUncheckedCreateWithoutOrderInput>;
  };

  export type FormSerialUpdateWithWhereUniqueWithoutOrderInput = {
    where: FormSerialWhereUniqueInput;
    data: XOR<FormSerialUpdateWithoutOrderInput, FormSerialUncheckedUpdateWithoutOrderInput>;
  };

  export type FormSerialUpdateManyWithWhereWithoutOrderInput = {
    where: FormSerialScalarWhereInput;
    data: XOR<FormSerialUpdateManyMutationInput, FormSerialUncheckedUpdateManyWithoutOrderInput>;
  };

  export type PromoCodeUpsertWithoutOrdersInput = {
    update: XOR<PromoCodeUpdateWithoutOrdersInput, PromoCodeUncheckedUpdateWithoutOrdersInput>;
    create: XOR<PromoCodeCreateWithoutOrdersInput, PromoCodeUncheckedCreateWithoutOrdersInput>;
    where?: PromoCodeWhereInput;
  };

  export type PromoCodeUpdateToOneWithWhereWithoutOrdersInput = {
    where?: PromoCodeWhereInput;
    data: XOR<PromoCodeUpdateWithoutOrdersInput, PromoCodeUncheckedUpdateWithoutOrdersInput>;
  };

  export type PromoCodeUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    value?: IntFieldUpdateOperationsInput | number;
    minOrderAmount?: NullableIntFieldUpdateOperationsInput | number | null;
    maxDiscount?: NullableIntFieldUpdateOperationsInput | number | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null;
    currentUsage?: IntFieldUpdateOperationsInput | number;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PromoCodeUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    value?: IntFieldUpdateOperationsInput | number;
    minOrderAmount?: NullableIntFieldUpdateOperationsInput | number | null;
    maxDiscount?: NullableIntFieldUpdateOperationsInput | number | null;
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null;
    currentUsage?: IntFieldUpdateOperationsInput | number;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrderCreateWithoutPaymentInput = {
    id?: string;
    status?: string;
    totalPrice: number;
    totalCents: number;
    customerName: string;
    customerPhone: string;
    additionalPhone?: string | null;
    customerEmail: string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    notes?: string | null;
    adminNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    completedAt?: Date | string | null;
    estimatedCompletionDate?: Date | string | null;
    deliveryFee?: number;
    deliveryType?: string;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    photographyLocation?: string | null;
    photographyDate?: Date | string | null;
    marriageDate?: Date | string | null;
    divorceDate?: Date | string | null;
    wifeMotherName?: string | null;
    quantity?: number;
    serviceDetails?: string | null;
    otherFees?: number;
    discount?: number;
    gender?: string | null;
    policeStation?: string | null;
    pickupLocation?: string | null;
    originalDocuments?: string | null;
    attachedDocuments?: string | null;
    hasAttachments?: boolean;
    selectedFines?: string | null;
    finesDetails?: string | null;
    servicesDetails?: string | null;
    customerFollowUp?: string | null;
    discountAmount?: number;
    createdByAdmin?: UserCreateNestedOneWithoutCreatedOrdersInput;
    documents?: DocumentCreateNestedManyWithoutOrderInput;
    service: ServiceCreateNestedOneWithoutOrdersInput;
    user: UserCreateNestedOneWithoutOrdersInput;
    variant: ServiceVariantCreateNestedOneWithoutOrdersInput;
    orderDocuments?: OrderDocumentCreateNestedManyWithoutOrderInput;
    formSerials?: FormSerialCreateNestedManyWithoutOrderInput;
    promoCode?: PromoCodeCreateNestedOneWithoutOrdersInput;
  };

  export type OrderUncheckedCreateWithoutPaymentInput = {
    id?: string;
    userId: string;
    serviceId: string;
    variantId: string;
    status?: string;
    totalPrice: number;
    totalCents: number;
    customerName: string;
    customerPhone: string;
    additionalPhone?: string | null;
    customerEmail: string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    notes?: string | null;
    adminNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    completedAt?: Date | string | null;
    estimatedCompletionDate?: Date | string | null;
    deliveryFee?: number;
    deliveryType?: string;
    createdByAdminId?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    photographyLocation?: string | null;
    photographyDate?: Date | string | null;
    marriageDate?: Date | string | null;
    divorceDate?: Date | string | null;
    wifeMotherName?: string | null;
    quantity?: number;
    serviceDetails?: string | null;
    otherFees?: number;
    discount?: number;
    gender?: string | null;
    policeStation?: string | null;
    pickupLocation?: string | null;
    originalDocuments?: string | null;
    attachedDocuments?: string | null;
    hasAttachments?: boolean;
    selectedFines?: string | null;
    finesDetails?: string | null;
    servicesDetails?: string | null;
    customerFollowUp?: string | null;
    promoCodeId?: string | null;
    discountAmount?: number;
    documents?: DocumentUncheckedCreateNestedManyWithoutOrderInput;
    orderDocuments?: OrderDocumentUncheckedCreateNestedManyWithoutOrderInput;
    formSerials?: FormSerialUncheckedCreateNestedManyWithoutOrderInput;
  };

  export type OrderCreateOrConnectWithoutPaymentInput = {
    where: OrderWhereUniqueInput;
    create: XOR<OrderCreateWithoutPaymentInput, OrderUncheckedCreateWithoutPaymentInput>;
  };

  export type OrderUpsertWithoutPaymentInput = {
    update: XOR<OrderUpdateWithoutPaymentInput, OrderUncheckedUpdateWithoutPaymentInput>;
    create: XOR<OrderCreateWithoutPaymentInput, OrderUncheckedCreateWithoutPaymentInput>;
    where?: OrderWhereInput;
  };

  export type OrderUpdateToOneWithWhereWithoutPaymentInput = {
    where?: OrderWhereInput;
    data: XOR<OrderUpdateWithoutPaymentInput, OrderUncheckedUpdateWithoutPaymentInput>;
  };

  export type OrderUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    totalPrice?: IntFieldUpdateOperationsInput | number;
    totalCents?: IntFieldUpdateOperationsInput | number;
    customerName?: StringFieldUpdateOperationsInput | string;
    customerPhone?: StringFieldUpdateOperationsInput | string;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    customerEmail?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveryFee?: IntFieldUpdateOperationsInput | number;
    deliveryType?: StringFieldUpdateOperationsInput | string;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    marriageDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    serviceDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    otherFees?: IntFieldUpdateOperationsInput | number;
    discount?: IntFieldUpdateOperationsInput | number;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    policeStation?: NullableStringFieldUpdateOperationsInput | string | null;
    pickupLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    attachedDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean;
    selectedFines?: NullableStringFieldUpdateOperationsInput | string | null;
    finesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    servicesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    customerFollowUp?: NullableStringFieldUpdateOperationsInput | string | null;
    discountAmount?: IntFieldUpdateOperationsInput | number;
    createdByAdmin?: UserUpdateOneWithoutCreatedOrdersNestedInput;
    documents?: DocumentUpdateManyWithoutOrderNestedInput;
    service?: ServiceUpdateOneRequiredWithoutOrdersNestedInput;
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput;
    variant?: ServiceVariantUpdateOneRequiredWithoutOrdersNestedInput;
    orderDocuments?: OrderDocumentUpdateManyWithoutOrderNestedInput;
    formSerials?: FormSerialUpdateManyWithoutOrderNestedInput;
    promoCode?: PromoCodeUpdateOneWithoutOrdersNestedInput;
  };

  export type OrderUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    variantId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    totalPrice?: IntFieldUpdateOperationsInput | number;
    totalCents?: IntFieldUpdateOperationsInput | number;
    customerName?: StringFieldUpdateOperationsInput | string;
    customerPhone?: StringFieldUpdateOperationsInput | string;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    customerEmail?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveryFee?: IntFieldUpdateOperationsInput | number;
    deliveryType?: StringFieldUpdateOperationsInput | string;
    createdByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    marriageDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    serviceDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    otherFees?: IntFieldUpdateOperationsInput | number;
    discount?: IntFieldUpdateOperationsInput | number;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    policeStation?: NullableStringFieldUpdateOperationsInput | string | null;
    pickupLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    attachedDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean;
    selectedFines?: NullableStringFieldUpdateOperationsInput | string | null;
    finesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    servicesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    customerFollowUp?: NullableStringFieldUpdateOperationsInput | string | null;
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null;
    discountAmount?: IntFieldUpdateOperationsInput | number;
    documents?: DocumentUncheckedUpdateManyWithoutOrderNestedInput;
    orderDocuments?: OrderDocumentUncheckedUpdateManyWithoutOrderNestedInput;
    formSerials?: FormSerialUncheckedUpdateManyWithoutOrderNestedInput;
  };

  export type UserCreateWithoutAuditLogsInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    passwordHash?: string | null;
    phone?: string | null;
    additionalPhone?: string | null;
    role?: string;
    resetToken?: string | null;
    resetTokenExpiry?: Date | string | null;
    verificationToken?: string | null;
    verificationTokenExpiry?: Date | string | null;
    verificationCode?: string | null;
    verificationCodeExpiry?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    wifeMotherName?: string | null;
    createdByAdmin?: UserCreateNestedOneWithoutCreatedUsersInput;
    createdUsers?: UserCreateNestedManyWithoutCreatedByAdminInput;
    createdOrders?: OrderCreateNestedManyWithoutCreatedByAdminInput;
    orders?: OrderCreateNestedManyWithoutUserInput;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    addedFormSerials?: FormSerialCreateNestedManyWithoutAddedByAdminInput;
    consumedFormSerials?: FormSerialCreateNestedManyWithoutConsumedByAdminInput;
    createdDependents?: DependentCreateNestedManyWithoutCreatedByAdminInput;
  };

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    passwordHash?: string | null;
    phone?: string | null;
    additionalPhone?: string | null;
    role?: string;
    createdByAdminId?: string | null;
    resetToken?: string | null;
    resetTokenExpiry?: Date | string | null;
    verificationToken?: string | null;
    verificationTokenExpiry?: Date | string | null;
    verificationCode?: string | null;
    verificationCodeExpiry?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    wifeMotherName?: string | null;
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByAdminInput;
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByAdminInput;
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    addedFormSerials?: FormSerialUncheckedCreateNestedManyWithoutAddedByAdminInput;
    consumedFormSerials?: FormSerialUncheckedCreateNestedManyWithoutConsumedByAdminInput;
    createdDependents?: DependentUncheckedCreateNestedManyWithoutCreatedByAdminInput;
  };

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>;
  };

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>;
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>;
  };

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationCodeExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdByAdmin?: UserUpdateOneWithoutCreatedUsersNestedInput;
    createdUsers?: UserUpdateManyWithoutCreatedByAdminNestedInput;
    createdOrders?: OrderUpdateManyWithoutCreatedByAdminNestedInput;
    orders?: OrderUpdateManyWithoutUserNestedInput;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    addedFormSerials?: FormSerialUpdateManyWithoutAddedByAdminNestedInput;
    consumedFormSerials?: FormSerialUpdateManyWithoutConsumedByAdminNestedInput;
    createdDependents?: DependentUpdateManyWithoutCreatedByAdminNestedInput;
  };

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationCodeExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByAdminNestedInput;
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByAdminNestedInput;
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    addedFormSerials?: FormSerialUncheckedUpdateManyWithoutAddedByAdminNestedInput;
    consumedFormSerials?: FormSerialUncheckedUpdateManyWithoutConsumedByAdminNestedInput;
    createdDependents?: DependentUncheckedUpdateManyWithoutCreatedByAdminNestedInput;
  };

  export type OrderCreateWithoutDocumentsInput = {
    id?: string;
    status?: string;
    totalPrice: number;
    totalCents: number;
    customerName: string;
    customerPhone: string;
    additionalPhone?: string | null;
    customerEmail: string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    notes?: string | null;
    adminNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    completedAt?: Date | string | null;
    estimatedCompletionDate?: Date | string | null;
    deliveryFee?: number;
    deliveryType?: string;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    photographyLocation?: string | null;
    photographyDate?: Date | string | null;
    marriageDate?: Date | string | null;
    divorceDate?: Date | string | null;
    wifeMotherName?: string | null;
    quantity?: number;
    serviceDetails?: string | null;
    otherFees?: number;
    discount?: number;
    gender?: string | null;
    policeStation?: string | null;
    pickupLocation?: string | null;
    originalDocuments?: string | null;
    attachedDocuments?: string | null;
    hasAttachments?: boolean;
    selectedFines?: string | null;
    finesDetails?: string | null;
    servicesDetails?: string | null;
    customerFollowUp?: string | null;
    discountAmount?: number;
    createdByAdmin?: UserCreateNestedOneWithoutCreatedOrdersInput;
    service: ServiceCreateNestedOneWithoutOrdersInput;
    user: UserCreateNestedOneWithoutOrdersInput;
    variant: ServiceVariantCreateNestedOneWithoutOrdersInput;
    orderDocuments?: OrderDocumentCreateNestedManyWithoutOrderInput;
    payment?: PaymentCreateNestedOneWithoutOrderInput;
    formSerials?: FormSerialCreateNestedManyWithoutOrderInput;
    promoCode?: PromoCodeCreateNestedOneWithoutOrdersInput;
  };

  export type OrderUncheckedCreateWithoutDocumentsInput = {
    id?: string;
    userId: string;
    serviceId: string;
    variantId: string;
    status?: string;
    totalPrice: number;
    totalCents: number;
    customerName: string;
    customerPhone: string;
    additionalPhone?: string | null;
    customerEmail: string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    notes?: string | null;
    adminNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    completedAt?: Date | string | null;
    estimatedCompletionDate?: Date | string | null;
    deliveryFee?: number;
    deliveryType?: string;
    createdByAdminId?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    photographyLocation?: string | null;
    photographyDate?: Date | string | null;
    marriageDate?: Date | string | null;
    divorceDate?: Date | string | null;
    wifeMotherName?: string | null;
    quantity?: number;
    serviceDetails?: string | null;
    otherFees?: number;
    discount?: number;
    gender?: string | null;
    policeStation?: string | null;
    pickupLocation?: string | null;
    originalDocuments?: string | null;
    attachedDocuments?: string | null;
    hasAttachments?: boolean;
    selectedFines?: string | null;
    finesDetails?: string | null;
    servicesDetails?: string | null;
    customerFollowUp?: string | null;
    promoCodeId?: string | null;
    discountAmount?: number;
    orderDocuments?: OrderDocumentUncheckedCreateNestedManyWithoutOrderInput;
    payment?: PaymentUncheckedCreateNestedOneWithoutOrderInput;
    formSerials?: FormSerialUncheckedCreateNestedManyWithoutOrderInput;
  };

  export type OrderCreateOrConnectWithoutDocumentsInput = {
    where: OrderWhereUniqueInput;
    create: XOR<OrderCreateWithoutDocumentsInput, OrderUncheckedCreateWithoutDocumentsInput>;
  };

  export type OrderUpsertWithoutDocumentsInput = {
    update: XOR<OrderUpdateWithoutDocumentsInput, OrderUncheckedUpdateWithoutDocumentsInput>;
    create: XOR<OrderCreateWithoutDocumentsInput, OrderUncheckedCreateWithoutDocumentsInput>;
    where?: OrderWhereInput;
  };

  export type OrderUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: OrderWhereInput;
    data: XOR<OrderUpdateWithoutDocumentsInput, OrderUncheckedUpdateWithoutDocumentsInput>;
  };

  export type OrderUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    totalPrice?: IntFieldUpdateOperationsInput | number;
    totalCents?: IntFieldUpdateOperationsInput | number;
    customerName?: StringFieldUpdateOperationsInput | string;
    customerPhone?: StringFieldUpdateOperationsInput | string;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    customerEmail?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveryFee?: IntFieldUpdateOperationsInput | number;
    deliveryType?: StringFieldUpdateOperationsInput | string;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    marriageDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    serviceDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    otherFees?: IntFieldUpdateOperationsInput | number;
    discount?: IntFieldUpdateOperationsInput | number;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    policeStation?: NullableStringFieldUpdateOperationsInput | string | null;
    pickupLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    attachedDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean;
    selectedFines?: NullableStringFieldUpdateOperationsInput | string | null;
    finesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    servicesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    customerFollowUp?: NullableStringFieldUpdateOperationsInput | string | null;
    discountAmount?: IntFieldUpdateOperationsInput | number;
    createdByAdmin?: UserUpdateOneWithoutCreatedOrdersNestedInput;
    service?: ServiceUpdateOneRequiredWithoutOrdersNestedInput;
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput;
    variant?: ServiceVariantUpdateOneRequiredWithoutOrdersNestedInput;
    orderDocuments?: OrderDocumentUpdateManyWithoutOrderNestedInput;
    payment?: PaymentUpdateOneWithoutOrderNestedInput;
    formSerials?: FormSerialUpdateManyWithoutOrderNestedInput;
    promoCode?: PromoCodeUpdateOneWithoutOrdersNestedInput;
  };

  export type OrderUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    variantId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    totalPrice?: IntFieldUpdateOperationsInput | number;
    totalCents?: IntFieldUpdateOperationsInput | number;
    customerName?: StringFieldUpdateOperationsInput | string;
    customerPhone?: StringFieldUpdateOperationsInput | string;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    customerEmail?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveryFee?: IntFieldUpdateOperationsInput | number;
    deliveryType?: StringFieldUpdateOperationsInput | string;
    createdByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    marriageDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    serviceDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    otherFees?: IntFieldUpdateOperationsInput | number;
    discount?: IntFieldUpdateOperationsInput | number;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    policeStation?: NullableStringFieldUpdateOperationsInput | string | null;
    pickupLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    attachedDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean;
    selectedFines?: NullableStringFieldUpdateOperationsInput | string | null;
    finesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    servicesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    customerFollowUp?: NullableStringFieldUpdateOperationsInput | string | null;
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null;
    discountAmount?: IntFieldUpdateOperationsInput | number;
    orderDocuments?: OrderDocumentUncheckedUpdateManyWithoutOrderNestedInput;
    payment?: PaymentUncheckedUpdateOneWithoutOrderNestedInput;
    formSerials?: FormSerialUncheckedUpdateManyWithoutOrderNestedInput;
  };

  export type OrderCreateWithoutOrderDocumentsInput = {
    id?: string;
    status?: string;
    totalPrice: number;
    totalCents: number;
    customerName: string;
    customerPhone: string;
    additionalPhone?: string | null;
    customerEmail: string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    notes?: string | null;
    adminNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    completedAt?: Date | string | null;
    estimatedCompletionDate?: Date | string | null;
    deliveryFee?: number;
    deliveryType?: string;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    photographyLocation?: string | null;
    photographyDate?: Date | string | null;
    marriageDate?: Date | string | null;
    divorceDate?: Date | string | null;
    wifeMotherName?: string | null;
    quantity?: number;
    serviceDetails?: string | null;
    otherFees?: number;
    discount?: number;
    gender?: string | null;
    policeStation?: string | null;
    pickupLocation?: string | null;
    originalDocuments?: string | null;
    attachedDocuments?: string | null;
    hasAttachments?: boolean;
    selectedFines?: string | null;
    finesDetails?: string | null;
    servicesDetails?: string | null;
    customerFollowUp?: string | null;
    discountAmount?: number;
    createdByAdmin?: UserCreateNestedOneWithoutCreatedOrdersInput;
    documents?: DocumentCreateNestedManyWithoutOrderInput;
    service: ServiceCreateNestedOneWithoutOrdersInput;
    user: UserCreateNestedOneWithoutOrdersInput;
    variant: ServiceVariantCreateNestedOneWithoutOrdersInput;
    payment?: PaymentCreateNestedOneWithoutOrderInput;
    formSerials?: FormSerialCreateNestedManyWithoutOrderInput;
    promoCode?: PromoCodeCreateNestedOneWithoutOrdersInput;
  };

  export type OrderUncheckedCreateWithoutOrderDocumentsInput = {
    id?: string;
    userId: string;
    serviceId: string;
    variantId: string;
    status?: string;
    totalPrice: number;
    totalCents: number;
    customerName: string;
    customerPhone: string;
    additionalPhone?: string | null;
    customerEmail: string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    notes?: string | null;
    adminNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    completedAt?: Date | string | null;
    estimatedCompletionDate?: Date | string | null;
    deliveryFee?: number;
    deliveryType?: string;
    createdByAdminId?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    photographyLocation?: string | null;
    photographyDate?: Date | string | null;
    marriageDate?: Date | string | null;
    divorceDate?: Date | string | null;
    wifeMotherName?: string | null;
    quantity?: number;
    serviceDetails?: string | null;
    otherFees?: number;
    discount?: number;
    gender?: string | null;
    policeStation?: string | null;
    pickupLocation?: string | null;
    originalDocuments?: string | null;
    attachedDocuments?: string | null;
    hasAttachments?: boolean;
    selectedFines?: string | null;
    finesDetails?: string | null;
    servicesDetails?: string | null;
    customerFollowUp?: string | null;
    promoCodeId?: string | null;
    discountAmount?: number;
    documents?: DocumentUncheckedCreateNestedManyWithoutOrderInput;
    payment?: PaymentUncheckedCreateNestedOneWithoutOrderInput;
    formSerials?: FormSerialUncheckedCreateNestedManyWithoutOrderInput;
  };

  export type OrderCreateOrConnectWithoutOrderDocumentsInput = {
    where: OrderWhereUniqueInput;
    create: XOR<
      OrderCreateWithoutOrderDocumentsInput,
      OrderUncheckedCreateWithoutOrderDocumentsInput
    >;
  };

  export type OrderUpsertWithoutOrderDocumentsInput = {
    update: XOR<
      OrderUpdateWithoutOrderDocumentsInput,
      OrderUncheckedUpdateWithoutOrderDocumentsInput
    >;
    create: XOR<
      OrderCreateWithoutOrderDocumentsInput,
      OrderUncheckedCreateWithoutOrderDocumentsInput
    >;
    where?: OrderWhereInput;
  };

  export type OrderUpdateToOneWithWhereWithoutOrderDocumentsInput = {
    where?: OrderWhereInput;
    data: XOR<
      OrderUpdateWithoutOrderDocumentsInput,
      OrderUncheckedUpdateWithoutOrderDocumentsInput
    >;
  };

  export type OrderUpdateWithoutOrderDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    totalPrice?: IntFieldUpdateOperationsInput | number;
    totalCents?: IntFieldUpdateOperationsInput | number;
    customerName?: StringFieldUpdateOperationsInput | string;
    customerPhone?: StringFieldUpdateOperationsInput | string;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    customerEmail?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveryFee?: IntFieldUpdateOperationsInput | number;
    deliveryType?: StringFieldUpdateOperationsInput | string;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    marriageDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    serviceDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    otherFees?: IntFieldUpdateOperationsInput | number;
    discount?: IntFieldUpdateOperationsInput | number;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    policeStation?: NullableStringFieldUpdateOperationsInput | string | null;
    pickupLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    attachedDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean;
    selectedFines?: NullableStringFieldUpdateOperationsInput | string | null;
    finesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    servicesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    customerFollowUp?: NullableStringFieldUpdateOperationsInput | string | null;
    discountAmount?: IntFieldUpdateOperationsInput | number;
    createdByAdmin?: UserUpdateOneWithoutCreatedOrdersNestedInput;
    documents?: DocumentUpdateManyWithoutOrderNestedInput;
    service?: ServiceUpdateOneRequiredWithoutOrdersNestedInput;
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput;
    variant?: ServiceVariantUpdateOneRequiredWithoutOrdersNestedInput;
    payment?: PaymentUpdateOneWithoutOrderNestedInput;
    formSerials?: FormSerialUpdateManyWithoutOrderNestedInput;
    promoCode?: PromoCodeUpdateOneWithoutOrdersNestedInput;
  };

  export type OrderUncheckedUpdateWithoutOrderDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    variantId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    totalPrice?: IntFieldUpdateOperationsInput | number;
    totalCents?: IntFieldUpdateOperationsInput | number;
    customerName?: StringFieldUpdateOperationsInput | string;
    customerPhone?: StringFieldUpdateOperationsInput | string;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    customerEmail?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveryFee?: IntFieldUpdateOperationsInput | number;
    deliveryType?: StringFieldUpdateOperationsInput | string;
    createdByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    marriageDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    serviceDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    otherFees?: IntFieldUpdateOperationsInput | number;
    discount?: IntFieldUpdateOperationsInput | number;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    policeStation?: NullableStringFieldUpdateOperationsInput | string | null;
    pickupLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    attachedDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean;
    selectedFines?: NullableStringFieldUpdateOperationsInput | string | null;
    finesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    servicesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    customerFollowUp?: NullableStringFieldUpdateOperationsInput | string | null;
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null;
    discountAmount?: IntFieldUpdateOperationsInput | number;
    documents?: DocumentUncheckedUpdateManyWithoutOrderNestedInput;
    payment?: PaymentUncheckedUpdateOneWithoutOrderNestedInput;
    formSerials?: FormSerialUncheckedUpdateManyWithoutOrderNestedInput;
  };

  export type ServiceCreateWithoutDocumentsInput = {
    id?: string;
    name: string;
    slug: string;
    description?: string | null;
    icon?: string | null;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    orders?: OrderCreateNestedManyWithoutServiceInput;
    category: CategoryCreateNestedOneWithoutServicesInput;
    variants?: ServiceVariantCreateNestedManyWithoutServiceInput;
    fields?: ServiceFieldCreateNestedManyWithoutServiceInput;
  };

  export type ServiceUncheckedCreateWithoutDocumentsInput = {
    id?: string;
    name: string;
    slug: string;
    description?: string | null;
    icon?: string | null;
    active?: boolean;
    categoryId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    orders?: OrderUncheckedCreateNestedManyWithoutServiceInput;
    variants?: ServiceVariantUncheckedCreateNestedManyWithoutServiceInput;
    fields?: ServiceFieldUncheckedCreateNestedManyWithoutServiceInput;
  };

  export type ServiceCreateOrConnectWithoutDocumentsInput = {
    where: ServiceWhereUniqueInput;
    create: XOR<ServiceCreateWithoutDocumentsInput, ServiceUncheckedCreateWithoutDocumentsInput>;
  };

  export type ServiceUpsertWithoutDocumentsInput = {
    update: XOR<ServiceUpdateWithoutDocumentsInput, ServiceUncheckedUpdateWithoutDocumentsInput>;
    create: XOR<ServiceCreateWithoutDocumentsInput, ServiceUncheckedCreateWithoutDocumentsInput>;
    where?: ServiceWhereInput;
  };

  export type ServiceUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: ServiceWhereInput;
    data: XOR<ServiceUpdateWithoutDocumentsInput, ServiceUncheckedUpdateWithoutDocumentsInput>;
  };

  export type ServiceUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    icon?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    orders?: OrderUpdateManyWithoutServiceNestedInput;
    category?: CategoryUpdateOneRequiredWithoutServicesNestedInput;
    variants?: ServiceVariantUpdateManyWithoutServiceNestedInput;
    fields?: ServiceFieldUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    icon?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    categoryId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    orders?: OrderUncheckedUpdateManyWithoutServiceNestedInput;
    variants?: ServiceVariantUncheckedUpdateManyWithoutServiceNestedInput;
    fields?: ServiceFieldUncheckedUpdateManyWithoutServiceNestedInput;
  };

  export type FormTypeVariantCreateWithoutFormTypeInput = {
    id?: string;
    createdAt?: Date | string;
    serviceVariant: ServiceVariantCreateNestedOneWithoutFormTypeLinksInput;
  };

  export type FormTypeVariantUncheckedCreateWithoutFormTypeInput = {
    id?: string;
    serviceVariantId: string;
    createdAt?: Date | string;
  };

  export type FormTypeVariantCreateOrConnectWithoutFormTypeInput = {
    where: FormTypeVariantWhereUniqueInput;
    create: XOR<
      FormTypeVariantCreateWithoutFormTypeInput,
      FormTypeVariantUncheckedCreateWithoutFormTypeInput
    >;
  };

  export type FormTypeVariantCreateManyFormTypeInputEnvelope = {
    data: FormTypeVariantCreateManyFormTypeInput | FormTypeVariantCreateManyFormTypeInput[];
    skipDuplicates?: boolean;
  };

  export type FormSerialCreateWithoutFormTypeInput = {
    id?: string;
    serialNumber: string;
    consumed?: boolean;
    consumedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    order?: OrderCreateNestedOneWithoutFormSerialsInput;
    addedByAdmin?: UserCreateNestedOneWithoutAddedFormSerialsInput;
    consumedByAdmin?: UserCreateNestedOneWithoutConsumedFormSerialsInput;
  };

  export type FormSerialUncheckedCreateWithoutFormTypeInput = {
    id?: string;
    serialNumber: string;
    orderId?: string | null;
    consumed?: boolean;
    consumedAt?: Date | string | null;
    addedByAdminId?: string | null;
    consumedByAdminId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FormSerialCreateOrConnectWithoutFormTypeInput = {
    where: FormSerialWhereUniqueInput;
    create: XOR<
      FormSerialCreateWithoutFormTypeInput,
      FormSerialUncheckedCreateWithoutFormTypeInput
    >;
  };

  export type FormSerialCreateManyFormTypeInputEnvelope = {
    data: FormSerialCreateManyFormTypeInput | FormSerialCreateManyFormTypeInput[];
    skipDuplicates?: boolean;
  };

  export type FormTypeVariantUpsertWithWhereUniqueWithoutFormTypeInput = {
    where: FormTypeVariantWhereUniqueInput;
    update: XOR<
      FormTypeVariantUpdateWithoutFormTypeInput,
      FormTypeVariantUncheckedUpdateWithoutFormTypeInput
    >;
    create: XOR<
      FormTypeVariantCreateWithoutFormTypeInput,
      FormTypeVariantUncheckedCreateWithoutFormTypeInput
    >;
  };

  export type FormTypeVariantUpdateWithWhereUniqueWithoutFormTypeInput = {
    where: FormTypeVariantWhereUniqueInput;
    data: XOR<
      FormTypeVariantUpdateWithoutFormTypeInput,
      FormTypeVariantUncheckedUpdateWithoutFormTypeInput
    >;
  };

  export type FormTypeVariantUpdateManyWithWhereWithoutFormTypeInput = {
    where: FormTypeVariantScalarWhereInput;
    data: XOR<
      FormTypeVariantUpdateManyMutationInput,
      FormTypeVariantUncheckedUpdateManyWithoutFormTypeInput
    >;
  };

  export type FormSerialUpsertWithWhereUniqueWithoutFormTypeInput = {
    where: FormSerialWhereUniqueInput;
    update: XOR<
      FormSerialUpdateWithoutFormTypeInput,
      FormSerialUncheckedUpdateWithoutFormTypeInput
    >;
    create: XOR<
      FormSerialCreateWithoutFormTypeInput,
      FormSerialUncheckedCreateWithoutFormTypeInput
    >;
  };

  export type FormSerialUpdateWithWhereUniqueWithoutFormTypeInput = {
    where: FormSerialWhereUniqueInput;
    data: XOR<FormSerialUpdateWithoutFormTypeInput, FormSerialUncheckedUpdateWithoutFormTypeInput>;
  };

  export type FormSerialUpdateManyWithWhereWithoutFormTypeInput = {
    where: FormSerialScalarWhereInput;
    data: XOR<FormSerialUpdateManyMutationInput, FormSerialUncheckedUpdateManyWithoutFormTypeInput>;
  };

  export type FormTypeCreateWithoutVariantLinksInput = {
    id?: string;
    name: string;
    description?: string | null;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    serials?: FormSerialCreateNestedManyWithoutFormTypeInput;
  };

  export type FormTypeUncheckedCreateWithoutVariantLinksInput = {
    id?: string;
    name: string;
    description?: string | null;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    serials?: FormSerialUncheckedCreateNestedManyWithoutFormTypeInput;
  };

  export type FormTypeCreateOrConnectWithoutVariantLinksInput = {
    where: FormTypeWhereUniqueInput;
    create: XOR<
      FormTypeCreateWithoutVariantLinksInput,
      FormTypeUncheckedCreateWithoutVariantLinksInput
    >;
  };

  export type ServiceVariantCreateWithoutFormTypeLinksInput = {
    id?: string;
    name: string;
    priceCents: number;
    etaDays: number;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    orders?: OrderCreateNestedManyWithoutVariantInput;
    service: ServiceCreateNestedOneWithoutVariantsInput;
  };

  export type ServiceVariantUncheckedCreateWithoutFormTypeLinksInput = {
    id?: string;
    name: string;
    priceCents: number;
    etaDays: number;
    serviceId: string;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    orders?: OrderUncheckedCreateNestedManyWithoutVariantInput;
  };

  export type ServiceVariantCreateOrConnectWithoutFormTypeLinksInput = {
    where: ServiceVariantWhereUniqueInput;
    create: XOR<
      ServiceVariantCreateWithoutFormTypeLinksInput,
      ServiceVariantUncheckedCreateWithoutFormTypeLinksInput
    >;
  };

  export type FormTypeUpsertWithoutVariantLinksInput = {
    update: XOR<
      FormTypeUpdateWithoutVariantLinksInput,
      FormTypeUncheckedUpdateWithoutVariantLinksInput
    >;
    create: XOR<
      FormTypeCreateWithoutVariantLinksInput,
      FormTypeUncheckedCreateWithoutVariantLinksInput
    >;
    where?: FormTypeWhereInput;
  };

  export type FormTypeUpdateToOneWithWhereWithoutVariantLinksInput = {
    where?: FormTypeWhereInput;
    data: XOR<
      FormTypeUpdateWithoutVariantLinksInput,
      FormTypeUncheckedUpdateWithoutVariantLinksInput
    >;
  };

  export type FormTypeUpdateWithoutVariantLinksInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    serials?: FormSerialUpdateManyWithoutFormTypeNestedInput;
  };

  export type FormTypeUncheckedUpdateWithoutVariantLinksInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    serials?: FormSerialUncheckedUpdateManyWithoutFormTypeNestedInput;
  };

  export type ServiceVariantUpsertWithoutFormTypeLinksInput = {
    update: XOR<
      ServiceVariantUpdateWithoutFormTypeLinksInput,
      ServiceVariantUncheckedUpdateWithoutFormTypeLinksInput
    >;
    create: XOR<
      ServiceVariantCreateWithoutFormTypeLinksInput,
      ServiceVariantUncheckedCreateWithoutFormTypeLinksInput
    >;
    where?: ServiceVariantWhereInput;
  };

  export type ServiceVariantUpdateToOneWithWhereWithoutFormTypeLinksInput = {
    where?: ServiceVariantWhereInput;
    data: XOR<
      ServiceVariantUpdateWithoutFormTypeLinksInput,
      ServiceVariantUncheckedUpdateWithoutFormTypeLinksInput
    >;
  };

  export type ServiceVariantUpdateWithoutFormTypeLinksInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    priceCents?: IntFieldUpdateOperationsInput | number;
    etaDays?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    orders?: OrderUpdateManyWithoutVariantNestedInput;
    service?: ServiceUpdateOneRequiredWithoutVariantsNestedInput;
  };

  export type ServiceVariantUncheckedUpdateWithoutFormTypeLinksInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    priceCents?: IntFieldUpdateOperationsInput | number;
    etaDays?: IntFieldUpdateOperationsInput | number;
    serviceId?: StringFieldUpdateOperationsInput | string;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    orders?: OrderUncheckedUpdateManyWithoutVariantNestedInput;
  };

  export type FormTypeCreateWithoutSerialsInput = {
    id?: string;
    name: string;
    description?: string | null;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    variantLinks?: FormTypeVariantCreateNestedManyWithoutFormTypeInput;
  };

  export type FormTypeUncheckedCreateWithoutSerialsInput = {
    id?: string;
    name: string;
    description?: string | null;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    variantLinks?: FormTypeVariantUncheckedCreateNestedManyWithoutFormTypeInput;
  };

  export type FormTypeCreateOrConnectWithoutSerialsInput = {
    where: FormTypeWhereUniqueInput;
    create: XOR<FormTypeCreateWithoutSerialsInput, FormTypeUncheckedCreateWithoutSerialsInput>;
  };

  export type OrderCreateWithoutFormSerialsInput = {
    id?: string;
    status?: string;
    totalPrice: number;
    totalCents: number;
    customerName: string;
    customerPhone: string;
    additionalPhone?: string | null;
    customerEmail: string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    notes?: string | null;
    adminNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    completedAt?: Date | string | null;
    estimatedCompletionDate?: Date | string | null;
    deliveryFee?: number;
    deliveryType?: string;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    photographyLocation?: string | null;
    photographyDate?: Date | string | null;
    marriageDate?: Date | string | null;
    divorceDate?: Date | string | null;
    wifeMotherName?: string | null;
    quantity?: number;
    serviceDetails?: string | null;
    otherFees?: number;
    discount?: number;
    gender?: string | null;
    policeStation?: string | null;
    pickupLocation?: string | null;
    originalDocuments?: string | null;
    attachedDocuments?: string | null;
    hasAttachments?: boolean;
    selectedFines?: string | null;
    finesDetails?: string | null;
    servicesDetails?: string | null;
    customerFollowUp?: string | null;
    discountAmount?: number;
    createdByAdmin?: UserCreateNestedOneWithoutCreatedOrdersInput;
    documents?: DocumentCreateNestedManyWithoutOrderInput;
    service: ServiceCreateNestedOneWithoutOrdersInput;
    user: UserCreateNestedOneWithoutOrdersInput;
    variant: ServiceVariantCreateNestedOneWithoutOrdersInput;
    orderDocuments?: OrderDocumentCreateNestedManyWithoutOrderInput;
    payment?: PaymentCreateNestedOneWithoutOrderInput;
    promoCode?: PromoCodeCreateNestedOneWithoutOrdersInput;
  };

  export type OrderUncheckedCreateWithoutFormSerialsInput = {
    id?: string;
    userId: string;
    serviceId: string;
    variantId: string;
    status?: string;
    totalPrice: number;
    totalCents: number;
    customerName: string;
    customerPhone: string;
    additionalPhone?: string | null;
    customerEmail: string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    notes?: string | null;
    adminNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    completedAt?: Date | string | null;
    estimatedCompletionDate?: Date | string | null;
    deliveryFee?: number;
    deliveryType?: string;
    createdByAdminId?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    photographyLocation?: string | null;
    photographyDate?: Date | string | null;
    marriageDate?: Date | string | null;
    divorceDate?: Date | string | null;
    wifeMotherName?: string | null;
    quantity?: number;
    serviceDetails?: string | null;
    otherFees?: number;
    discount?: number;
    gender?: string | null;
    policeStation?: string | null;
    pickupLocation?: string | null;
    originalDocuments?: string | null;
    attachedDocuments?: string | null;
    hasAttachments?: boolean;
    selectedFines?: string | null;
    finesDetails?: string | null;
    servicesDetails?: string | null;
    customerFollowUp?: string | null;
    promoCodeId?: string | null;
    discountAmount?: number;
    documents?: DocumentUncheckedCreateNestedManyWithoutOrderInput;
    orderDocuments?: OrderDocumentUncheckedCreateNestedManyWithoutOrderInput;
    payment?: PaymentUncheckedCreateNestedOneWithoutOrderInput;
  };

  export type OrderCreateOrConnectWithoutFormSerialsInput = {
    where: OrderWhereUniqueInput;
    create: XOR<OrderCreateWithoutFormSerialsInput, OrderUncheckedCreateWithoutFormSerialsInput>;
  };

  export type UserCreateWithoutAddedFormSerialsInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    passwordHash?: string | null;
    phone?: string | null;
    additionalPhone?: string | null;
    role?: string;
    resetToken?: string | null;
    resetTokenExpiry?: Date | string | null;
    verificationToken?: string | null;
    verificationTokenExpiry?: Date | string | null;
    verificationCode?: string | null;
    verificationCodeExpiry?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    wifeMotherName?: string | null;
    createdByAdmin?: UserCreateNestedOneWithoutCreatedUsersInput;
    createdUsers?: UserCreateNestedManyWithoutCreatedByAdminInput;
    createdOrders?: OrderCreateNestedManyWithoutCreatedByAdminInput;
    orders?: OrderCreateNestedManyWithoutUserInput;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    consumedFormSerials?: FormSerialCreateNestedManyWithoutConsumedByAdminInput;
    createdDependents?: DependentCreateNestedManyWithoutCreatedByAdminInput;
  };

  export type UserUncheckedCreateWithoutAddedFormSerialsInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    passwordHash?: string | null;
    phone?: string | null;
    additionalPhone?: string | null;
    role?: string;
    createdByAdminId?: string | null;
    resetToken?: string | null;
    resetTokenExpiry?: Date | string | null;
    verificationToken?: string | null;
    verificationTokenExpiry?: Date | string | null;
    verificationCode?: string | null;
    verificationCodeExpiry?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    wifeMotherName?: string | null;
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByAdminInput;
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByAdminInput;
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    consumedFormSerials?: FormSerialUncheckedCreateNestedManyWithoutConsumedByAdminInput;
    createdDependents?: DependentUncheckedCreateNestedManyWithoutCreatedByAdminInput;
  };

  export type UserCreateOrConnectWithoutAddedFormSerialsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutAddedFormSerialsInput,
      UserUncheckedCreateWithoutAddedFormSerialsInput
    >;
  };

  export type UserCreateWithoutConsumedFormSerialsInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    passwordHash?: string | null;
    phone?: string | null;
    additionalPhone?: string | null;
    role?: string;
    resetToken?: string | null;
    resetTokenExpiry?: Date | string | null;
    verificationToken?: string | null;
    verificationTokenExpiry?: Date | string | null;
    verificationCode?: string | null;
    verificationCodeExpiry?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    wifeMotherName?: string | null;
    createdByAdmin?: UserCreateNestedOneWithoutCreatedUsersInput;
    createdUsers?: UserCreateNestedManyWithoutCreatedByAdminInput;
    createdOrders?: OrderCreateNestedManyWithoutCreatedByAdminInput;
    orders?: OrderCreateNestedManyWithoutUserInput;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    addedFormSerials?: FormSerialCreateNestedManyWithoutAddedByAdminInput;
    createdDependents?: DependentCreateNestedManyWithoutCreatedByAdminInput;
  };

  export type UserUncheckedCreateWithoutConsumedFormSerialsInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    passwordHash?: string | null;
    phone?: string | null;
    additionalPhone?: string | null;
    role?: string;
    createdByAdminId?: string | null;
    resetToken?: string | null;
    resetTokenExpiry?: Date | string | null;
    verificationToken?: string | null;
    verificationTokenExpiry?: Date | string | null;
    verificationCode?: string | null;
    verificationCodeExpiry?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    wifeMotherName?: string | null;
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByAdminInput;
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByAdminInput;
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    addedFormSerials?: FormSerialUncheckedCreateNestedManyWithoutAddedByAdminInput;
    createdDependents?: DependentUncheckedCreateNestedManyWithoutCreatedByAdminInput;
  };

  export type UserCreateOrConnectWithoutConsumedFormSerialsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutConsumedFormSerialsInput,
      UserUncheckedCreateWithoutConsumedFormSerialsInput
    >;
  };

  export type FormTypeUpsertWithoutSerialsInput = {
    update: XOR<FormTypeUpdateWithoutSerialsInput, FormTypeUncheckedUpdateWithoutSerialsInput>;
    create: XOR<FormTypeCreateWithoutSerialsInput, FormTypeUncheckedCreateWithoutSerialsInput>;
    where?: FormTypeWhereInput;
  };

  export type FormTypeUpdateToOneWithWhereWithoutSerialsInput = {
    where?: FormTypeWhereInput;
    data: XOR<FormTypeUpdateWithoutSerialsInput, FormTypeUncheckedUpdateWithoutSerialsInput>;
  };

  export type FormTypeUpdateWithoutSerialsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    variantLinks?: FormTypeVariantUpdateManyWithoutFormTypeNestedInput;
  };

  export type FormTypeUncheckedUpdateWithoutSerialsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    variantLinks?: FormTypeVariantUncheckedUpdateManyWithoutFormTypeNestedInput;
  };

  export type OrderUpsertWithoutFormSerialsInput = {
    update: XOR<OrderUpdateWithoutFormSerialsInput, OrderUncheckedUpdateWithoutFormSerialsInput>;
    create: XOR<OrderCreateWithoutFormSerialsInput, OrderUncheckedCreateWithoutFormSerialsInput>;
    where?: OrderWhereInput;
  };

  export type OrderUpdateToOneWithWhereWithoutFormSerialsInput = {
    where?: OrderWhereInput;
    data: XOR<OrderUpdateWithoutFormSerialsInput, OrderUncheckedUpdateWithoutFormSerialsInput>;
  };

  export type OrderUpdateWithoutFormSerialsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    totalPrice?: IntFieldUpdateOperationsInput | number;
    totalCents?: IntFieldUpdateOperationsInput | number;
    customerName?: StringFieldUpdateOperationsInput | string;
    customerPhone?: StringFieldUpdateOperationsInput | string;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    customerEmail?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveryFee?: IntFieldUpdateOperationsInput | number;
    deliveryType?: StringFieldUpdateOperationsInput | string;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    marriageDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    serviceDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    otherFees?: IntFieldUpdateOperationsInput | number;
    discount?: IntFieldUpdateOperationsInput | number;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    policeStation?: NullableStringFieldUpdateOperationsInput | string | null;
    pickupLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    attachedDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean;
    selectedFines?: NullableStringFieldUpdateOperationsInput | string | null;
    finesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    servicesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    customerFollowUp?: NullableStringFieldUpdateOperationsInput | string | null;
    discountAmount?: IntFieldUpdateOperationsInput | number;
    createdByAdmin?: UserUpdateOneWithoutCreatedOrdersNestedInput;
    documents?: DocumentUpdateManyWithoutOrderNestedInput;
    service?: ServiceUpdateOneRequiredWithoutOrdersNestedInput;
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput;
    variant?: ServiceVariantUpdateOneRequiredWithoutOrdersNestedInput;
    orderDocuments?: OrderDocumentUpdateManyWithoutOrderNestedInput;
    payment?: PaymentUpdateOneWithoutOrderNestedInput;
    promoCode?: PromoCodeUpdateOneWithoutOrdersNestedInput;
  };

  export type OrderUncheckedUpdateWithoutFormSerialsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    variantId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    totalPrice?: IntFieldUpdateOperationsInput | number;
    totalCents?: IntFieldUpdateOperationsInput | number;
    customerName?: StringFieldUpdateOperationsInput | string;
    customerPhone?: StringFieldUpdateOperationsInput | string;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    customerEmail?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveryFee?: IntFieldUpdateOperationsInput | number;
    deliveryType?: StringFieldUpdateOperationsInput | string;
    createdByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    marriageDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    serviceDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    otherFees?: IntFieldUpdateOperationsInput | number;
    discount?: IntFieldUpdateOperationsInput | number;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    policeStation?: NullableStringFieldUpdateOperationsInput | string | null;
    pickupLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    attachedDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean;
    selectedFines?: NullableStringFieldUpdateOperationsInput | string | null;
    finesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    servicesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    customerFollowUp?: NullableStringFieldUpdateOperationsInput | string | null;
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null;
    discountAmount?: IntFieldUpdateOperationsInput | number;
    documents?: DocumentUncheckedUpdateManyWithoutOrderNestedInput;
    orderDocuments?: OrderDocumentUncheckedUpdateManyWithoutOrderNestedInput;
    payment?: PaymentUncheckedUpdateOneWithoutOrderNestedInput;
  };

  export type UserUpsertWithoutAddedFormSerialsInput = {
    update: XOR<
      UserUpdateWithoutAddedFormSerialsInput,
      UserUncheckedUpdateWithoutAddedFormSerialsInput
    >;
    create: XOR<
      UserCreateWithoutAddedFormSerialsInput,
      UserUncheckedCreateWithoutAddedFormSerialsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutAddedFormSerialsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutAddedFormSerialsInput,
      UserUncheckedUpdateWithoutAddedFormSerialsInput
    >;
  };

  export type UserUpdateWithoutAddedFormSerialsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationCodeExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdByAdmin?: UserUpdateOneWithoutCreatedUsersNestedInput;
    createdUsers?: UserUpdateManyWithoutCreatedByAdminNestedInput;
    createdOrders?: OrderUpdateManyWithoutCreatedByAdminNestedInput;
    orders?: OrderUpdateManyWithoutUserNestedInput;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    consumedFormSerials?: FormSerialUpdateManyWithoutConsumedByAdminNestedInput;
    createdDependents?: DependentUpdateManyWithoutCreatedByAdminNestedInput;
  };

  export type UserUncheckedUpdateWithoutAddedFormSerialsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationCodeExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByAdminNestedInput;
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByAdminNestedInput;
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    consumedFormSerials?: FormSerialUncheckedUpdateManyWithoutConsumedByAdminNestedInput;
    createdDependents?: DependentUncheckedUpdateManyWithoutCreatedByAdminNestedInput;
  };

  export type UserUpsertWithoutConsumedFormSerialsInput = {
    update: XOR<
      UserUpdateWithoutConsumedFormSerialsInput,
      UserUncheckedUpdateWithoutConsumedFormSerialsInput
    >;
    create: XOR<
      UserCreateWithoutConsumedFormSerialsInput,
      UserUncheckedCreateWithoutConsumedFormSerialsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutConsumedFormSerialsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutConsumedFormSerialsInput,
      UserUncheckedUpdateWithoutConsumedFormSerialsInput
    >;
  };

  export type UserUpdateWithoutConsumedFormSerialsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationCodeExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdByAdmin?: UserUpdateOneWithoutCreatedUsersNestedInput;
    createdUsers?: UserUpdateManyWithoutCreatedByAdminNestedInput;
    createdOrders?: OrderUpdateManyWithoutCreatedByAdminNestedInput;
    orders?: OrderUpdateManyWithoutUserNestedInput;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    addedFormSerials?: FormSerialUpdateManyWithoutAddedByAdminNestedInput;
    createdDependents?: DependentUpdateManyWithoutCreatedByAdminNestedInput;
  };

  export type UserUncheckedUpdateWithoutConsumedFormSerialsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationCodeExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByAdminNestedInput;
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByAdminNestedInput;
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    addedFormSerials?: FormSerialUncheckedUpdateManyWithoutAddedByAdminNestedInput;
    createdDependents?: DependentUncheckedUpdateManyWithoutCreatedByAdminNestedInput;
  };

  export type UserCreateWithoutCreatedDependentsInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    passwordHash?: string | null;
    phone?: string | null;
    additionalPhone?: string | null;
    role?: string;
    resetToken?: string | null;
    resetTokenExpiry?: Date | string | null;
    verificationToken?: string | null;
    verificationTokenExpiry?: Date | string | null;
    verificationCode?: string | null;
    verificationCodeExpiry?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    wifeMotherName?: string | null;
    createdByAdmin?: UserCreateNestedOneWithoutCreatedUsersInput;
    createdUsers?: UserCreateNestedManyWithoutCreatedByAdminInput;
    createdOrders?: OrderCreateNestedManyWithoutCreatedByAdminInput;
    orders?: OrderCreateNestedManyWithoutUserInput;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    addedFormSerials?: FormSerialCreateNestedManyWithoutAddedByAdminInput;
    consumedFormSerials?: FormSerialCreateNestedManyWithoutConsumedByAdminInput;
  };

  export type UserUncheckedCreateWithoutCreatedDependentsInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    passwordHash?: string | null;
    phone?: string | null;
    additionalPhone?: string | null;
    role?: string;
    createdByAdminId?: string | null;
    resetToken?: string | null;
    resetTokenExpiry?: Date | string | null;
    verificationToken?: string | null;
    verificationTokenExpiry?: Date | string | null;
    verificationCode?: string | null;
    verificationCodeExpiry?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    wifeMotherName?: string | null;
    createdUsers?: UserUncheckedCreateNestedManyWithoutCreatedByAdminInput;
    createdOrders?: OrderUncheckedCreateNestedManyWithoutCreatedByAdminInput;
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    addedFormSerials?: FormSerialUncheckedCreateNestedManyWithoutAddedByAdminInput;
    consumedFormSerials?: FormSerialUncheckedCreateNestedManyWithoutConsumedByAdminInput;
  };

  export type UserCreateOrConnectWithoutCreatedDependentsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutCreatedDependentsInput,
      UserUncheckedCreateWithoutCreatedDependentsInput
    >;
  };

  export type UserUpsertWithoutCreatedDependentsInput = {
    update: XOR<
      UserUpdateWithoutCreatedDependentsInput,
      UserUncheckedUpdateWithoutCreatedDependentsInput
    >;
    create: XOR<
      UserCreateWithoutCreatedDependentsInput,
      UserUncheckedCreateWithoutCreatedDependentsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutCreatedDependentsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutCreatedDependentsInput,
      UserUncheckedUpdateWithoutCreatedDependentsInput
    >;
  };

  export type UserUpdateWithoutCreatedDependentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationCodeExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdByAdmin?: UserUpdateOneWithoutCreatedUsersNestedInput;
    createdUsers?: UserUpdateManyWithoutCreatedByAdminNestedInput;
    createdOrders?: OrderUpdateManyWithoutCreatedByAdminNestedInput;
    orders?: OrderUpdateManyWithoutUserNestedInput;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    addedFormSerials?: FormSerialUpdateManyWithoutAddedByAdminNestedInput;
    consumedFormSerials?: FormSerialUpdateManyWithoutConsumedByAdminNestedInput;
  };

  export type UserUncheckedUpdateWithoutCreatedDependentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    createdByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationCodeExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByAdminNestedInput;
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByAdminNestedInput;
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    addedFormSerials?: FormSerialUncheckedUpdateManyWithoutAddedByAdminNestedInput;
    consumedFormSerials?: FormSerialUncheckedUpdateManyWithoutConsumedByAdminNestedInput;
  };

  export type OrderCreateWithoutPromoCodeInput = {
    id?: string;
    status?: string;
    totalPrice: number;
    totalCents: number;
    customerName: string;
    customerPhone: string;
    additionalPhone?: string | null;
    customerEmail: string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    notes?: string | null;
    adminNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    completedAt?: Date | string | null;
    estimatedCompletionDate?: Date | string | null;
    deliveryFee?: number;
    deliveryType?: string;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    photographyLocation?: string | null;
    photographyDate?: Date | string | null;
    marriageDate?: Date | string | null;
    divorceDate?: Date | string | null;
    wifeMotherName?: string | null;
    quantity?: number;
    serviceDetails?: string | null;
    otherFees?: number;
    discount?: number;
    gender?: string | null;
    policeStation?: string | null;
    pickupLocation?: string | null;
    originalDocuments?: string | null;
    attachedDocuments?: string | null;
    hasAttachments?: boolean;
    selectedFines?: string | null;
    finesDetails?: string | null;
    servicesDetails?: string | null;
    customerFollowUp?: string | null;
    discountAmount?: number;
    createdByAdmin?: UserCreateNestedOneWithoutCreatedOrdersInput;
    documents?: DocumentCreateNestedManyWithoutOrderInput;
    service: ServiceCreateNestedOneWithoutOrdersInput;
    user: UserCreateNestedOneWithoutOrdersInput;
    variant: ServiceVariantCreateNestedOneWithoutOrdersInput;
    orderDocuments?: OrderDocumentCreateNestedManyWithoutOrderInput;
    payment?: PaymentCreateNestedOneWithoutOrderInput;
    formSerials?: FormSerialCreateNestedManyWithoutOrderInput;
  };

  export type OrderUncheckedCreateWithoutPromoCodeInput = {
    id?: string;
    userId: string;
    serviceId: string;
    variantId: string;
    status?: string;
    totalPrice: number;
    totalCents: number;
    customerName: string;
    customerPhone: string;
    additionalPhone?: string | null;
    customerEmail: string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    notes?: string | null;
    adminNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    completedAt?: Date | string | null;
    estimatedCompletionDate?: Date | string | null;
    deliveryFee?: number;
    deliveryType?: string;
    createdByAdminId?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    photographyLocation?: string | null;
    photographyDate?: Date | string | null;
    marriageDate?: Date | string | null;
    divorceDate?: Date | string | null;
    wifeMotherName?: string | null;
    quantity?: number;
    serviceDetails?: string | null;
    otherFees?: number;
    discount?: number;
    gender?: string | null;
    policeStation?: string | null;
    pickupLocation?: string | null;
    originalDocuments?: string | null;
    attachedDocuments?: string | null;
    hasAttachments?: boolean;
    selectedFines?: string | null;
    finesDetails?: string | null;
    servicesDetails?: string | null;
    customerFollowUp?: string | null;
    discountAmount?: number;
    documents?: DocumentUncheckedCreateNestedManyWithoutOrderInput;
    orderDocuments?: OrderDocumentUncheckedCreateNestedManyWithoutOrderInput;
    payment?: PaymentUncheckedCreateNestedOneWithoutOrderInput;
    formSerials?: FormSerialUncheckedCreateNestedManyWithoutOrderInput;
  };

  export type OrderCreateOrConnectWithoutPromoCodeInput = {
    where: OrderWhereUniqueInput;
    create: XOR<OrderCreateWithoutPromoCodeInput, OrderUncheckedCreateWithoutPromoCodeInput>;
  };

  export type OrderCreateManyPromoCodeInputEnvelope = {
    data: OrderCreateManyPromoCodeInput | OrderCreateManyPromoCodeInput[];
    skipDuplicates?: boolean;
  };

  export type OrderUpsertWithWhereUniqueWithoutPromoCodeInput = {
    where: OrderWhereUniqueInput;
    update: XOR<OrderUpdateWithoutPromoCodeInput, OrderUncheckedUpdateWithoutPromoCodeInput>;
    create: XOR<OrderCreateWithoutPromoCodeInput, OrderUncheckedCreateWithoutPromoCodeInput>;
  };

  export type OrderUpdateWithWhereUniqueWithoutPromoCodeInput = {
    where: OrderWhereUniqueInput;
    data: XOR<OrderUpdateWithoutPromoCodeInput, OrderUncheckedUpdateWithoutPromoCodeInput>;
  };

  export type OrderUpdateManyWithWhereWithoutPromoCodeInput = {
    where: OrderScalarWhereInput;
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutPromoCodeInput>;
  };

  export type UserCreateManyCreatedByAdminInput = {
    id?: string;
    name?: string | null;
    email?: string | null;
    emailVerified?: Date | string | null;
    image?: string | null;
    passwordHash?: string | null;
    phone?: string | null;
    additionalPhone?: string | null;
    role?: string;
    resetToken?: string | null;
    resetTokenExpiry?: Date | string | null;
    verificationToken?: string | null;
    verificationTokenExpiry?: Date | string | null;
    verificationCode?: string | null;
    verificationCodeExpiry?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    wifeMotherName?: string | null;
  };

  export type OrderCreateManyCreatedByAdminInput = {
    id?: string;
    userId: string;
    serviceId: string;
    variantId: string;
    status?: string;
    totalPrice: number;
    totalCents: number;
    customerName: string;
    customerPhone: string;
    additionalPhone?: string | null;
    customerEmail: string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    notes?: string | null;
    adminNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    completedAt?: Date | string | null;
    estimatedCompletionDate?: Date | string | null;
    deliveryFee?: number;
    deliveryType?: string;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    photographyLocation?: string | null;
    photographyDate?: Date | string | null;
    marriageDate?: Date | string | null;
    divorceDate?: Date | string | null;
    wifeMotherName?: string | null;
    quantity?: number;
    serviceDetails?: string | null;
    otherFees?: number;
    discount?: number;
    gender?: string | null;
    policeStation?: string | null;
    pickupLocation?: string | null;
    originalDocuments?: string | null;
    attachedDocuments?: string | null;
    hasAttachments?: boolean;
    selectedFines?: string | null;
    finesDetails?: string | null;
    servicesDetails?: string | null;
    customerFollowUp?: string | null;
    promoCodeId?: string | null;
    discountAmount?: number;
  };

  export type OrderCreateManyUserInput = {
    id?: string;
    serviceId: string;
    variantId: string;
    status?: string;
    totalPrice: number;
    totalCents: number;
    customerName: string;
    customerPhone: string;
    additionalPhone?: string | null;
    customerEmail: string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    notes?: string | null;
    adminNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    completedAt?: Date | string | null;
    estimatedCompletionDate?: Date | string | null;
    deliveryFee?: number;
    deliveryType?: string;
    createdByAdminId?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    photographyLocation?: string | null;
    photographyDate?: Date | string | null;
    marriageDate?: Date | string | null;
    divorceDate?: Date | string | null;
    wifeMotherName?: string | null;
    quantity?: number;
    serviceDetails?: string | null;
    otherFees?: number;
    discount?: number;
    gender?: string | null;
    policeStation?: string | null;
    pickupLocation?: string | null;
    originalDocuments?: string | null;
    attachedDocuments?: string | null;
    hasAttachments?: boolean;
    selectedFines?: string | null;
    finesDetails?: string | null;
    servicesDetails?: string | null;
    customerFollowUp?: string | null;
    promoCodeId?: string | null;
    discountAmount?: number;
  };

  export type AccountCreateManyUserInput = {
    id?: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
  };

  export type AuditLogCreateManyUserInput = {
    id?: string;
    action: string;
    entityType: string;
    entityId?: string | null;
    oldValues?: string | null;
    newValues?: string | null;
    ipAddress?: string | null;
    userAgent?: string | null;
    createdAt?: Date | string;
  };

  export type SessionCreateManyUserInput = {
    id?: string;
    sessionToken: string;
    expires: Date | string;
  };

  export type FormSerialCreateManyAddedByAdminInput = {
    id?: string;
    formTypeId: string;
    serialNumber: string;
    orderId?: string | null;
    consumed?: boolean;
    consumedAt?: Date | string | null;
    consumedByAdminId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FormSerialCreateManyConsumedByAdminInput = {
    id?: string;
    formTypeId: string;
    serialNumber: string;
    orderId?: string | null;
    consumed?: boolean;
    consumedAt?: Date | string | null;
    addedByAdminId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type DependentCreateManyCreatedByAdminInput = {
    id?: string;
    name: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type UserUpdateWithoutCreatedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationCodeExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdUsers?: UserUpdateManyWithoutCreatedByAdminNestedInput;
    createdOrders?: OrderUpdateManyWithoutCreatedByAdminNestedInput;
    orders?: OrderUpdateManyWithoutUserNestedInput;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    addedFormSerials?: FormSerialUpdateManyWithoutAddedByAdminNestedInput;
    consumedFormSerials?: FormSerialUpdateManyWithoutConsumedByAdminNestedInput;
    createdDependents?: DependentUpdateManyWithoutCreatedByAdminNestedInput;
  };

  export type UserUncheckedUpdateWithoutCreatedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationCodeExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    createdUsers?: UserUncheckedUpdateManyWithoutCreatedByAdminNestedInput;
    createdOrders?: OrderUncheckedUpdateManyWithoutCreatedByAdminNestedInput;
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    addedFormSerials?: FormSerialUncheckedUpdateManyWithoutAddedByAdminNestedInput;
    consumedFormSerials?: FormSerialUncheckedUpdateManyWithoutConsumedByAdminNestedInput;
    createdDependents?: DependentUncheckedUpdateManyWithoutCreatedByAdminNestedInput;
  };

  export type UserUncheckedUpdateManyWithoutCreatedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: StringFieldUpdateOperationsInput | string;
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null;
    verificationCodeExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type OrderUpdateWithoutCreatedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    totalPrice?: IntFieldUpdateOperationsInput | number;
    totalCents?: IntFieldUpdateOperationsInput | number;
    customerName?: StringFieldUpdateOperationsInput | string;
    customerPhone?: StringFieldUpdateOperationsInput | string;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    customerEmail?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveryFee?: IntFieldUpdateOperationsInput | number;
    deliveryType?: StringFieldUpdateOperationsInput | string;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    marriageDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    serviceDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    otherFees?: IntFieldUpdateOperationsInput | number;
    discount?: IntFieldUpdateOperationsInput | number;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    policeStation?: NullableStringFieldUpdateOperationsInput | string | null;
    pickupLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    attachedDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean;
    selectedFines?: NullableStringFieldUpdateOperationsInput | string | null;
    finesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    servicesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    customerFollowUp?: NullableStringFieldUpdateOperationsInput | string | null;
    discountAmount?: IntFieldUpdateOperationsInput | number;
    documents?: DocumentUpdateManyWithoutOrderNestedInput;
    service?: ServiceUpdateOneRequiredWithoutOrdersNestedInput;
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput;
    variant?: ServiceVariantUpdateOneRequiredWithoutOrdersNestedInput;
    orderDocuments?: OrderDocumentUpdateManyWithoutOrderNestedInput;
    payment?: PaymentUpdateOneWithoutOrderNestedInput;
    formSerials?: FormSerialUpdateManyWithoutOrderNestedInput;
    promoCode?: PromoCodeUpdateOneWithoutOrdersNestedInput;
  };

  export type OrderUncheckedUpdateWithoutCreatedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    variantId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    totalPrice?: IntFieldUpdateOperationsInput | number;
    totalCents?: IntFieldUpdateOperationsInput | number;
    customerName?: StringFieldUpdateOperationsInput | string;
    customerPhone?: StringFieldUpdateOperationsInput | string;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    customerEmail?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveryFee?: IntFieldUpdateOperationsInput | number;
    deliveryType?: StringFieldUpdateOperationsInput | string;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    marriageDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    serviceDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    otherFees?: IntFieldUpdateOperationsInput | number;
    discount?: IntFieldUpdateOperationsInput | number;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    policeStation?: NullableStringFieldUpdateOperationsInput | string | null;
    pickupLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    attachedDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean;
    selectedFines?: NullableStringFieldUpdateOperationsInput | string | null;
    finesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    servicesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    customerFollowUp?: NullableStringFieldUpdateOperationsInput | string | null;
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null;
    discountAmount?: IntFieldUpdateOperationsInput | number;
    documents?: DocumentUncheckedUpdateManyWithoutOrderNestedInput;
    orderDocuments?: OrderDocumentUncheckedUpdateManyWithoutOrderNestedInput;
    payment?: PaymentUncheckedUpdateOneWithoutOrderNestedInput;
    formSerials?: FormSerialUncheckedUpdateManyWithoutOrderNestedInput;
  };

  export type OrderUncheckedUpdateManyWithoutCreatedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    variantId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    totalPrice?: IntFieldUpdateOperationsInput | number;
    totalCents?: IntFieldUpdateOperationsInput | number;
    customerName?: StringFieldUpdateOperationsInput | string;
    customerPhone?: StringFieldUpdateOperationsInput | string;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    customerEmail?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveryFee?: IntFieldUpdateOperationsInput | number;
    deliveryType?: StringFieldUpdateOperationsInput | string;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    marriageDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    serviceDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    otherFees?: IntFieldUpdateOperationsInput | number;
    discount?: IntFieldUpdateOperationsInput | number;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    policeStation?: NullableStringFieldUpdateOperationsInput | string | null;
    pickupLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    attachedDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean;
    selectedFines?: NullableStringFieldUpdateOperationsInput | string | null;
    finesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    servicesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    customerFollowUp?: NullableStringFieldUpdateOperationsInput | string | null;
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null;
    discountAmount?: IntFieldUpdateOperationsInput | number;
  };

  export type OrderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    totalPrice?: IntFieldUpdateOperationsInput | number;
    totalCents?: IntFieldUpdateOperationsInput | number;
    customerName?: StringFieldUpdateOperationsInput | string;
    customerPhone?: StringFieldUpdateOperationsInput | string;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    customerEmail?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveryFee?: IntFieldUpdateOperationsInput | number;
    deliveryType?: StringFieldUpdateOperationsInput | string;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    marriageDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    serviceDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    otherFees?: IntFieldUpdateOperationsInput | number;
    discount?: IntFieldUpdateOperationsInput | number;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    policeStation?: NullableStringFieldUpdateOperationsInput | string | null;
    pickupLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    attachedDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean;
    selectedFines?: NullableStringFieldUpdateOperationsInput | string | null;
    finesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    servicesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    customerFollowUp?: NullableStringFieldUpdateOperationsInput | string | null;
    discountAmount?: IntFieldUpdateOperationsInput | number;
    createdByAdmin?: UserUpdateOneWithoutCreatedOrdersNestedInput;
    documents?: DocumentUpdateManyWithoutOrderNestedInput;
    service?: ServiceUpdateOneRequiredWithoutOrdersNestedInput;
    variant?: ServiceVariantUpdateOneRequiredWithoutOrdersNestedInput;
    orderDocuments?: OrderDocumentUpdateManyWithoutOrderNestedInput;
    payment?: PaymentUpdateOneWithoutOrderNestedInput;
    formSerials?: FormSerialUpdateManyWithoutOrderNestedInput;
    promoCode?: PromoCodeUpdateOneWithoutOrdersNestedInput;
  };

  export type OrderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    variantId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    totalPrice?: IntFieldUpdateOperationsInput | number;
    totalCents?: IntFieldUpdateOperationsInput | number;
    customerName?: StringFieldUpdateOperationsInput | string;
    customerPhone?: StringFieldUpdateOperationsInput | string;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    customerEmail?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveryFee?: IntFieldUpdateOperationsInput | number;
    deliveryType?: StringFieldUpdateOperationsInput | string;
    createdByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    marriageDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    serviceDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    otherFees?: IntFieldUpdateOperationsInput | number;
    discount?: IntFieldUpdateOperationsInput | number;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    policeStation?: NullableStringFieldUpdateOperationsInput | string | null;
    pickupLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    attachedDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean;
    selectedFines?: NullableStringFieldUpdateOperationsInput | string | null;
    finesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    servicesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    customerFollowUp?: NullableStringFieldUpdateOperationsInput | string | null;
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null;
    discountAmount?: IntFieldUpdateOperationsInput | number;
    documents?: DocumentUncheckedUpdateManyWithoutOrderNestedInput;
    orderDocuments?: OrderDocumentUncheckedUpdateManyWithoutOrderNestedInput;
    payment?: PaymentUncheckedUpdateOneWithoutOrderNestedInput;
    formSerials?: FormSerialUncheckedUpdateManyWithoutOrderNestedInput;
  };

  export type OrderUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    variantId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    totalPrice?: IntFieldUpdateOperationsInput | number;
    totalCents?: IntFieldUpdateOperationsInput | number;
    customerName?: StringFieldUpdateOperationsInput | string;
    customerPhone?: StringFieldUpdateOperationsInput | string;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    customerEmail?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveryFee?: IntFieldUpdateOperationsInput | number;
    deliveryType?: StringFieldUpdateOperationsInput | string;
    createdByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    marriageDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    serviceDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    otherFees?: IntFieldUpdateOperationsInput | number;
    discount?: IntFieldUpdateOperationsInput | number;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    policeStation?: NullableStringFieldUpdateOperationsInput | string | null;
    pickupLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    attachedDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean;
    selectedFines?: NullableStringFieldUpdateOperationsInput | string | null;
    finesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    servicesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    customerFollowUp?: NullableStringFieldUpdateOperationsInput | string | null;
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null;
    discountAmount?: IntFieldUpdateOperationsInput | number;
  };

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    oldValues?: NullableStringFieldUpdateOperationsInput | string | null;
    newValues?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    oldValues?: NullableStringFieldUpdateOperationsInput | string | null;
    newValues?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    oldValues?: NullableStringFieldUpdateOperationsInput | string | null;
    newValues?: NullableStringFieldUpdateOperationsInput | string | null;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FormSerialUpdateWithoutAddedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serialNumber?: StringFieldUpdateOperationsInput | string;
    consumed?: BoolFieldUpdateOperationsInput | boolean;
    consumedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    formType?: FormTypeUpdateOneRequiredWithoutSerialsNestedInput;
    order?: OrderUpdateOneWithoutFormSerialsNestedInput;
    consumedByAdmin?: UserUpdateOneWithoutConsumedFormSerialsNestedInput;
  };

  export type FormSerialUncheckedUpdateWithoutAddedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string;
    formTypeId?: StringFieldUpdateOperationsInput | string;
    serialNumber?: StringFieldUpdateOperationsInput | string;
    orderId?: NullableStringFieldUpdateOperationsInput | string | null;
    consumed?: BoolFieldUpdateOperationsInput | boolean;
    consumedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    consumedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FormSerialUncheckedUpdateManyWithoutAddedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string;
    formTypeId?: StringFieldUpdateOperationsInput | string;
    serialNumber?: StringFieldUpdateOperationsInput | string;
    orderId?: NullableStringFieldUpdateOperationsInput | string | null;
    consumed?: BoolFieldUpdateOperationsInput | boolean;
    consumedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    consumedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FormSerialUpdateWithoutConsumedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serialNumber?: StringFieldUpdateOperationsInput | string;
    consumed?: BoolFieldUpdateOperationsInput | boolean;
    consumedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    formType?: FormTypeUpdateOneRequiredWithoutSerialsNestedInput;
    order?: OrderUpdateOneWithoutFormSerialsNestedInput;
    addedByAdmin?: UserUpdateOneWithoutAddedFormSerialsNestedInput;
  };

  export type FormSerialUncheckedUpdateWithoutConsumedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string;
    formTypeId?: StringFieldUpdateOperationsInput | string;
    serialNumber?: StringFieldUpdateOperationsInput | string;
    orderId?: NullableStringFieldUpdateOperationsInput | string | null;
    consumed?: BoolFieldUpdateOperationsInput | boolean;
    consumedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    addedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FormSerialUncheckedUpdateManyWithoutConsumedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string;
    formTypeId?: StringFieldUpdateOperationsInput | string;
    serialNumber?: StringFieldUpdateOperationsInput | string;
    orderId?: NullableStringFieldUpdateOperationsInput | string | null;
    consumed?: BoolFieldUpdateOperationsInput | boolean;
    consumedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    addedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DependentUpdateWithoutCreatedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DependentUncheckedUpdateWithoutCreatedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DependentUncheckedUpdateManyWithoutCreatedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ServiceCreateManyCategoryInput = {
    id?: string;
    name: string;
    slug: string;
    description?: string | null;
    icon?: string | null;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ServiceUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    icon?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    orders?: OrderUpdateManyWithoutServiceNestedInput;
    documents?: ServiceDocumentUpdateManyWithoutServiceNestedInput;
    variants?: ServiceVariantUpdateManyWithoutServiceNestedInput;
    fields?: ServiceFieldUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    icon?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    orders?: OrderUncheckedUpdateManyWithoutServiceNestedInput;
    documents?: ServiceDocumentUncheckedUpdateManyWithoutServiceNestedInput;
    variants?: ServiceVariantUncheckedUpdateManyWithoutServiceNestedInput;
    fields?: ServiceFieldUncheckedUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    icon?: NullableStringFieldUpdateOperationsInput | string | null;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrderCreateManyServiceInput = {
    id?: string;
    userId: string;
    variantId: string;
    status?: string;
    totalPrice: number;
    totalCents: number;
    customerName: string;
    customerPhone: string;
    additionalPhone?: string | null;
    customerEmail: string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    notes?: string | null;
    adminNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    completedAt?: Date | string | null;
    estimatedCompletionDate?: Date | string | null;
    deliveryFee?: number;
    deliveryType?: string;
    createdByAdminId?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    photographyLocation?: string | null;
    photographyDate?: Date | string | null;
    marriageDate?: Date | string | null;
    divorceDate?: Date | string | null;
    wifeMotherName?: string | null;
    quantity?: number;
    serviceDetails?: string | null;
    otherFees?: number;
    discount?: number;
    gender?: string | null;
    policeStation?: string | null;
    pickupLocation?: string | null;
    originalDocuments?: string | null;
    attachedDocuments?: string | null;
    hasAttachments?: boolean;
    selectedFines?: string | null;
    finesDetails?: string | null;
    servicesDetails?: string | null;
    customerFollowUp?: string | null;
    promoCodeId?: string | null;
    discountAmount?: number;
  };

  export type ServiceDocumentCreateManyServiceInput = {
    id?: string;
    title: string;
    description?: string | null;
    required?: boolean;
    showIf?: string | null;
    orderIndex?: number;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ServiceVariantCreateManyServiceInput = {
    id?: string;
    name: string;
    priceCents: number;
    etaDays: number;
    active?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ServiceFieldCreateManyServiceInput = {
    id?: string;
    name: string;
    label: string;
    type: string;
    placeholder?: string | null;
    required?: boolean;
    orderIndex?: number;
    active?: boolean;
    showIf?: string | null;
    validation?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type OrderUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    totalPrice?: IntFieldUpdateOperationsInput | number;
    totalCents?: IntFieldUpdateOperationsInput | number;
    customerName?: StringFieldUpdateOperationsInput | string;
    customerPhone?: StringFieldUpdateOperationsInput | string;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    customerEmail?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveryFee?: IntFieldUpdateOperationsInput | number;
    deliveryType?: StringFieldUpdateOperationsInput | string;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    marriageDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    serviceDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    otherFees?: IntFieldUpdateOperationsInput | number;
    discount?: IntFieldUpdateOperationsInput | number;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    policeStation?: NullableStringFieldUpdateOperationsInput | string | null;
    pickupLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    attachedDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean;
    selectedFines?: NullableStringFieldUpdateOperationsInput | string | null;
    finesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    servicesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    customerFollowUp?: NullableStringFieldUpdateOperationsInput | string | null;
    discountAmount?: IntFieldUpdateOperationsInput | number;
    createdByAdmin?: UserUpdateOneWithoutCreatedOrdersNestedInput;
    documents?: DocumentUpdateManyWithoutOrderNestedInput;
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput;
    variant?: ServiceVariantUpdateOneRequiredWithoutOrdersNestedInput;
    orderDocuments?: OrderDocumentUpdateManyWithoutOrderNestedInput;
    payment?: PaymentUpdateOneWithoutOrderNestedInput;
    formSerials?: FormSerialUpdateManyWithoutOrderNestedInput;
    promoCode?: PromoCodeUpdateOneWithoutOrdersNestedInput;
  };

  export type OrderUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    variantId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    totalPrice?: IntFieldUpdateOperationsInput | number;
    totalCents?: IntFieldUpdateOperationsInput | number;
    customerName?: StringFieldUpdateOperationsInput | string;
    customerPhone?: StringFieldUpdateOperationsInput | string;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    customerEmail?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveryFee?: IntFieldUpdateOperationsInput | number;
    deliveryType?: StringFieldUpdateOperationsInput | string;
    createdByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    marriageDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    serviceDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    otherFees?: IntFieldUpdateOperationsInput | number;
    discount?: IntFieldUpdateOperationsInput | number;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    policeStation?: NullableStringFieldUpdateOperationsInput | string | null;
    pickupLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    attachedDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean;
    selectedFines?: NullableStringFieldUpdateOperationsInput | string | null;
    finesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    servicesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    customerFollowUp?: NullableStringFieldUpdateOperationsInput | string | null;
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null;
    discountAmount?: IntFieldUpdateOperationsInput | number;
    documents?: DocumentUncheckedUpdateManyWithoutOrderNestedInput;
    orderDocuments?: OrderDocumentUncheckedUpdateManyWithoutOrderNestedInput;
    payment?: PaymentUncheckedUpdateOneWithoutOrderNestedInput;
    formSerials?: FormSerialUncheckedUpdateManyWithoutOrderNestedInput;
  };

  export type OrderUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    variantId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    totalPrice?: IntFieldUpdateOperationsInput | number;
    totalCents?: IntFieldUpdateOperationsInput | number;
    customerName?: StringFieldUpdateOperationsInput | string;
    customerPhone?: StringFieldUpdateOperationsInput | string;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    customerEmail?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveryFee?: IntFieldUpdateOperationsInput | number;
    deliveryType?: StringFieldUpdateOperationsInput | string;
    createdByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    marriageDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    serviceDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    otherFees?: IntFieldUpdateOperationsInput | number;
    discount?: IntFieldUpdateOperationsInput | number;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    policeStation?: NullableStringFieldUpdateOperationsInput | string | null;
    pickupLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    attachedDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean;
    selectedFines?: NullableStringFieldUpdateOperationsInput | string | null;
    finesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    servicesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    customerFollowUp?: NullableStringFieldUpdateOperationsInput | string | null;
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null;
    discountAmount?: IntFieldUpdateOperationsInput | number;
  };

  export type ServiceDocumentUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    required?: BoolFieldUpdateOperationsInput | boolean;
    showIf?: NullableStringFieldUpdateOperationsInput | string | null;
    orderIndex?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ServiceDocumentUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    required?: BoolFieldUpdateOperationsInput | boolean;
    showIf?: NullableStringFieldUpdateOperationsInput | string | null;
    orderIndex?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ServiceDocumentUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    required?: BoolFieldUpdateOperationsInput | boolean;
    showIf?: NullableStringFieldUpdateOperationsInput | string | null;
    orderIndex?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ServiceVariantUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    priceCents?: IntFieldUpdateOperationsInput | number;
    etaDays?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    orders?: OrderUpdateManyWithoutVariantNestedInput;
    formTypeLinks?: FormTypeVariantUpdateManyWithoutServiceVariantNestedInput;
  };

  export type ServiceVariantUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    priceCents?: IntFieldUpdateOperationsInput | number;
    etaDays?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    orders?: OrderUncheckedUpdateManyWithoutVariantNestedInput;
    formTypeLinks?: FormTypeVariantUncheckedUpdateManyWithoutServiceVariantNestedInput;
  };

  export type ServiceVariantUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    priceCents?: IntFieldUpdateOperationsInput | number;
    etaDays?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ServiceFieldUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null;
    required?: BoolFieldUpdateOperationsInput | boolean;
    orderIndex?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    showIf?: NullableStringFieldUpdateOperationsInput | string | null;
    validation?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    options?: ServiceFieldOptionUpdateManyWithoutFieldNestedInput;
  };

  export type ServiceFieldUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null;
    required?: BoolFieldUpdateOperationsInput | boolean;
    orderIndex?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    showIf?: NullableStringFieldUpdateOperationsInput | string | null;
    validation?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    options?: ServiceFieldOptionUncheckedUpdateManyWithoutFieldNestedInput;
  };

  export type ServiceFieldUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    label?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null;
    required?: BoolFieldUpdateOperationsInput | boolean;
    orderIndex?: IntFieldUpdateOperationsInput | number;
    active?: BoolFieldUpdateOperationsInput | boolean;
    showIf?: NullableStringFieldUpdateOperationsInput | string | null;
    validation?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ServiceFieldOptionCreateManyFieldInput = {
    id?: string;
    value: string;
    label: string;
    orderIndex?: number;
    requiredDocs?: string | null;
    showFields?: string | null;
    createdAt?: Date | string;
  };

  export type ServiceFieldOptionUpdateWithoutFieldInput = {
    id?: StringFieldUpdateOperationsInput | string;
    value?: StringFieldUpdateOperationsInput | string;
    label?: StringFieldUpdateOperationsInput | string;
    orderIndex?: IntFieldUpdateOperationsInput | number;
    requiredDocs?: NullableStringFieldUpdateOperationsInput | string | null;
    showFields?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ServiceFieldOptionUncheckedUpdateWithoutFieldInput = {
    id?: StringFieldUpdateOperationsInput | string;
    value?: StringFieldUpdateOperationsInput | string;
    label?: StringFieldUpdateOperationsInput | string;
    orderIndex?: IntFieldUpdateOperationsInput | number;
    requiredDocs?: NullableStringFieldUpdateOperationsInput | string | null;
    showFields?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ServiceFieldOptionUncheckedUpdateManyWithoutFieldInput = {
    id?: StringFieldUpdateOperationsInput | string;
    value?: StringFieldUpdateOperationsInput | string;
    label?: StringFieldUpdateOperationsInput | string;
    orderIndex?: IntFieldUpdateOperationsInput | number;
    requiredDocs?: NullableStringFieldUpdateOperationsInput | string | null;
    showFields?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrderCreateManyVariantInput = {
    id?: string;
    userId: string;
    serviceId: string;
    status?: string;
    totalPrice: number;
    totalCents: number;
    customerName: string;
    customerPhone: string;
    additionalPhone?: string | null;
    customerEmail: string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    notes?: string | null;
    adminNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    completedAt?: Date | string | null;
    estimatedCompletionDate?: Date | string | null;
    deliveryFee?: number;
    deliveryType?: string;
    createdByAdminId?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    photographyLocation?: string | null;
    photographyDate?: Date | string | null;
    marriageDate?: Date | string | null;
    divorceDate?: Date | string | null;
    wifeMotherName?: string | null;
    quantity?: number;
    serviceDetails?: string | null;
    otherFees?: number;
    discount?: number;
    gender?: string | null;
    policeStation?: string | null;
    pickupLocation?: string | null;
    originalDocuments?: string | null;
    attachedDocuments?: string | null;
    hasAttachments?: boolean;
    selectedFines?: string | null;
    finesDetails?: string | null;
    servicesDetails?: string | null;
    customerFollowUp?: string | null;
    promoCodeId?: string | null;
    discountAmount?: number;
  };

  export type FormTypeVariantCreateManyServiceVariantInput = {
    id?: string;
    formTypeId: string;
    createdAt?: Date | string;
  };

  export type OrderUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    totalPrice?: IntFieldUpdateOperationsInput | number;
    totalCents?: IntFieldUpdateOperationsInput | number;
    customerName?: StringFieldUpdateOperationsInput | string;
    customerPhone?: StringFieldUpdateOperationsInput | string;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    customerEmail?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveryFee?: IntFieldUpdateOperationsInput | number;
    deliveryType?: StringFieldUpdateOperationsInput | string;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    marriageDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    serviceDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    otherFees?: IntFieldUpdateOperationsInput | number;
    discount?: IntFieldUpdateOperationsInput | number;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    policeStation?: NullableStringFieldUpdateOperationsInput | string | null;
    pickupLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    attachedDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean;
    selectedFines?: NullableStringFieldUpdateOperationsInput | string | null;
    finesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    servicesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    customerFollowUp?: NullableStringFieldUpdateOperationsInput | string | null;
    discountAmount?: IntFieldUpdateOperationsInput | number;
    createdByAdmin?: UserUpdateOneWithoutCreatedOrdersNestedInput;
    documents?: DocumentUpdateManyWithoutOrderNestedInput;
    service?: ServiceUpdateOneRequiredWithoutOrdersNestedInput;
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput;
    orderDocuments?: OrderDocumentUpdateManyWithoutOrderNestedInput;
    payment?: PaymentUpdateOneWithoutOrderNestedInput;
    formSerials?: FormSerialUpdateManyWithoutOrderNestedInput;
    promoCode?: PromoCodeUpdateOneWithoutOrdersNestedInput;
  };

  export type OrderUncheckedUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    totalPrice?: IntFieldUpdateOperationsInput | number;
    totalCents?: IntFieldUpdateOperationsInput | number;
    customerName?: StringFieldUpdateOperationsInput | string;
    customerPhone?: StringFieldUpdateOperationsInput | string;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    customerEmail?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveryFee?: IntFieldUpdateOperationsInput | number;
    deliveryType?: StringFieldUpdateOperationsInput | string;
    createdByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    marriageDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    serviceDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    otherFees?: IntFieldUpdateOperationsInput | number;
    discount?: IntFieldUpdateOperationsInput | number;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    policeStation?: NullableStringFieldUpdateOperationsInput | string | null;
    pickupLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    attachedDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean;
    selectedFines?: NullableStringFieldUpdateOperationsInput | string | null;
    finesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    servicesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    customerFollowUp?: NullableStringFieldUpdateOperationsInput | string | null;
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null;
    discountAmount?: IntFieldUpdateOperationsInput | number;
    documents?: DocumentUncheckedUpdateManyWithoutOrderNestedInput;
    orderDocuments?: OrderDocumentUncheckedUpdateManyWithoutOrderNestedInput;
    payment?: PaymentUncheckedUpdateOneWithoutOrderNestedInput;
    formSerials?: FormSerialUncheckedUpdateManyWithoutOrderNestedInput;
  };

  export type OrderUncheckedUpdateManyWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    totalPrice?: IntFieldUpdateOperationsInput | number;
    totalCents?: IntFieldUpdateOperationsInput | number;
    customerName?: StringFieldUpdateOperationsInput | string;
    customerPhone?: StringFieldUpdateOperationsInput | string;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    customerEmail?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveryFee?: IntFieldUpdateOperationsInput | number;
    deliveryType?: StringFieldUpdateOperationsInput | string;
    createdByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    marriageDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    serviceDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    otherFees?: IntFieldUpdateOperationsInput | number;
    discount?: IntFieldUpdateOperationsInput | number;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    policeStation?: NullableStringFieldUpdateOperationsInput | string | null;
    pickupLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    attachedDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean;
    selectedFines?: NullableStringFieldUpdateOperationsInput | string | null;
    finesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    servicesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    customerFollowUp?: NullableStringFieldUpdateOperationsInput | string | null;
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null;
    discountAmount?: IntFieldUpdateOperationsInput | number;
  };

  export type FormTypeVariantUpdateWithoutServiceVariantInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    formType?: FormTypeUpdateOneRequiredWithoutVariantLinksNestedInput;
  };

  export type FormTypeVariantUncheckedUpdateWithoutServiceVariantInput = {
    id?: StringFieldUpdateOperationsInput | string;
    formTypeId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FormTypeVariantUncheckedUpdateManyWithoutServiceVariantInput = {
    id?: StringFieldUpdateOperationsInput | string;
    formTypeId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DocumentCreateManyOrderInput = {
    id?: string;
    fileName: string;
    filePath: string;
    fileType: string;
    fileSize: number;
    uploadedAt?: Date | string;
  };

  export type OrderDocumentCreateManyOrderInput = {
    id?: string;
    fileName: string;
    filePath: string;
    fileSize: number;
    fileType: string;
    documentType: string;
    uploadedAt?: Date | string;
  };

  export type FormSerialCreateManyOrderInput = {
    id?: string;
    formTypeId: string;
    serialNumber: string;
    consumed?: boolean;
    consumedAt?: Date | string | null;
    addedByAdminId?: string | null;
    consumedByAdminId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type DocumentUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fileName?: StringFieldUpdateOperationsInput | string;
    filePath?: StringFieldUpdateOperationsInput | string;
    fileType?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DocumentUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fileName?: StringFieldUpdateOperationsInput | string;
    filePath?: StringFieldUpdateOperationsInput | string;
    fileType?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DocumentUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fileName?: StringFieldUpdateOperationsInput | string;
    filePath?: StringFieldUpdateOperationsInput | string;
    fileType?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrderDocumentUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fileName?: StringFieldUpdateOperationsInput | string;
    filePath?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    fileType?: StringFieldUpdateOperationsInput | string;
    documentType?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrderDocumentUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fileName?: StringFieldUpdateOperationsInput | string;
    filePath?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    fileType?: StringFieldUpdateOperationsInput | string;
    documentType?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrderDocumentUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fileName?: StringFieldUpdateOperationsInput | string;
    filePath?: StringFieldUpdateOperationsInput | string;
    fileSize?: IntFieldUpdateOperationsInput | number;
    fileType?: StringFieldUpdateOperationsInput | string;
    documentType?: StringFieldUpdateOperationsInput | string;
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FormSerialUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serialNumber?: StringFieldUpdateOperationsInput | string;
    consumed?: BoolFieldUpdateOperationsInput | boolean;
    consumedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    formType?: FormTypeUpdateOneRequiredWithoutSerialsNestedInput;
    addedByAdmin?: UserUpdateOneWithoutAddedFormSerialsNestedInput;
    consumedByAdmin?: UserUpdateOneWithoutConsumedFormSerialsNestedInput;
  };

  export type FormSerialUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string;
    formTypeId?: StringFieldUpdateOperationsInput | string;
    serialNumber?: StringFieldUpdateOperationsInput | string;
    consumed?: BoolFieldUpdateOperationsInput | boolean;
    consumedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    addedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    consumedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FormSerialUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string;
    formTypeId?: StringFieldUpdateOperationsInput | string;
    serialNumber?: StringFieldUpdateOperationsInput | string;
    consumed?: BoolFieldUpdateOperationsInput | boolean;
    consumedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    addedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    consumedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FormTypeVariantCreateManyFormTypeInput = {
    id?: string;
    serviceVariantId: string;
    createdAt?: Date | string;
  };

  export type FormSerialCreateManyFormTypeInput = {
    id?: string;
    serialNumber: string;
    orderId?: string | null;
    consumed?: boolean;
    consumedAt?: Date | string | null;
    addedByAdminId?: string | null;
    consumedByAdminId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FormTypeVariantUpdateWithoutFormTypeInput = {
    id?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    serviceVariant?: ServiceVariantUpdateOneRequiredWithoutFormTypeLinksNestedInput;
  };

  export type FormTypeVariantUncheckedUpdateWithoutFormTypeInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceVariantId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FormTypeVariantUncheckedUpdateManyWithoutFormTypeInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serviceVariantId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FormSerialUpdateWithoutFormTypeInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serialNumber?: StringFieldUpdateOperationsInput | string;
    consumed?: BoolFieldUpdateOperationsInput | boolean;
    consumedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    order?: OrderUpdateOneWithoutFormSerialsNestedInput;
    addedByAdmin?: UserUpdateOneWithoutAddedFormSerialsNestedInput;
    consumedByAdmin?: UserUpdateOneWithoutConsumedFormSerialsNestedInput;
  };

  export type FormSerialUncheckedUpdateWithoutFormTypeInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serialNumber?: StringFieldUpdateOperationsInput | string;
    orderId?: NullableStringFieldUpdateOperationsInput | string | null;
    consumed?: BoolFieldUpdateOperationsInput | boolean;
    consumedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    addedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    consumedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FormSerialUncheckedUpdateManyWithoutFormTypeInput = {
    id?: StringFieldUpdateOperationsInput | string;
    serialNumber?: StringFieldUpdateOperationsInput | string;
    orderId?: NullableStringFieldUpdateOperationsInput | string | null;
    consumed?: BoolFieldUpdateOperationsInput | boolean;
    consumedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    addedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    consumedByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type OrderCreateManyPromoCodeInput = {
    id?: string;
    userId: string;
    serviceId: string;
    variantId: string;
    status?: string;
    totalPrice: number;
    totalCents: number;
    customerName: string;
    customerPhone: string;
    additionalPhone?: string | null;
    customerEmail: string;
    address?: string | null;
    governorate?: string | null;
    city?: string | null;
    district?: string | null;
    street?: string | null;
    buildingNumber?: string | null;
    apartmentNumber?: string | null;
    landmark?: string | null;
    notes?: string | null;
    adminNotes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    completedAt?: Date | string | null;
    estimatedCompletionDate?: Date | string | null;
    deliveryFee?: number;
    deliveryType?: string;
    createdByAdminId?: string | null;
    birthDate?: Date | string | null;
    fatherName?: string | null;
    idNumber?: string | null;
    motherName?: string | null;
    nationality?: string | null;
    wifeName?: string | null;
    photographyLocation?: string | null;
    photographyDate?: Date | string | null;
    marriageDate?: Date | string | null;
    divorceDate?: Date | string | null;
    wifeMotherName?: string | null;
    quantity?: number;
    serviceDetails?: string | null;
    otherFees?: number;
    discount?: number;
    gender?: string | null;
    policeStation?: string | null;
    pickupLocation?: string | null;
    originalDocuments?: string | null;
    attachedDocuments?: string | null;
    hasAttachments?: boolean;
    selectedFines?: string | null;
    finesDetails?: string | null;
    servicesDetails?: string | null;
    customerFollowUp?: string | null;
    discountAmount?: number;
  };

  export type OrderUpdateWithoutPromoCodeInput = {
    id?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    totalPrice?: IntFieldUpdateOperationsInput | number;
    totalCents?: IntFieldUpdateOperationsInput | number;
    customerName?: StringFieldUpdateOperationsInput | string;
    customerPhone?: StringFieldUpdateOperationsInput | string;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    customerEmail?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveryFee?: IntFieldUpdateOperationsInput | number;
    deliveryType?: StringFieldUpdateOperationsInput | string;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    marriageDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    serviceDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    otherFees?: IntFieldUpdateOperationsInput | number;
    discount?: IntFieldUpdateOperationsInput | number;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    policeStation?: NullableStringFieldUpdateOperationsInput | string | null;
    pickupLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    attachedDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean;
    selectedFines?: NullableStringFieldUpdateOperationsInput | string | null;
    finesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    servicesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    customerFollowUp?: NullableStringFieldUpdateOperationsInput | string | null;
    discountAmount?: IntFieldUpdateOperationsInput | number;
    createdByAdmin?: UserUpdateOneWithoutCreatedOrdersNestedInput;
    documents?: DocumentUpdateManyWithoutOrderNestedInput;
    service?: ServiceUpdateOneRequiredWithoutOrdersNestedInput;
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput;
    variant?: ServiceVariantUpdateOneRequiredWithoutOrdersNestedInput;
    orderDocuments?: OrderDocumentUpdateManyWithoutOrderNestedInput;
    payment?: PaymentUpdateOneWithoutOrderNestedInput;
    formSerials?: FormSerialUpdateManyWithoutOrderNestedInput;
  };

  export type OrderUncheckedUpdateWithoutPromoCodeInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    variantId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    totalPrice?: IntFieldUpdateOperationsInput | number;
    totalCents?: IntFieldUpdateOperationsInput | number;
    customerName?: StringFieldUpdateOperationsInput | string;
    customerPhone?: StringFieldUpdateOperationsInput | string;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    customerEmail?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveryFee?: IntFieldUpdateOperationsInput | number;
    deliveryType?: StringFieldUpdateOperationsInput | string;
    createdByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    marriageDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    serviceDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    otherFees?: IntFieldUpdateOperationsInput | number;
    discount?: IntFieldUpdateOperationsInput | number;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    policeStation?: NullableStringFieldUpdateOperationsInput | string | null;
    pickupLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    attachedDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean;
    selectedFines?: NullableStringFieldUpdateOperationsInput | string | null;
    finesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    servicesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    customerFollowUp?: NullableStringFieldUpdateOperationsInput | string | null;
    discountAmount?: IntFieldUpdateOperationsInput | number;
    documents?: DocumentUncheckedUpdateManyWithoutOrderNestedInput;
    orderDocuments?: OrderDocumentUncheckedUpdateManyWithoutOrderNestedInput;
    payment?: PaymentUncheckedUpdateOneWithoutOrderNestedInput;
    formSerials?: FormSerialUncheckedUpdateManyWithoutOrderNestedInput;
  };

  export type OrderUncheckedUpdateManyWithoutPromoCodeInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    variantId?: StringFieldUpdateOperationsInput | string;
    status?: StringFieldUpdateOperationsInput | string;
    totalPrice?: IntFieldUpdateOperationsInput | number;
    totalCents?: IntFieldUpdateOperationsInput | number;
    customerName?: StringFieldUpdateOperationsInput | string;
    customerPhone?: StringFieldUpdateOperationsInput | string;
    additionalPhone?: NullableStringFieldUpdateOperationsInput | string | null;
    customerEmail?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    governorate?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    district?: NullableStringFieldUpdateOperationsInput | string | null;
    street?: NullableStringFieldUpdateOperationsInput | string | null;
    buildingNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    apartmentNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    landmark?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    deliveryFee?: IntFieldUpdateOperationsInput | number;
    deliveryType?: StringFieldUpdateOperationsInput | string;
    createdByAdminId?: NullableStringFieldUpdateOperationsInput | string | null;
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    fatherName?: NullableStringFieldUpdateOperationsInput | string | null;
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null;
    motherName?: NullableStringFieldUpdateOperationsInput | string | null;
    nationality?: NullableStringFieldUpdateOperationsInput | string | null;
    wifeName?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    photographyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    marriageDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    wifeMotherName?: NullableStringFieldUpdateOperationsInput | string | null;
    quantity?: IntFieldUpdateOperationsInput | number;
    serviceDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    otherFees?: IntFieldUpdateOperationsInput | number;
    discount?: IntFieldUpdateOperationsInput | number;
    gender?: NullableStringFieldUpdateOperationsInput | string | null;
    policeStation?: NullableStringFieldUpdateOperationsInput | string | null;
    pickupLocation?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    attachedDocuments?: NullableStringFieldUpdateOperationsInput | string | null;
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean;
    selectedFines?: NullableStringFieldUpdateOperationsInput | string | null;
    finesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    servicesDetails?: NullableStringFieldUpdateOperationsInput | string | null;
    customerFollowUp?: NullableStringFieldUpdateOperationsInput | string | null;
    discountAmount?: IntFieldUpdateOperationsInput | number;
  };

  /**
   * Aliases for legacy arg types
   */
  /**
   * @deprecated Use UserCountOutputTypeDefaultArgs instead
   */
  export type UserCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = UserCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use CategoryCountOutputTypeDefaultArgs instead
   */
  export type CategoryCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = CategoryCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use ServiceCountOutputTypeDefaultArgs instead
   */
  export type ServiceCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = ServiceCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use ServiceFieldCountOutputTypeDefaultArgs instead
   */
  export type ServiceFieldCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = ServiceFieldCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use ServiceVariantCountOutputTypeDefaultArgs instead
   */
  export type ServiceVariantCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = ServiceVariantCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use OrderCountOutputTypeDefaultArgs instead
   */
  export type OrderCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = OrderCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use FormTypeCountOutputTypeDefaultArgs instead
   */
  export type FormTypeCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = FormTypeCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use PromoCodeCountOutputTypeDefaultArgs instead
   */
  export type PromoCodeCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = PromoCodeCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use AccountDefaultArgs instead
   */
  export type AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    AccountDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use SessionDefaultArgs instead
   */
  export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    SessionDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use VerificationTokenDefaultArgs instead
   */
  export type VerificationTokenArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = VerificationTokenDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use UserDefaultArgs instead
   */
  export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    UserDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use CategoryDefaultArgs instead
   */
  export type CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    CategoryDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use ServiceDefaultArgs instead
   */
  export type ServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    ServiceDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use ServiceFieldDefaultArgs instead
   */
  export type ServiceFieldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    ServiceFieldDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use ServiceFieldOptionDefaultArgs instead
   */
  export type ServiceFieldOptionArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = ServiceFieldOptionDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use ServiceVariantDefaultArgs instead
   */
  export type ServiceVariantArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = ServiceVariantDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use OrderDefaultArgs instead
   */
  export type OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    OrderDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use PaymentDefaultArgs instead
   */
  export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    PaymentDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use AuditLogDefaultArgs instead
   */
  export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    AuditLogDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use FAQDefaultArgs instead
   */
  export type FAQArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    FAQDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use DocumentDefaultArgs instead
   */
  export type DocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    DocumentDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use OrderDocumentDefaultArgs instead
   */
  export type OrderDocumentArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = OrderDocumentDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use ServiceDocumentDefaultArgs instead
   */
  export type ServiceDocumentArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = ServiceDocumentDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use SystemSettingsDefaultArgs instead
   */
  export type SystemSettingsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = SystemSettingsDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use FormTypeDefaultArgs instead
   */
  export type FormTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    FormTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use FormTypeVariantDefaultArgs instead
   */
  export type FormTypeVariantArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = FormTypeVariantDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use FormSerialDefaultArgs instead
   */
  export type FormSerialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    FormSerialDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use DependentDefaultArgs instead
   */
  export type DependentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    DependentDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use PromoCodeDefaultArgs instead
   */
  export type PromoCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    PromoCodeDefaultArgs<ExtArgs>;

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF;
}
